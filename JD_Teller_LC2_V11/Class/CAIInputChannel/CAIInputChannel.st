//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "CAIInputChannel"
	Revision           = "2.20"
	GUID               = "{8995D54C-8CF1-4CCC-806D-DD1EF8319F7E}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Client Name="connectc" Required="true" Internal="false"/>
		<Client Name="EEOffset" Required="true" Internal="false"/>
		<Client Name="Neg" Required="false" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="stewer"/>
		<Dokumentation Revision="2.20" Date="05.12.2013" Author="LanSte&#13;&#10;FucHer" Company="Sigmatek" Description="Added payload support&#13;&#10;Changed AWL code to Structured Text. CyRt Client default value: 1"/>
		<Dokumentation Revision="2.11" Date="04.03.2010" Author="BleErn" Company="Sigmatek" Description="Changes in BaseClass (UpdateRtPostScan)"/>
	</RevDoku>
	<Network Name="CAIInputChannel">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{C1A05AA6-033D-4041-BA16-D37CD75AE2D1}"
				Class      = "DAIInputChnl"
				Position   = "(270,150)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Server Name="State"/>
					<Client Name="BitResolution"/>
					<Client Name="CBias"/>
					<Client Name="channel"/>
					<Client Name="CInvert"/>
					<Client Name="connect"/>
					<Client Name="CScale"/>
					<Client Name="CyRt" Value="1"/>
					<Client Name="TypeofChannel"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Data" Destination="_base.Data" Vertices="(742,210),(570,240),"/>
			<Connection Source="this.State" Destination="_base.State" Vertices="(742,270),(570,300),"/>
			<Connection Source="_base.TypeofChannel" Destination="this.TypeofChannel" Vertices="(270,360),(38,270),"/>
			<Connection Source="_base.CyRt" Destination="this.CyRt" Vertices="(270,420),(38,330),"/>
			<Connection Source="_base.CScale" Destination="this.CScale" Vertices="(270,480),(38,390),"/>
			<Connection Source="_base.CBias" Destination="this.CBias" Vertices="(270,540),(38,450),"/>
			<Connection Source="_base.CInvert" Destination="this.CInvert" Vertices="(270,600),(38,510),"/>
			<Connection Source="_base.BitResolution" Destination="this.BitResolution" Vertices="(270,660),(38,570),"/>
			<Connection Source="_base.channel" Destination="this.channel" Vertices="(270,240),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using DAIInputChnl

CAIInputChannel : CLASS
: DAIInputChnl
  //Servers:
  //Clients:
	connectc 	: CltChCmd_HwBaseCDIAS;
	Neg 	: CltCh_DINT;
	EEOffset 	: CltCh_DINT;
  //Variables:
  //Functions:
				//! <Function Comment="[#ENGLISH]&#13;&#10; *******************************************************&#13;&#10; this is the init method of one input channel&#13;&#10; *******************************************************&#13;&#10;" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION CalFactory1;
				//! <Function Comment="-- overwite this function if there are other offsets ---------------------------&#13;&#10;" Name="GetEEOffset"/>
	FUNCTION VIRTUAL GLOBAL GetEEOffset
		VAR_OUTPUT
			Offset 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL ReCallFactory;
	
	FUNCTION VIRTUAL GLOBAL SetBalanceData;
	
	FUNCTION AWL CalFactory1_AWL;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd HwBaseCDIAS


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB CAIInputChannel::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_CAIINPUTCHANNEL
2$UINT, 20$UINT, (SIZEOF(::CAIInputChannel))$UINT, 
0$UINT, 3$UINT, 0$UINT, 
TO_UDINT(2472734913), "CAIInputChannel", //Class
TO_UDINT(658675781), "DAIInputChnl", 2$UINT, 10$UINT, //Baseclass
//Servers:
//Clients:
(::CAIInputChannel.connectc.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1308000559), "connectc", TO_UDINT(1800499398), "HwBaseCDIAS", 2$UINT, 50$UINT, 
(::CAIInputChannel.Neg.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3774027435), "Neg", 
(::CAIInputChannel.EEOffset.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(173860299), "EEOffset", 
END_FUNCTION


#define USER_CNT_CAIInputChannel 5

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_CAIInputChannel] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION CAIInputChannel::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= DAIInputChnl::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= DAIInputChnl::Data.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, DAIInputChnl::Data.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_CAIInputChannel;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #GetEEOffset();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #SetBalanceData();

#pragma warning (default : 74)
	DAIInputChnl::Data.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DAIInputChnl::Data.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma usingLtd DiasMaster

(****************************************************************************************
*
*	Created : Sigmatek
*	Changes :
*		2.5 => 2.10	/	05.12.2007	/	Mark:	//#SR001
*			- [DB 713]: make compatible to CIV/DIV DataMover
*		1.1 => 2.5	/	06.03.2007	/	Mark:	//#SR000
*			- [DB 421]: now class is ready for plug & play over CIV
*		0.1 => 1.1 / 23.12.2004 / no Mark / ws
*			compatibility with Lasal Class 2
*			removed visible flags from internal servers
*
*****************************************************************************************)

//[#ENGLISH]
// *******************************************************
// this is the init method of one input channel
// *******************************************************
FUNCTION VIRTUAL GLOBAL CAIInputChannel::Init

	channel       := channel.read();
	TypeofChannel := TypeofChannel.read();
	CyRt          := CyRt.read();
	CScale        := CScale.read();
	CBias         := CBias.read(); 
	CInvert 	  := CInvert.read();
	BitResolution := BitResolution.read();
	Neg := Neg.Read();
	EEOffset := EEOffset.Read();

	if BitResolution = 14 then
		udMaxBin := 16000;
	else			  	
		udMaxBin := 4000; 
	end_if;	

	//#SR000 start
	b_VaranAvailable := Connectc.Masterconnect.IsVaranAvailable() <> 0;

	if ( b_VaranAvailable = TRUE ) then
		if firstscan = 0 then
//#SR001			HandleRDValue:=connectc.AddOneChannel(thisp:=this, RTCY:=cyrt, channel:=channel);
			firstscan := 1;
		end_if;
	else
	//#SR000 end
		if connectc.GetEEState() then
			// no data on the EEPROM channel or wrong
			factory.dOffEE := 0;
			factory.dMulEE := 4000;
			factory.dDivEE := 4050;
			CalFactory1();
			if BitResolution = 14 then
				udMaxBin := 16383;
			else			  	
				udMaxBin := 4095; 
			end_if;	
		else
			if firstscan = 0 then
				firstscan:=1; 
				SetBalanceData();
				CalFactory1();
				HandleRDValue:=connectc.AddOneChannel(thisp:=this, RTCY:=cyrt, channel:=channel);
				if BitResolution = 14 then
					udMaxBin := 16383;
				else			  	
					udMaxBin := 4095; 
				end_if;	
			end_if;
		end_if;
	end_if;		//#SR000

END_FUNCTION //VIRTUAL GLOBAL CAIInputChannel::Init
FUNCTION CAIInputChannel::CalFactory1

// -- calculate binary offset

  udBiasBin := (udMaxBin$DINT * CBias / -1000)$UDINT;
  udOffAct  := (udBiasBin$DINT * Factory.dDivEE / Factory.dMulEE + Factory.dOffEE)$UDINT;

// dMulAct

  if Neg = 0 then
    udMulAct := CScale$UDINT;
  else
    udMulAct := (CScale SHL 1)$UDINT;   // *2 weil +/-
  end_if;

// dDivAct

  udDivAct := ((udMaxBin + udBiasBin)$DINT * Factory.dDivEE / Factory.dMulEE)$UDINT;

END_FUNCTION // CAIInputChannel::CalFactory1
FUNCTION AWL CAIInputChannel::CalFactory1_AWL
#ifdef _LSL_TARGETARCH_X86
// -- calculate binary offset

         L.EAX     udMaxBin
         IMUL.D    cBias
         L.EBX     -1000
         IDIV      EBX
         S.EAX     udBiasBin

         IMUL.D    Factory.dDivEE
         IDIV.D    Factory.dMulEE
         ADD.EAX   Factory.dOffEE
         S.EAX     udOffAct

// dMulAct

         L.EAX     cScale
		 CMP.D	   Neg,0
		 JE		   noPlusMinus
		 SHL.EAX   1 // *2 weil +/-
noPlusMinus
         S.EAX     udMulAct

// dDivAct

         L.EAX     udMaxBin
         ADD.EAX   udBiasBin
         IMUL.D    Factory.dDivEE
         IDIV.D    Factory.dMulEE
         S.EAX     udDivAct
#endif
END_FUNCTION // CAIInputChannel::CalFactory1
//-- overwite this function if there are other offsets ---------------------------
FUNCTION VIRTUAL GLOBAL CAIInputChannel::GetEEOffset
VAR_OUTPUT
	Offset		: UINT;
END_VAR

	Offset := EEOffset$UINT + Channel$UINT * 6;

END_FUNCTION //VIRTUAL GLOBAL CAIInputChannel::GetEEOffset

FUNCTION GLOBAL CAIInputChannel::ReCallFactory			//#SR000

	if BitResolution = 14 then
		udMaxBin := 16000;
	else			  	
		udMaxBin := 4000; 
	end_if;	

  SetBalanceData();
	
	CalFactory1();

	if BitResolution = 14 then
		udMaxBin := 16383;
	else			  	
		udMaxBin := 4095; 
	end_if;	

	HandleRDValue:=connectc.AddOneChannel(thisp:=this, RTCY:=cyrt, channel:=channel);		//#SR001

END_FUNCTION //GLOBAL CAIInputChannel::ReCallFactory



FUNCTION VIRTUAL GLOBAL CAIInputChannel::SetBalanceData
  
  factory.dOffEE := TO_DINT (TO_INT(connectc.GetEEData(GetEEOffset()+0)));
  factory.dMulEE := TO_DINT (TO_INT(connectc.GetEEData(GetEEOffset()+2)));
  factory.dDivEE := TO_DINT (TO_INT(connectc.GetEEData(GetEEOffset()+4)));
  
  if factory.dMulEE = 0 |
     factory.dDivEE = 0 then
     
    factory.dMulEE := 4000;
    factory.dDivEE := 4050;
  
  end_if;
      
END_FUNCTION
