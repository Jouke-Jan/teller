//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Jamdetection_TeachIn_Teller"
	Revision           = "1.1"
	GUID               = "{2DC5081F-788D-4F7C-8FB4-B668F43BEB38}"
	RealtimeTask       = "true"
	CyclicTask         = "true"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(540,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{28EA0DFA-C133-47FF-BF21-810230BDF873}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="CopyTeachIn" GUID="{B6251BD0-FFF2-46CF-9898-5E914BF6BC76}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="iEncDiv" GUID="{520F60D8-66F6-40BD-AA6D-FEBDC913F530}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="iEncMulti" GUID="{271BB98B-C466-4BA8-9A9C-166691EC97D6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="JamPauze" GUID="{2905F212-4B7F-4C0E-B410-F03F08169280}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="MaxLengthBox" GUID="{59B56BE0-0439-494D-B16E-FEB3AA869600}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="MinJamSpeed" GUID="{3E84C9B1-DF4F-4144-8DEB-53605992EC34}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="MinSpot" GUID="{2D4E49A6-C1D2-45A7-AF1E-A63FB90B0465}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Nr_Of_JamSensors" GUID="{EEF23528-34CB-4007-BFCA-7749DB047307}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="oJamdetection" GUID="{E9F6D6F3-4DC0-45FF-9347-1C01817C55C0}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="oSpeed" GUID="{5E18BAAC-68DB-434E-BF75-B7343A85F9B0}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ResetJam" GUID="{5E7DC0D1-8789-42AD-9B3D-0AEE86E8B355}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Sectie" GUID="{B6270DF3-AFAF-433C-A463-96DDDFC8A953}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="SectieNrInMachine" GUID="{09830A44-5421-4830-9739-10F91A325234}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="SectieType" GUID="{9F5DC6A5-A5AC-405A-AC66-F4C041B04915}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="sExtraBox" GUID="{AE6885E3-8526-407D-B5B9-16A39D96DDEF}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="SimSpeed" GUID="{193F8D8B-CC15-4315-8E42-8BF022ABBF87}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Simulator" GUID="{5F2866D1-20A4-4512-AB9C-A4F606AB8631}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="TeachIn" GUID="{44A4A566-FEFE-467A-9C65-CB53F9E9EF3C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="c_JamData" Required="true" Internal="false"/>
		<Client Name="c_SectieType" Required="true" Internal="false"/>
		<Client Name="cJamDetect" Required="false" Internal="false" Comment="Status Jamdetect&#13;&#10;1: Detectie&#13;&#10;0: Geen detectie"/>
		<Client Name="cJamDetect2HW" Required="true" Internal="false"/>
		<Client Name="cJamDetectSignal" Required="false" Internal="false" Comment="Knipperende uitgang"/>
		<Client Name="cJamReset" Required="true" Internal="false"/>
		<Client Name="cSensor_01" Required="false" Internal="false"/>
		<Client Name="cSensor_02" Required="false" Internal="false"/>
		<Client Name="cSensor_03" Required="false" Internal="false"/>
		<Client Name="cSimpuls" Required="false" Internal="false"/>
		<Client Name="iEncoder" Required="false" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="jd" Author="SV"/>
		<Dokumentation Revision="1.1" Date="2014-09-16" Author="SV" Company="jd" Description="Clients cSensor_4 tm cSensor_16 verwijderd.&#13;&#10;cSimpuls sensoren verwijderd.&#13;&#10;TaskOnOff server verwijderd.&#13;&#10;TaskOnOff uit RT en CY wordk verwijderd."/>
		<Dokumentation Revision="1.0" Date="2014-09-04" Author="SV" Company="jd" Description="Kopie uit retrofit class versie 1.2. De class haalt de neemt nu de EncMul, EncDiv, MinSpot en &#13;&#10;ExtraBox uit de TellerClass_Teller.&#13;&#10;Client Jampauze ingevoerd, regel 244. Zorgt voor tijdelijk negeren van de jamfunctie."/>
	</RevDoku>
</Class>
*)
Jamdetection_TeachIn_Teller : CLASS
	TYPE
#pragma pack(push, 1)
	  tJam : STRUCT
	    Sensor : ARRAY [0..16] OF DINT;
	    CaseMinSSW : ARRAY [0..16] OF DINT;
	    MinimaleCounter : ARRAY [0..16] OF DINT;
	    Din : ARRAY [0..16] OF DINT;
	    JamBoxlength : ARRAY [0..16] OF DINT;
	    JamBoxLengthCalc : ARRAY [0..16] OF DINT;
	    CaseJam : ARRAY [0..16] OF DINT;
	    Jampos : ARRAY [0..16] OF DINT;
	    Jamdetection : ARRAY [0..16] OF DINT;
	    CaseTeachIn : ARRAY [0..16] OF DINT;
	    TeachInLength : ARRAY [0..16] OF DINT;
	    Holes : ARRAY [0..16] OF DINT;
	    Sensor_Aanwezig : ARRAY [0..16] OF DINT;
	    OnOff : ARRAY [0..16] OF DINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	Sectie 	: SvrCh_tSectie;
	SectieType 	: SvrCh_DINT;
	Nr_Of_JamSensors 	: SvrCh_DINT;
	SectieNrInMachine 	: SvrCh_DINT;
	MinJamSpeed 	: SvrCh_DINT;
	MinSpot 	: SvrCh_DINT;
	sExtraBox 	: SvrCh_DINT;
	iEncMulti 	: SvrCh_DINT;
	iEncDiv 	: SvrCh_DINT;
	oSpeed 	: SvrCh_DINT;
	SimSpeed 	: SvrCh_DINT;
	Simulator 	: SvrCh_DINT;
	MaxLengthBox 	: SvrCh_DINT;
	oJamdetection 	: SvrCh_DINT;
	ResetJam 	: SvrCh_DINT;
	TeachIn 	: SvrCh_DINT;
	CopyTeachIn 	: SvrCh_DINT;
	JamPauze 	: SvrCh_DINT;
  //Clients:
	c_JamData 	: CltChCmd_RAMex;
	c_SectieType 	: CltCh_DINT;
	iEncoder 	: CltCh_DINT;
	cJamDetect 	: CltCh_DINT;
	cJamDetectSignal 	: CltCh_DINT;
	cJamDetect2HW 	: CltCh_DINT;
	cSensor_01 	: CltCh_DINT;
	cSensor_02 	: CltCh_DINT;
	cSensor_03 	: CltCh_DINT;
	cSimpuls 	: CltCh_DINT;
	cJamReset 	: CltCh_DINT;
  //Variables:
		JamData 	: ^tJamDetect;
		Enc 	: Encoder1;
		Jam 	: tJam;
		OSpeedie 	: tOspeed;
		i 	: DINT;
		ii 	: DINT;
		iii 	: DINT;
		Reset 	: DINT;
		Teach 	: DINT;
		Timer 	: UDINT;
		Timer2 	: UDINT;
		Timer3 	: UDINT;
		caseKnipper 	: DINT;
		cJamDetectSignalOld 	: DINT;
		caseJam2HW 	: DINT;
		JamDetPrevState 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Nr_Of_JamSensors::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SectieNrInMachine::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MinJamSpeed::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MinSpot::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL sExtraBox::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL iEncMulti::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL iEncDiv::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MaxLengthBox::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ResetJam::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL TeachIn::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CopyTeachIn::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd RAMex


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Jamdetection_TeachIn_Teller::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_JAMDETECTION_TEACHIN_TELLER
1$UINT, 1$UINT, (SIZEOF(::Jamdetection_TeachIn_Teller))$UINT, 
19$UINT, 11$UINT, 0$UINT, 
TO_UDINT(826277511), "Jamdetection_TeachIn_Teller", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Jamdetection_TeachIn_Teller.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::Jamdetection_TeachIn_Teller.Sectie.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1859271727), "Sectie", 
(::Jamdetection_TeachIn_Teller.SectieType.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1987048131), "SectieType", 
(::Jamdetection_TeachIn_Teller.Nr_Of_JamSensors.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2603717189), "Nr_Of_JamSensors", 
(::Jamdetection_TeachIn_Teller.SectieNrInMachine.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(862555266), "SectieNrInMachine", 
(::Jamdetection_TeachIn_Teller.MinJamSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3574817786), "MinJamSpeed", 
(::Jamdetection_TeachIn_Teller.MinSpot.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3653713552), "MinSpot", 
(::Jamdetection_TeachIn_Teller.sExtraBox.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1270495476), "sExtraBox", 
(::Jamdetection_TeachIn_Teller.iEncMulti.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2623171893), "iEncMulti", 
(::Jamdetection_TeachIn_Teller.iEncDiv.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2837987425), "iEncDiv", 
(::Jamdetection_TeachIn_Teller.oSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1906102849), "oSpeed", 
(::Jamdetection_TeachIn_Teller.SimSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3801008399), "SimSpeed", 
(::Jamdetection_TeachIn_Teller.Simulator.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3305198152), "Simulator", 
(::Jamdetection_TeachIn_Teller.MaxLengthBox.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3318919923), "MaxLengthBox", 
(::Jamdetection_TeachIn_Teller.oJamdetection.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2611080245), "oJamdetection", 
(::Jamdetection_TeachIn_Teller.ResetJam.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2792755174), "ResetJam", 
(::Jamdetection_TeachIn_Teller.TeachIn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(923224972), "TeachIn", 
(::Jamdetection_TeachIn_Teller.CopyTeachIn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3654070086), "CopyTeachIn", 
(::Jamdetection_TeachIn_Teller.JamPauze.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3152771642), "JamPauze", 
//Clients:
(::Jamdetection_TeachIn_Teller.c_JamData.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3006162123), "c_JamData", TO_UDINT(933570811), "RAMex", 1$UINT, 16$UINT, 
(::Jamdetection_TeachIn_Teller.c_SectieType.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1116409912), "c_SectieType", 
(::Jamdetection_TeachIn_Teller.iEncoder.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3545101083), "iEncoder", 
(::Jamdetection_TeachIn_Teller.cJamDetect.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2632337968), "cJamDetect", 
(::Jamdetection_TeachIn_Teller.cJamDetectSignal.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2513455686), "cJamDetectSignal", 
(::Jamdetection_TeachIn_Teller.cJamDetect2HW.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1922428024), "cJamDetect2HW", 
(::Jamdetection_TeachIn_Teller.cSensor_01.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1884571239), "cSensor_01", 
(::Jamdetection_TeachIn_Teller.cSensor_02.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3915192285), "cSensor_02", 
(::Jamdetection_TeachIn_Teller.cSensor_03.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2656708427), "cSensor_03", 
(::Jamdetection_TeachIn_Teller.cSimpuls.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1475202479), "cSimpuls", 
(::Jamdetection_TeachIn_Teller.cJamReset.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2300188886), "cJamReset", 
END_FUNCTION


#define USER_CNT_Jamdetection_TeachIn_Teller 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Jamdetection_TeachIn_Teller] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Jamdetection_TeachIn_Teller::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Jamdetection_TeachIn_Teller, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.RtWork		:= #RtWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SectieNrInMachine.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SectieNrInMachine::Write() );
	IF SectieNrInMachine.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MinJamSpeed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #MinJamSpeed::Write() );
	IF MinJamSpeed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MinSpot.pMeth			:= StoreMethod( #M_RD_DIRECT(), #MinSpot::Write() );
	IF MinSpot.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sExtraBox.pMeth			:= StoreMethod( #M_RD_DIRECT(), #sExtraBox::Write() );
	IF sExtraBox.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	iEncMulti.pMeth			:= StoreMethod( #M_RD_DIRECT(), #iEncMulti::Write() );
	IF iEncMulti.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	iEncDiv.pMeth			:= StoreMethod( #M_RD_DIRECT(), #iEncDiv::Write() );
	IF iEncDiv.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SimSpeed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF SimSpeed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Simulator.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Simulator.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MaxLengthBox.pMeth			:= StoreMethod( #M_RD_DIRECT(), #MaxLengthBox::Write() );
	IF MaxLengthBox.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ResetJam.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ResetJam::Write() );
	IF ResetJam.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	TeachIn.pMeth			:= StoreMethod( #M_RD_DIRECT(), #TeachIn::Write() );
	IF TeachIn.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CopyTeachIn.pMeth			:= StoreMethod( #M_RD_DIRECT(), #CopyTeachIn::Write() );
	IF CopyTeachIn.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	JamPauze.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF JamPauze.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL Jamdetection_TeachIn_Teller::Init
VAR
	ii: DINT;
END_VAR

  if      c_JamData.GetSize() <> sizeof(tJamDetect) then
          c_JamData.SetSize(udSize:=sizeof(tJamDetect));
  end_if;

  if      _FirstScan then
          JamData := (c_JamData.GetDataPtr())$^tJamDetect;
          SectieType := c_SectieType;
          if    SectieType < 1 then
                SectieType := 1;
          elsif SectieType > 12 then
                SectieType := 12;
          end_if;
         
          if    SectieType = 1 then
                Sectie := PreFeeder;
          elsif SectieType = 2 then
                Sectie := TriFeeder;
          elsif SectieType = 3 then
                Sectie := Feeder;
          elsif SectieType = 4 then
                Sectie := MAS;
          elsif SectieType = 5 then
                Sectie := Prefold;
          elsif SectieType = 6 then
                Sectie := A_Sectie;
          elsif SectieType = 7 then
                Sectie := B_Sectie;
          elsif SectieType = 8 then
                Sectie := C_Sectie;
          elsif SectieType = 9 then
                Sectie := FinalFold;
          elsif SectieType = 10 then
                Sectie := F_Unit;
          elsif SectieType = 11 then
                Sectie := Trombone;
          elsif SectieType = 12 then
                Sectie := ConveyorBand;
          end_if;  
  
          Nr_Of_JamSensors.Write(input:=JamData^.NrOfJamSensors);
          MinSpot.Write(input:=JamData^.MinSpot);
          sExtraBox.Write(input:=JamData^.sExtraBox);
          iEncMulti.Write(input:=JamData^.iEncMulti);
          iEncDiv.Write(input:=JamData^.iEncDiv);
          MaxLengthBox.Write(input:=JamData^.T_Doos);
          MinJamSpeed.Write(input:=JamData^.MinJamSpeed);   
          SectieNrInMachine.Write(input:=JamData^.SectieNrInMachine);
          //SV max aantal sensoren
          Nr_Of_JamSensors := 3;
          for ii:= Nr_Of_JamSensors to 16 do
              JamData^.Status[ii] := No_Sensor_Configurated;
          end_for;  
          
          JamData^.NrOfJamSensors := Nr_Of_JamSensors;
  end_if;




END_FUNCTION





FUNCTION VIRTUAL GLOBAL Jamdetection_TeachIn_Teller::RtWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  
//Als in de machine setup de functie is geselelecteerd wordt de code uitgevoerd
   
  
      if  Nr_Of_JamSensors > 0 then

      
      //inlezen van de encoder

        if    SimSpeed <= 0 then
              iEncoder := iEncoder.Read();
        else
              iEncoder += SimSpeed;      
        end_if;

        if    enc.Divider < 1 then
              enc.Divider := 1;
        end_if;



        Enc.EncoderDelta := iEncoder - Enc.EncoderOld;
        Enc.EncoderOld := iEncoder; 
        Enc.SpeedDelta := ((Enc.EncoderDelta * encres * enc.Multi) / enc.Divider);  


        if  ResetJam then
            Reset := 1;
            ResetJam := 0;
        end_if;
        
        
        
        for i:= 1 to Nr_Of_JamSensors do
            
          if Simulator = 0 then //Simulator puls aan of uit
            //Sensoren inlezen
            if    i = 1 then
                  cSensor_01 := cSensor_01.Read();
                  Jam.Sensor[1] := cSensor_01;
            elsif i = 2 then
                  cSensor_02 := cSensor_02.Read();
                  Jam.Sensor[2] := cSensor_02;           
            elsif i = 3 then
                  cSensor_03 := cSensor_03.Read();
                  Jam.Sensor[3] := cSensor_03;
            
            end_if;
          else //simulator puls          SV 16-09-2014 sensoren 4 tm 16 verwijderd
            cSimpuls := cSimpuls.Read();
            Jam.Sensor[1] := cSimpuls;
            Jam.Sensor[2] := cSimpuls;
            Jam.Sensor[3] := cSimpuls;

                                      // SV 16-09-2014 sensoren 4 tm 16 verwijderd
            cSensor_01 :=  Jam.Sensor[1];
            cSensor_02 :=  Jam.Sensor[2];
            cSensor_03 :=  Jam.Sensor[3];


          end_if;

            //Minspot
                case Jam.CaseMinSSW[i] of
                0:
                  if  Jam.Sensor[i] = 1 then
                      Jam.MinimaleCounter[i]:=0;
                      Jam.Din[i]:=0;
                      Jam.CaseMinSSW[i]+=1;
                  end_if;
                1:
                  Jam.MinimaleCounter[i]+= Enc.SpeedDelta;
                 
                  if  Jam.MinimaleCounter[i] > (MinSpot * encres) then
                      if  Jam.Sensor[i] = 1 then
                          Jam.Din[i]:=1;  
                          Jam.CaseMinSSW[i]+=1;  
                      else
                          Jam.CaseMinSSW[i]:=0;
                      end_if;    
                  end_if;
                2: 
                      Jam.Din[i]:=0;
                  if  Jam.Sensor[i] = 0 then
                      Jam.CaseMinSSW[i]:=0;
                  end_if;
                end_case;  
        
            //Jam
                if Jam.JamBoxlength[i] <> 0 & Teach = 0  & Jam.OnOff[i]  then
                    case Jam.CaseJam[i] of     
                    0: //controleren of aan de snipper beveiliging is voldaan 
                       if Jam.Din[i] then                
                          Jam.CaseJam[i] += 1;
                          Jam.Jampos[i] :=  MinSpot * encres;
                          Jam.JamBoxLengthCalc[i] := (Jam.JamBoxlength[i] + sExtraBox) * encres;
                       end_if;
                    1: //Controle op Jamdetect
                       //Kijken of de sensor hoog is na de ingestelde Boxlengte en extra waarde  
                       //Onder een bepaalde snelheid wordt de jamdetect niet aangestuurd
                          Jam.Jampos[i] += Enc.SpeedDelta;                                        
                          if   Jam.Jampos[i] > Jam.JamBoxLengthCalc[i] then //De Jampos loopt nu mee 
                              if   Jam.Sensor[i] & (MinJamSpeed < oSpeed) & (JamPauze = 0) then     //2014-09-04 SV Cient JamPauze ingevoerd.
                                   Jam.Jamdetection[i] := 1;
                                   oJamdetection := 1;
                                   Jam.CaseJam[i] += 1;
                              else                                //Geen Jamdetect!!
                                   Jam.Jamdetection[i] := 0;      //Geen Jamdetect, terug naar stap 0 en wachten op een nieuwe doos
                                   Jam.CaseJam[i] := 0;
                              end_if; 
                          end_if;
                    2:  //Jam, reset is nodig om verder te gaan.
                  
                       if Reset then
                          Jam.Jamdetection[i] := 0;  
                          oJamdetection := 0;
                          //als bij reset de doos niet is weggehaald start de controle opnieuw
                          //if  Jam.Sensor[i] = 1 then
                              //Jam.CaseJam[i] := 1;
                              //Jam.Jampos[i] :=  MinSpot * encres;
                              //Jam.JamBoxLengthCalc[i] := (Jam.JamBoxlength[i] + sExtraBox) * encres;                          
                          //else
                              Jam.CaseJam[i]:=0;
                          
                          //end_if;
                       end_if;
                     end_case;   
                 
                 end_if;  


              //TeachIn
              //Holes kunnen worden gezien
              
              if Teach = 1  then
                  case Jam.CaseTeachIn[i] of
                  0: 
                       if     Jam.Din[i] then                
                              Jam.CaseTeachIn[i] += 1;
                              Jam.Jampos[i] :=  MinSpot * encres;
                       end_if;            
                  1: 
                       Jam.Jampos[i] += Enc.SpeedDelta;
                       
                       //Bij geblokkeerde sensor error aangeven
                       if     jam.Sensor[i] = 1 & Jam.Jampos[i] >= ((MaxLengthBox + sExtraBox) * encres) then
                              Jam.TeachInLength[i] := 0; 
                              JamData^.Status[i] := Box_Oversized;
                              Jam.CaseTeachIn[i] := 3;
                       //Box detected save position     
                       elsif  jam.Sensor[i] = 0  then   
                              Jam.TeachInLength[i] := Jam.Jampos[i];
                              Jam.CaseTeachIn[i] += 1;
                       end_if;

                  2:     
                       Jam.Jampos[i] += Enc.SpeedDelta;
                       
                       //Er is een gat gedetecteerd Hole
                       if     jam.Sensor[i] = 1 & Jam.Jampos[i] < ((MaxLengthBox + sExtraBox) * encres) then
                              Jam.Holes[i] += 1;
                              Jam.CaseTeachIn[i] := 1;
                       //Ready       
                       elsif  jam.Sensor[i] = 0 & Jam.Jampos[i] >= ((MaxLengthBox + sExtraBox) * encres) then 
                              if    jam.holes[i] > 0 then
                                    JamData^.Status[i] := Holes_Detected;
                              else    
                                    JamData^.Status[i] := TeachIn_Ok;
                              end_if; 
                              Jam.CaseTeachIn[i] := 3; 
                       elsif  jam.Sensor[i] = 1 & Jam.Jampos[i] >= ((MaxLengthBox + sExtraBox) * encres) then
                              Jam.TeachInLength[i] := 0; 
                              JamData^.Status[i] := Box_Oversized;
                              Jam.CaseTeachIn[i] := 3;                        
                       end_if;
                  
                  3:   //Ready
                       //Do nothing      
                       
                  end_case;

              end_if;         
        end_for;

        Reset := 0;
      end_if;



	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Jamdetection_TeachIn_Teller::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  
//Als in de machine setup de functie is geselelecteerd wordt de code uitgevoerd

  
      if  Nr_Of_JamSensors > 0 then

        //encoder 

        if iEncDiv = 0 then  
           iEncDiv :=1;
        end_if;
        
        if    SimSpeed <= 0 then
              Enc.Multi   := iEncMulti;
              Enc.Divider := iEncDiv;
              
              OSpeedie.EncIn :=iEncoder;
              ospeedie.EncDelta := OSpeedie.EncIn - OSpeedie.EncOud;
              OSpeedie.EncOud := OSpeedie.EncIn;
              oSpeed := to_dint((to_Real(ospeedie.EncDelta) * 60 * To_Real(Enc.Multi)) / (to_Real(Enc.Divider)*50));
        else            
              Enc.Multi   := 1000;
              Enc.Divider := 60000;
              oSpeed := SimSpeed;
        end_if;  
          

        
        
        for ii:= 1 to Nr_Of_JamSensors do
            Jam.JamBoxlength[ii] := JamData^.JamBoxlength[ii];
            Jam.OnOff[ii] := JamData^.OnOff[ii];
            JamData^.TeachInLength[ii] := jam.TeachInLength[ii];
            
            if  Jam.Jamdetection[ii] = 1 then
                JamData^.Status[ii] := Jam_Detect;
            end_if; 
            
            if  Teach = 0 & (Jam.JamBoxlength[ii] = 0 | Jam.OnOff[ii] = 0)  then
                JamData^.Status[ii] := Turned_Off;
            end_if;
            
            JamData^.TeachInLength[ii] := Jam.TeachInLength[ii]/encres;
            
            JamData^.Sensor[ii] := Jam.Sensor[ii];
        
        end_for;

        
        cJamDetect := oJamdetection;
        cJamDetect.Write(input:=cJamDetect);
        
        if     oJamdetection = 1 then
               //noodstop bedienen 
               if     caseJam2HW = 0 then
                      caseJam2HW := 1;
               end_if;


               case   caseKnipper of
               
               0:
                      timer := ops.tAbsolute; 
                      cJamDetectSignal := 1;
                      caseKnipper := 1;
               
               1:
                      if  ops.tAbsolute - timer > 125 then
                          timer := ops.tAbsolute;
                          caseKnipper := 2;
                      end_if;
               
               2:
                      timer := ops.tAbsolute; 
                      cJamDetectSignal := 0;
                      caseKnipper := 3;


               3:
                      if  ops.tAbsolute - timer > 125 then
                          timer := ops.tAbsolute; 
                          caseKnipper := 0;
                      end_if;           
               end_case;


                 
        else
               caseKnipper := 0;
               cJamDetectSignal := 0;
               
               //noodstop uitsturing moet cyclus afgerond hebben!
               if   caseJam2HW = 3 then
                    caseJam2HW := 0;
               end_if;     
               
        end_if;


        //stopcircuit 1 seconde onderbreken
        case   caseJam2HW   of
         
        0:     //Doe niets 
               
        1:
               cJamDetect2HW := 1;
               cJamDetect2HW.Write(input:=cJamDetect2HW);
               caseJam2HW += 1;
               Timer3 := ops.tAbsolute;       
        
        2:
               //HW uitschakelen     
               if    ops.tAbsolute - Timer3 > 1000 then
                     cJamDetect2HW := 0;
                     cJamDetect2HW.Write(input:=cJamDetect2HW);
                     caseJam2HW += 1;
               end_if;

        3:     //doe niets
                
        end_case;


        if     cJamDetectSignalOld <> cJamDetectSignal  then
               cJamDetectSignalOld := cJamDetectSignal; 
               cJamDetectSignal.Write(input:=cJamDetectSignal); 
               
        end_if;

      end_if;
      


  //SV 29-8-2014. Instellinen die dezelfde waarde hebben als de TellerClass overnemen uit de TellerClass,  zodat dit maar 1 keer hoeft te worden ingegeven..
  MinSpot := JamData^.MinSpot;
  sExtraBox := JamData^.sExtraBox;
  iEncMulti := JamData^.iEncMulti;
  iEncDiv := JamData^.iEncDiv;

	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Jamdetection_TeachIn_Teller::Nr_Of_JamSensors::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	Nr_Of_JamSensors := input;
  if  Nr_Of_JamSensors < 0 | Nr_Of_JamSensors > 16 then
      Nr_Of_JamSensors := 0;  
  end_if;
  
  for ii:= Nr_Of_JamSensors to 16 do
      JamData^.Status[ii] := No_Sensor_Configurated;
  end_for;  
  
  JamData^.NrOfJamSensors := Nr_Of_JamSensors;
  
 	result := Nr_Of_JamSensors;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Jamdetection_TeachIn_Teller::MinSpot::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	MinSpot := input;
  if    MinSpot < 20 then
        MinSpot := 20;
  elsif MinSpot > 100 then
        MinSpot := 20;  
  end_if;

  JamData^.MinSpot := MinSpot;
  
  
 	result := MinSpot;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Jamdetection_TeachIn_Teller::sExtraBox::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	sExtraBox := input;
  if    sExtraBox < 20 then
        sExtraBox := 20;
  elsif sExtraBox > 100 then
        sExtraBox := 20;  
  end_if;  
  JamData^.sExtraBox := sExtraBox;
  
 	result := sExtraBox;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Jamdetection_TeachIn_Teller::iEncMulti::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	iEncMulti := input;
  JamData^.iEncMulti := iEncMulti;
  
 	result := iEncMulti;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Jamdetection_TeachIn_Teller::iEncDiv::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	iEncDiv := input;
  if iEncDiv < 1 then
     iEncDiv := 1; 
  end_if;
  
  JamData^.iEncDiv := iEncDiv;
 	result := iEncDiv;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Jamdetection_TeachIn_Teller::MaxLengthBox::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	MaxLengthBox := input;
  if    MaxLengthBox < 2000 then
        MaxLengthBox := 2000;
  elsif MaxLengthBox > 5000 then
        MaxLengthBox := 5000;  
  end_if;    
  JamData^.T_Doos := MaxLengthBox;
  
 	result := MaxLengthBox;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Jamdetection_TeachIn_Teller::MinJamSpeed::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	MinJamSpeed := input;
  if    MinJamSpeed < 0 | MinJamSpeed > 250  then
        MinJamSpeed := 0;
  end_if;
  JamData^.MinJamSpeed := MinJamSpeed;
  
 	result := MinJamSpeed;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Jamdetection_TeachIn_Teller::ResetJam::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	ResetJam := input;
  
  if  ResetJam < 0 | ResetJam > 1 then
      ResetJam := 0;
  end_if;
  
  for ii:= 1 to Nr_Of_JamSensors do 
     if JamData^.Status[ii] = Jam_Detect then
        JamData^.Status[ii] := Normal_Operation;
     end_if;
  end_for;  
  
 	result := ResetJam;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Jamdetection_TeachIn_Teller::TeachIn::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	TeachIn := input;
  
  //Zonder T waarde doos geen TeachIn!!!
  if    MaxLengthBox = 0 | TeachIn = 0 then
        Teach := 0; 
        
        //Teach in case resettem
        for   iii := 1 to Nr_Of_JamSensors do    
              Jam.CaseTeachIn[iii] := 0;
              jam.Holes[iii] := 0;
              Jam.TeachInLength[iii] := 0;   
              if JamData^.OnOff[iii] > 0 & JamData^.JamBoxlength[iii] > 0 then
                 JamData^.Status[iii] := Normal_Operation;   
              end_if;                 
        end_for;           
        
  else
        Teach := 1;
        TeachIn := 1;

        //Reset eventuele eerdere jamdetect  
        oJamdetection := 0;        
        
        for   iii := 1 to Nr_Of_JamSensors do
              Jam.Jamdetection[iii] := 0;
              Jam.CaseJam[iii]:=0; 
        
              //Start status
              JamData^.Status[iii] := No_Box_Detected;
              
              Jam.CaseTeachIn[iii] := 0;
              jam.Holes[iii] := 0;
              Jam.TeachInLength[iii] := 0;               
              
        end_for;  
  end_if;

  
 	result := TeachIn;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Jamdetection_TeachIn_Teller::CopyTeachIn::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	CopyTeachIn := input;
  
  CopyTeachIn := 0;
  TeachIn := 0;
  Teach := 0;

  for   iii := 1 to Nr_Of_JamSensors do 
        JamData^.JamBoxlength[iii] := Jam.TeachInLength[iii]/ encres;
        if    JamData^.TeachInLength[iii] > 0 then
              JamData^.Status[iii] := Normal_Operation;
        else
              JamData^.Status[iii] := Turned_Off;
        end_if;
  end_for;   
 
 	result := CopyTeachIn;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Jamdetection_TeachIn_Teller::SectieNrInMachine::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	SectieNrInMachine := input;
  if SectieNrInMachine < 0 then
     SectieNrInMachine := 0;  
  end_if;
  if SectieNrInMachine > 18 then
     SectieNrInMachine :=18;  
  end_if;
  
  JamData^.SectieNrInMachine := SectieNrInMachine;
  
 	result := SectieNrInMachine;

END_FUNCTION



