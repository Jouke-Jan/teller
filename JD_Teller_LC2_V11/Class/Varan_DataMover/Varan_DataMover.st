//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Varan_DataMover"
	Revision           = "1.50"
	GUID               = "{2C71BE65-D6D6-45FA-9C48-3862FCEECD99}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(928,120)">
	<Channels>
		<Server Name="ISO_Time" GUID="{B9A25883-1CEE-4E93-A19A-EFDECDDA96DA}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Mover time for RT-Objects (Duration of isochronous list) in µs"/>
		<Server Name="OpcodeError" GUID="{9244B122-A1B3-448C-9125-F4E3FC7AF114}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="State" GUID="{61BF5D12-B132-470B-A0EA-2F408157A1F1}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="Timeout" GUID="{20DCAFD2-3049-41C3-BEDF-1443CD70E79D}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="TimeSliceError" GUID="{37BC71FD-ADDA-485E-88B2-D52F439DD0A7}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="Errorcounter for Timeslice Error"/>
		<Server Name="WishboneError" GUID="{DCE948F2-9534-40C6-AB85-91F0576E74A8}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="AddDIASTime" Required="false" Internal="false" Comment="in µs (0=default -&gt; DIAS and Varan Splitt time)"/>
		<Client Name="CodeSize" Required="true" Internal="false"/>
		<Client Name="CodeStartAddress" Required="true" Internal="false" Comment="code start address of data mover"/>
		<Client Name="DPRAM_Size" Required="true" Internal="false" Comment="size of DPRAM for Data Mover"/>
		<Client Name="DPRAM_StartAddress" Required="true" Internal="false" Comment="data start address of data mover (DPRAM)"/>
		<Client Name="DPRAM_StartAddress_SUBBus" Required="true" Internal="false" Comment="DPRAM address in sub bus system"/>
		<Client Name="TimeSliceErrorOn" Required="true" Internal="false" Comment="1=hold on by timeslice error"/>
		<Client Name="To_Multitask" Required="false" Internal="false" Comment="is connected automatically"/>
		<Client Name="To_StdLib" Required="false" Internal="false"/>
		<Client Name="VaranIn" Required="true" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\Varan_DataMover\Varan_DataMover.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="renste"/>
		<Dokumentation Revision="1.50" Date="12.02.2014" Author="PieSte" Company="Sigmatek" Description="Add read Client CodeStartAddress, CodeSize and TimeSliceErrorOn in Init to set value with connected server."/>
		<Dokumentation Revision="1.40" Date="04.12.2013" Author="LanSte&#13;&#10;&#13;&#10;ZoePat&#13;&#10;&#13;&#10;Peeale" Company="Sigmatek" Description="Changed Diect access Polling to a repeat until loop.&#13;&#10;Added Trace Messages if the Direct access failed.&#13;&#10;Moved DirectAccess to start the ISO-List from first RT-run to Varan_Callback, to prevent a TimeSliceError at startup.&#13;&#10;Added payload support"/>
		<Dokumentation Revision="1.30" Date="18.07.2013" Author="ZoePat&#13;&#10;RamAnd" Company="Sigmatek" Description="Added possibility to move data on CDIAS behind DataMover.&#13;&#10;The returncode of the CyWork method, which is used by the superior class, wasn&apos;t initialized in all cases."/>
		<Dokumentation Revision="1.20" Date="07.03.2013" Author="RamAnd" Company="Sigmatek" Description="Removed useless dummy memory allocation when adding ISO Read accesses.&#13;&#10;Made some time optimizations in for loops (use pointers instead of array accesses)&#13;&#10;Corrected handshake with OS for admin list of mover and corrected names of internal structure elements."/>
		<Dokumentation Revision="1.17" Date="16.08.2012" Author="BleErn" Company="Sigmatek" Description="Starting mover task for safety-modules was not thread safe.&#13;&#10;Added types for control and state register."/>
		<Dokumentation Revision="1.16" Date="27.06.2011" Author="RamAnd" Company="Sigmatek" Description="Support of sorting VARAN commands by priority added (needed for communication between safety-modules)."/>
		<Dokumentation Revision="1.15" Date="21.09.2011" Author="RamAnd" Company="Sigmatek" Description="Ensure to have a valid VARAN node string before creating a data object."/>
		<Dokumentation Revision="1.14" Date="11.05.2011" Author="RamAnd" Company="Sigmatek" Description="Don&apos;t wait for the mover to be finished with asychron code, if there is no code. Otherwise no cyclic update methods of connected objects are called."/>
		<Dokumentation Revision="1.13" Date="04.01.2011" Author="BleErn" Company="Sigmatek" Description="Added Client Transparent that allows to disable a VARAN-HW-Class"/>
		<Dokumentation Revision="1.12" Date="04.11.2010" Author="RamAnd" Company="Sigmatek" Description="If the module has been disconnected from VARAN, it was still possible to start a direct access on it, which lead to a problem when the module was connected again."/>
		<Dokumentation Revision="1.11" Date="15.10.2010" Author="BleErn" Company="Sigmatek" Description="Error of last change was caused  by a compiler error (Version 2)&#13;&#10;To improve readability of code cast was changed again"/>
		<Dokumentation Revision="1.10" Date="08.07.2010" Author="WocPet" Company="Sigmatek" Description="A pointer was casted to a wrong type - so a access exception was possible -&gt; corrected"/>
		<Dokumentation Revision="1.9" Date="23.02.2010" Author="WocPet" Company="Sigmatek" Description="Error with reconnection corrected (DO_Created :=  false) #WP003a"/>
		<Dokumentation Revision="1.8" Date="17.02.2010" Author="WocPet" Company="Sigmatek" Description="Reorganisation of DO creation if mover was active -&gt; new function implemented: &quot;Create DOs&quot; and the 4 methods &quot;GetMemory...&quot; are corrected&#13;&#10;//#WP003"/>
		<Dokumentation Revision="1.7" Date="28.01.2010" Author="RamAnd" Company="Sigmatek" Description="New DataMover OS functions are now only executed, when available (lead to crash)"/>
		<Dokumentation Revision="1.6" Date="18.12.2009" Author="RamAnd" Company="Sigmatek" Description="Added functionality to use Safety modules with activated Mover"/>
		<Dokumentation Revision="1.5" Date="20.07.2009" Author="ObeChr" Company="Sigmatek" Description="Required was ignored by setting StatusBits, now using SetRunState in VaranBase"/>
		<Dokumentation Revision="1.4" Date="09.04.2009" Author="wocpet" Company="Sigmatek" Description="problem with create semaphore - in complex classes solved&#13;&#10;WriteCode Methode doesn`t work with CIV513 =&gt; retval -27; Timeout calculation now corrected"/>
	</RevDoku>
</Class>
*)
Varan_DataMover : CLASS
	TYPE
#pragma pack(push, 1)
	  t_StructMove : STRUCT
	    us_Command : USINT;
	    ui_Length : UINT;
	    us_Length : USINT;
	    ud_SourceAdd : UDINT;
	    ud_DestAdd : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_DAData : STRUCT
	    b_Init : BOOL;
	    ud_CodeAddress : UDINT;
	    ud_DataAddress : UDINT;
	    ud_DataAddressSub : UDINT;
	    ud_StartAddress : UDINT;
	    ud_RetryTimeout : UDINT;
	    s_DAMove : t_StructMove;
	  END_STRUCT;
#pragma pack(pop)
	  t_MoverConfigReg : BSINT
	  [
	    1 MoverEnable,
	    2 SyncListEnable,
	    3 AdminEnable,
	    4 AsyncListEnable,
	    5 DiasAliveEnable,
	    6 HoldOPError,
	    7 HoldWBError,
	    8 HoldTimeSliceError,
	  ];
	  t_MoverStateReg : BSINT
	  [
	    1 MoverActive,
	    2 SyncActive,
	    3 AdminActive,
	    4 AsyncActive,
	  ];
#pragma pack(push, 1)
	  t_DataMoverConfig : STRUCT
	    us_ControlReg : t_MoverConfigReg;
	    us_StateReg : t_MoverStateReg;
	    us_Reserved : USINT;
	    us_ErrorReg : BSINT
	    [
	      1 OPCodeError0,
	      2 OPCodeError1,
	      3 OPCodeError2,
	      4 OPCodeError3,
	      5 WishboneError,
	      6 TimeSliceError,
	    ];
	    ud_SyncTimeReg : UDINT;
	    ud_AsyncTimeReg : UDINT;
	    ud_DATimeReg : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_DO_Config : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_Settings : ^t_VaranDOSettingsRd;
	    p_DataRead : ^t_DataMoverConfig;
	    us_OldRetryCounter : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_DO_ISOTime : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_Settings : ^t_VaranDOSettingsRd;
	    p_DataRead : ^UINT;
	    us_OldRetryCounter : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_DO_RD : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_Settings : ^t_VaranDOSettingsRd;
	    p_DataRead : ^USINT;
	    us_OldRetryCounter : USINT;
	    us_Length : USINT;
	    ud_Priority : HDINT;
	    b_DOIsRunning : t_SingleRunState;
	    p_UserDOHandle : ^UDINT;  //! <Type Comment="Optional Parameter&#13;&#10;If this pointer is set:&#13;&#10;Once the VaranDOs are created the DO Handle is saved to the passed address.&#13;&#10;Parameter added to get the Handle for the Payload Move DOs." Name="t_DO_RD.p_UserDOHandle"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_DO_StartAsyncList : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_Settings : ^t_VaranDOSettingsWr;
	    p_DataWrite : ^USINT;
	    us_OldRetryCounter : USINT;
	    b_DOIsRunning : t_SingleRunState;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_DO_WR : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_Settings : ^t_VaranDOSettingsWr;
	    p_DataWrite : ^USINT;
	    us_OldRetryCounter : USINT;
	    us_Length : USINT;
	    ud_Priority : HDINT;
	    b_DOIsRunning : t_SingleRunState;
	    p_UserDOHandle : ^UDINT;  //! <Type Comment="Optional Parameter&#13;&#10;If this pointer is set:&#13;&#10;Once the VaranDOs are created the DO Handle is saved to the passed address.&#13;&#10;Parameter added to get the Handle for the Payload Move DOs." Name="t_DO_WR.p_UserDOHandle"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_FastDA : STRUCT
	    ud_Address : UDINT;
	    us_Control : USINT;
	    us_Bytes : USINT;
	    a_Data : ARRAY [0..121] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ListConfig : STRUCT
	    ui_SyncListStart : UINT;
	    ui_Reserved1 : UINT;
	    ui_SyncListEnd : UINT;
	    ui_Reserved2 : UINT;
	    ui_AsyncListStart : UINT;
	    ui_Reserved3 : UINT;
	    ui_AsyncListEnd : UINT;
	    ui_Reserved4 : UINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_Settings : STRUCT
	    ui_DPRAMOffset : UINT;
	    ui_DPRAMOffsetSub : UINT;
	    ui_DPRAMSize : UINT;
	    us_DOCount : USINT;
	    b_DOIsRunning : t_SingleRunState;
	  END_STRUCT;
#pragma pack(push, 1)
	  t_StructDelay : STRUCT
	    us_Command : USINT;
	    ui_DelayTime : UINT;
	    us_DelayTime : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_StructEnd : STRUCT
	    us_Command : USINT;
	    us_Reserved : USINT;
	    ui_Reserved : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_StructMoveEn : STRUCT
	    us_Command : USINT;
	    ui_Length : UINT;
	    us_Length : USINT;
	    ud_SourceAdd : UDINT;
	    ud_DestAdd : UDINT;
	    ud_EnableAddByte : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	State 	: SvrChCmd_t_e_VaranErrors;
	Timeout 	: SvrCh_DINT;
	TimeSliceError 	: SvrCh_DINT;
	WishboneError 	: SvrCh_DINT;
	OpcodeError 	: SvrCh_DINT;
	ISO_Time 	: SvrCh_UDINT;
  //Clients:
	VaranIn 	: CltChCmd_Varan_Base;
	DPRAM_StartAddress 	: CltCh_HDINT;
	DPRAM_StartAddress_SUBBus 	: CltCh_HDINT;
	DPRAM_Size 	: CltCh_UDINT;
	CodeStartAddress 	: CltCh_HDINT;
	CodeSize 	: CltCh_UDINT;
	To_StdLib 	: CltChCmd__StdLib;
	To_Multitask 	: CltChCmd__MultiTask;
	TimeSliceErrorOn 	: CltCh_DINT;
	AddDIASTime 	: CltCh_UDINT;
  //Variables:
		a_DO_ISO_RD : ARRAY [0..VM_DATAMOVER_MAX_DO-1] OF t_DO_RD;

		s_Set_ISO_RD 	: t_Settings;
		a_DO_ISO_WR : ARRAY [0..VM_DATAMOVER_MAX_DO-1] OF t_DO_WR;

		s_Set_ISO_WR 	: t_Settings;
		a_DO_ASY_RD : ARRAY [0..VM_DATAMOVER_MAX_DO-1] OF t_DO_RD;

		s_Set_ASY_RD 	: t_Settings;
		a_DO_ASY_WR : ARRAY [0..VM_DATAMOVER_MAX_DO-1] OF t_DO_WR;

		s_Set_ASY_WR 	: t_Settings;
		s_ConfigDO 	: t_DO_Config;
		s_ConfigWrDO 	: t_DO_StartAsyncList;
		s_ISO_Time_DO 	: t_DO_ISOTime;
		a_SpecialDO : ARRAY [0..9] OF t_DO_WR;

		us_SpecialDOCnt 	: USINT;
		p_ISOMoverCode 	: ^USINT;
		ui_ISOByteCount 	: UINT;
		p_ASYMoverCode 	: ^USINT;
		ui_ASYByteCount 	: UINT;
		us_Firstscan 	: USINT;
		ud_VaranManagerNr 	: UDINT;
		pVaran 	: ^LSL_VARAN;
		p_NodeInfo 	: ^LSL_VARANNODEINFO;
		p_NodeString 	: ^USINT;
		ud_DeviceAddress 	: UDINT;
		sd_Required 	: DINT;
		s_Config 	: t_DataMoverConfig;
		s_ListSettings 	: t_ListConfig;
		s_DAData 	: t_DAData;
		s_End 	: t_StructEnd;
		ui_EndAddressOff 	: UINT;
		us_Wait 	: USINT;
		p_SemaHandle 	: ^void;
		s_FastDAData 	: t_FastDA;
		us_ASYDOCount 	: USINT;
		ui_OldISOCounter 	: UINT;
		ud_MoverDPRAM_Used 	: UDINT;
		pHardwareTree 	: ^LSL_HARDWARETREE;
		b_AdminStarted 	: BOOL;
		us_ControlRd 	: t_MoverStateReg;
		ud_AdminCnt 	: UDINT;
		DO_Created 	: BOOL;
		p_DummyDataRdWr 	: ^USINT;
		b_PayloadSupport 	: BOOL;
		ud_HandleModule 	: UDINT;
		pMultiVaran 	: ^LSL_MULTI_VARAN;
  //Functions:
				//! <Function Comment="=================================================================================================&#13;&#10;Construction of class&#13;&#10;=================================================================================================&#13;&#10;" Name="Varan_DataMover"/>
	FUNCTION Varan_DataMover
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="=================================================================================================&#13;&#10;Init of class&#13;&#10;=================================================================================================&#13;&#10;" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="=================================================================================================&#13;&#10;Cy Function of Varan Data Mover&#13;&#10;=================================================================================================&#13;&#10;" Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="=================================================================================================&#13;&#10;Rt Function of Varan Data Mover&#13;&#10;=================================================================================================&#13;&#10;" Name="RtWork"/>
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function for Varan Callback&#13;&#10;=================================================================================================&#13;&#10;" Name="Varan_Callback"/>
	FUNCTION GLOBAL Varan_Callback
		VAR_INPUT
			ud_reason 	: UDINT;			//! <Variable Comment="reason of callback" Name="Varan_Callback.ud_reason"/>
			ud_data 	: UDINT;			//! <Variable Comment="data of callback" Name="Varan_Callback.ud_data"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;			//! <Variable Comment=" 0=OK, negative=error (look lsl_st_varan.h)" Name="Varan_Callback.sd_retval"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="DirectAccessRead"/>
	FUNCTION GLOBAL DirectAccessRead
		VAR_INPUT
			ud_address 	: UDINT;			//! <Variable Comment="address of write access" Name="DirectAccessRead.ud_address"/>
			ud_length 	: UDINT;			//! <Variable Comment="max. 128 Byte access" Name="DirectAccessRead.ud_length"/>
			p_data 	: ^void;			//! <Variable Comment="address of pointer (pointer value is set)" Name="DirectAccessRead.p_data"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="DirectAccessWrite"/>
	FUNCTION GLOBAL DirectAccessWrite
		VAR_INPUT
			ud_address 	: UDINT;
			ud_length 	: UDINT;
			p_data 	: ^void;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a ISO Rd command&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRdISO"/>
	FUNCTION GLOBAL AddRdISO
		VAR_INPUT
			ud_add 	: UDINT;			//! <Variable Comment="address of access" Name="AddRdISO.ud_add"/>
			ud_length 	: UDINT;
			p_data 	: ^void;
			ud_Priority 	: HDINT := 0;
			p_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddRdISO.p_DataAddr"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a ISO Wr command&#13;&#10;=================================================================================================&#13;&#10;" Name="AddWrISO"/>
	FUNCTION GLOBAL AddWrISO
		VAR_INPUT
			ud_add 	: UDINT;
			ud_length 	: UDINT;
			p_data 	: ^void;
			ud_Priority 	: HDINT := 0;
			p_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddWrISO.p_DataAddr"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a ASY Rd command&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRdASY"/>
	FUNCTION GLOBAL AddRdASY
		VAR_INPUT
			ud_add 	: UDINT;
			ud_length 	: UDINT;
			p_data 	: ^void;
			ud_Priority 	: HDINT := 0;
			p_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddRdASY.p_DataAddr"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a ASY Wr command&#13;&#10;=================================================================================================&#13;&#10;" Name="AddWrASY"/>
	FUNCTION GLOBAL AddWrASY
		VAR_INPUT
			ud_add 	: UDINT;
			ud_length 	: UDINT;
			p_data 	: ^void;
			ud_Priority 	: HDINT := 0;
			p_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddWrASY.p_DataAddr"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="=================================================================================================&#13;&#10;Function that varan class gets retry counter&#13;&#10;=================================================================================================&#13;&#10;" Name="GetRetryCounter"/>
	FUNCTION GLOBAL GetRetryCounter
		VAR_OUTPUT
			ud_retries 	: UDINT;
		END_VAR;
				//! <Function Comment="=================================================================================================&#13;&#10;Function to set off all DO&apos;s&#13;&#10;=================================================================================================&#13;&#10;" Name="SetDOsOff"/>
	FUNCTION GLOBAL SetDOsOff;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a Delay on a list&#13;&#10;=================================================================================================&#13;&#10;" Name="AddDelay"/>
	FUNCTION GLOBAL AddDelay
		VAR_INPUT
			ud_task 	: UDINT;			//! <Variable Comment="VARAN_DOL_ISO = Realtime, VARAN_DOL_ASY= Cyclic" Name="AddDelay.ud_task"/>
			ud_time 	: UDINT;			//! <Variable Comment="delay time in µs" Name="AddDelay.ud_time"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="=================================================================================================&#13;&#10;Function to set Pointers for DA&#13;&#10;=================================================================================================&#13;&#10;" Name="SetDASettings"/>
	FUNCTION GLOBAL SetDASettings
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a ISO Wr command on first position (necessary for DIAS - Sync)&#13;&#10;=================================================================================================&#13;&#10;" Name="AddFirstWrISO"/>
	FUNCTION GLOBAL AddFirstWrISO
		VAR_INPUT
			ud_add 	: UDINT;
			ud_length 	: UDINT;
			p_data 	: ^void;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="=================================================================================================&#13;&#10;Function to start ASY List&#13;&#10;=================================================================================================&#13;&#10;" Name="StartAsyncList"/>
	FUNCTION StartAsyncList;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add an ISO Rd Enable&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRdISOEnable"/>
	FUNCTION GLOBAL AddRdISOEnable
		VAR_INPUT
			ud_add 	: UDINT;
			ud_length 	: UDINT;
			p_data 	: ^void;
			p_enable 	: ^USINT;			//! <Variable Comment="address of pointer to start single call" Name="AddRdISOEnable.p_enable"/>
			ud_Priority 	: HDINT := 0;
			p_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddRdISOEnable.p_DataAddr"/>
			p_UserDOHandle 	: ^UDINT := NIL;			//! <Variable Comment="Optional Parameter&#13;&#10;Once the VaranDOs are created the DO Handle is saved to the passed address.&#13;&#10;Parameter added to get the Handle for the Payload Move DOs." Name="AddRdISOEnable.p_UserDOHandle"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add an ISO Wr Enable&#13;&#10;=================================================================================================&#13;&#10;" Name="AddWrISOEnable"/>
	FUNCTION GLOBAL AddWrISOEnable
		VAR_INPUT
			ud_add 	: UDINT;
			ud_length 	: UDINT;
			p_data 	: ^void;
			p_enable 	: ^USINT;
			ud_Priority 	: HDINT := 0;
			p_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddWrISOEnable.p_DataAddr"/>
			p_UserDOHandle 	: ^UDINT := NIL;			//! <Variable Comment="Optional Parameter&#13;&#10;Once the VaranDOs are created the DO Handle is saved to the passed address.&#13;&#10;Parameter added to get the Handle for the Payload Move DOs." Name="AddWrISOEnable.p_UserDOHandle"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add an ASY Rd Enable&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRdASYEnable"/>
	FUNCTION GLOBAL AddRdASYEnable
		VAR_INPUT
			ud_add 	: UDINT;
			ud_length 	: UDINT;
			p_data 	: ^void;
			p_enable 	: ^USINT;
			ud_Priority 	: HDINT := 0;
			p_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddRdASYEnable.p_DataAddr"/>
			p_UserDOHandle 	: ^UDINT := NIL;			//! <Variable Comment="Optional Parameter&#13;&#10;Once the VaranDOs are created the DO Handle is saved to the passed address.&#13;&#10;Parameter added to get the Handle for the Payload Move DOs." Name="AddRdASYEnable.p_UserDOHandle"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add an ASY Wr Enable&#13;&#10;=================================================================================================&#13;&#10;" Name="AddWrASYEnable"/>
	FUNCTION GLOBAL AddWrASYEnable
		VAR_INPUT
			ud_add 	: UDINT;
			ud_length 	: UDINT;
			p_data 	: ^void;
			p_enable 	: ^USINT;
			ud_Priority 	: HDINT := 0;
			p_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddWrASYEnable.p_DataAddr"/>
			p_UserDOHandle 	: ^UDINT := NIL;			//! <Variable Comment="Optional Parameter&#13;&#10;Once the VaranDOs are created the DO Handle is saved to the passed address.&#13;&#10;Parameter added to get the Handle for the Payload Move DOs." Name="AddWrASYEnable.p_UserDOHandle"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get next free space for ISO read&#13;&#10;=================================================================================================&#13;&#10;" Name="GetMemoryISORd"/>
	FUNCTION GetMemoryISORd
		VAR_INPUT
			p_add 	: ^UDINT;			//! <Variable Comment="value for destination address" Name="GetMemoryISORd.p_add"/>
			p_data 	: ^void;
			ud_len 	: UDINT;			//! <Variable Comment="length of data" Name="GetMemoryISORd.ud_len"/>
			ud_Priority 	: HDINT := 0;
			p_UserDOHandle 	: ^UDINT := NIL;			//! <Variable Comment="Optional Parameter&#13;&#10;Once the VaranDOs are created the DO Handle is saved to the passed address.&#13;&#10;Parameter added to get the Handle for the Payload Move DOs." Name="GetMemoryISORd.p_UserDOHandle"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get next free space for ISO write&#13;&#10;=================================================================================================&#13;&#10;" Name="GetMemoryISOWr"/>
	FUNCTION GetMemoryISOWr
		VAR_INPUT
			p_add 	: ^UDINT;
			p_data 	: ^void;
			ud_len 	: UDINT;
			ud_Priority 	: HDINT := 0;
			p_UserDOHandle 	: ^UDINT := NIL;			//! <Variable Comment="Optional Parameter&#13;&#10;Once the VaranDOs are created the DO Handle is saved to the passed address.&#13;&#10;Parameter added to get the Handle for the Payload Move DOs." Name="GetMemoryISOWr.p_UserDOHandle"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get next free space for ASY read&#13;&#10;=================================================================================================&#13;&#10;" Name="GetMemoryASYRd"/>
	FUNCTION GetMemoryASYRd
		VAR_INPUT
			p_add 	: ^UDINT;
			p_data 	: ^void;
			ud_len 	: UDINT;
			ud_Priority 	: HDINT := 0;
			p_UserDOHandle 	: ^UDINT := NIL;			//! <Variable Comment="Optional Parameter&#13;&#10;Once the VaranDOs are created the DO Handle is saved to the passed address.&#13;&#10;Parameter added to get the Handle for the Payload Move DOs." Name="GetMemoryASYRd.p_UserDOHandle"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get next free space for ASY write&#13;&#10;=================================================================================================&#13;&#10;" Name="GetMemoryASYWr"/>
	FUNCTION GetMemoryASYWr
		VAR_INPUT
			p_add 	: ^UDINT;
			p_data 	: ^void;
			ud_len 	: UDINT;
			ud_Priority 	: HDINT := 0;
			p_UserDOHandle 	: ^UDINT := NIL;			//! <Variable Comment="Optional Parameter&#13;&#10;Once the VaranDOs are created the DO Handle is saved to the passed address.&#13;&#10;Parameter added to get the Handle for the Payload Move DOs." Name="GetMemoryASYWr.p_UserDOHandle"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to set DIAS Alvie Signal Address&#13;&#10;=================================================================================================&#13;&#10;" Name="SetDiasAliveSignal"/>
	FUNCTION GLOBAL SetDiasAliveSignal
		VAR_INPUT
			ud_address 	: UDINT;
			us_mode 	: USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="=================================================================================================&#13;&#10;Function check if we have enough code space&#13;&#10;=================================================================================================&#13;&#10;" Name="CheckLengthOfCode"/>
	FUNCTION CheckLengthOfCode
		VAR_OUTPUT
			b_available 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to write code to DPRAM&#13;&#10;=================================================================================================&#13;&#10;" Name="WriteCode"/>
	FUNCTION WriteCode
		VAR_INPUT
			ud_address 	: UDINT;
			ud_length 	: UDINT;
			p_data 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get actual pointer to code address&#13;&#10;=================================================================================================&#13;&#10;" Name="GetActualAddressPointerISO"/>
	FUNCTION GLOBAL GetActualAddressPointerISO
		VAR_INPUT
			ud_type 	: UDINT;			//! <Variable Comment="0=control area, 1=memory area" Name="GetActualAddressPointerISO.ud_type"/>
		END_VAR
		VAR_OUTPUT
			ud_add_off 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get actual pointer to code address&#13;&#10;=================================================================================================&#13;&#10;" Name="GetActualAddressPointerASY"/>
	FUNCTION GLOBAL GetActualAddressPointerASY
		VAR_INPUT
			ud_type 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ud_add_off 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to install special write DO (for CRIF)&#13;&#10;=================================================================================================&#13;&#10;" Name="AddVaranWrDO"/>
	FUNCTION GLOBAL AddVaranWrDO
		VAR_INPUT
			ud_dol_type 	: UDINT;			//! <Variable Comment=" pointer to variable to set right handle" Name="AddVaranWrDO.ud_dol_type"/>
			p_ud_handle 	: ^UDINT;			//! <Variable Comment="pointer to variable to set right handle" Name="AddVaranWrDO.p_ud_handle"/>
			ud_address 	: UDINT;
			ud_length 	: UDINT;
			p_ud_data 	: ^UDINT;			//! <Variable Comment=" pointer to variable to get pointer to data" Name="AddVaranWrDO.p_ud_data"/>
			ud_type 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL SafetyMoverDisable;
	
	FUNCTION GLOBAL SafetyMoverEnable
		VAR_INPUT
			MoverActive 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL SafetyMoverConfigured;
	
	FUNCTION GLOBAL CreateDOs;
	
	FUNCTION GLOBAL AddMoveISO
		VAR_INPUT
			SourceAddr 	: HDINT;
			DestAddr 	: HDINT;
			MoveLen 	: UDINT;
			pEnable 	: ^USINT;
			udPriority 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL AddMoveASY
		VAR_INPUT
			SourceAddr 	: HDINT;
			DestAddr 	: HDINT;
			MoveLen 	: UDINT;
			pEnable 	: ^USINT;
			udPriority 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _MultiTask
#pragma usingLtd _StdLib
#pragma usingLtd Varan_Base


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Varan_DataMover::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_VARAN_DATAMOVER
1$UINT, 50$UINT, (SIZEOF(::Varan_DataMover))$UINT, 
6$UINT, 10$UINT, 0$UINT, 
TO_UDINT(3752737333), "Varan_DataMover", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Varan_DataMover.State.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1422331979), "State", 
(::Varan_DataMover.Timeout.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3187968904), "Timeout", 
(::Varan_DataMover.TimeSliceError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3328036040), "TimeSliceError", 
(::Varan_DataMover.WishboneError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2644894044), "WishboneError", 
(::Varan_DataMover.OpcodeError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(66811495), "OpcodeError", 
(::Varan_DataMover.ISO_Time.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2110111691), "ISO_Time", 
//Clients:
(::Varan_DataMover.VaranIn.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2999796184), "VaranIn", TO_UDINT(862125188), "Varan_Base", 2$UINT, 2$UINT, 
(::Varan_DataMover.DPRAM_StartAddress.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2822515763), "DPRAM_StartAddress", 
(::Varan_DataMover.DPRAM_StartAddress_SUBBus.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1079902826), "DPRAM_StartAddress_SUBBus", 
(::Varan_DataMover.DPRAM_Size.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(442651590), "DPRAM_Size", 
(::Varan_DataMover.CodeStartAddress.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1570536194), "CodeStartAddress", 
(::Varan_DataMover.CodeSize.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2495125110), "CodeSize", 
(::Varan_DataMover.To_StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2139173287), "To_StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::Varan_DataMover.To_Multitask.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2145650779), "To_Multitask", TO_UDINT(2641766936), "_MultiTask", 1$UINT, 0$UINT, 
(::Varan_DataMover.TimeSliceErrorOn.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(917321762), "TimeSliceErrorOn", 
(::Varan_DataMover.AddDIASTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3621304464), "AddDIASTime", 
END_FUNCTION


#define USER_CNT_Varan_DataMover 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Varan_DataMover] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Varan_DataMover::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Varan_DataMover, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.RtWork		:= #RtWork();
	State.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	TimeSliceError.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF TimeSliceError.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= Varan_DataMover();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma usingLtd Hub_Base
VAR_PRIVATE
  MtxCnt : UINT;
END_VAR


(************************************************************************************
*
*	Class for Varan Data Mover
*	Created : Sigmatek	/	SR	/	2007
*	Changes :
*
*
*     FOR NEWER CHANGES SEE REVISION DOCUMENTATION IN CLASS PROPERTIES
*
*
*		1.2 => 1.3	/ 14.05.2008
*			- [DB 857]:	check asyncListEnable bit instead of AsyncActive Bit for AsyncList of DataMover  
*			- [DB 859]: optimize Diasbus efficiency 
*		1.1 => 1.2	/	14.02.2008
*			- [ DB713 ]: check size of free memory for code table when adding a new DO
*           - [ DB713 ]: implement counter for special DO
*		1.0 => 1.1	/	23.01.2008
*			- [ DB713 ]: insert function to get pointers (specially for CRIF)
*
************************************************************************************)


//=================================================================================================
//Construction of class
//=================================================================================================
FUNCTION  Varan_DataMover::Varan_DataMover
  VAR_OUTPUT
    ret_code		: CONFSTATES;
  END_VAR

	//opcode for end command
	s_End.us_Command 	:= VM_DATAMOVER_END_OP;

	//split dpram in 4 sections
	s_Set_ISO_RD.ui_DPRAMOffset		:= DPRAM_StartAddress$UINT;
	s_Set_ISO_RD.ui_DPRAMOffsetSub	:= DPRAM_StartAddress_SUBBus$UINT;
	s_Set_ISO_RD.ui_DPRAMSize		:= DPRAM_Size$UINT / 4;
	s_Set_ISO_WR.ui_DPRAMOffset		:= s_Set_ISO_RD.ui_DPRAMOffset	 + s_Set_ISO_RD.ui_DPRAMSize;
	s_Set_ISO_WR.ui_DPRAMOffsetSub	:= s_Set_ISO_RD.ui_DPRAMOffsetSub + s_Set_ISO_RD.ui_DPRAMSize;
	s_Set_ISO_WR.ui_DPRAMSize		:= DPRAM_Size$UINT / 4;
	
	s_Set_ASY_RD.ui_DPRAMOffset		:= s_Set_ISO_WR.ui_DPRAMOffset + s_Set_ISO_WR.ui_DPRAMSize;
	s_Set_ASY_RD.ui_DPRAMOffsetSub	:= s_Set_ISO_WR.ui_DPRAMOffsetSub + s_Set_ISO_WR.ui_DPRAMSize;
	s_Set_ASY_RD.ui_DPRAMSize		:= DPRAM_Size$UINT / 4;
	s_Set_ASY_WR.ui_DPRAMOffset		:= s_Set_ASY_RD.ui_DPRAMOffset + s_Set_ASY_RD.ui_DPRAMSize;
	s_Set_ASY_WR.ui_DPRAMOffsetSub	:= s_Set_ASY_RD.ui_DPRAMOffsetSub + s_Set_ASY_RD.ui_DPRAMSize;
	s_Set_ASY_WR.ui_DPRAMSize		:= DPRAM_Size$UINT / 4;

  
  //reset counter for semaphore
  MtxCnt := 0;
	
  State := _NotInitialized;

	ret_code	:= C_OK;

END_FUNCTION //  Varan_DataMover::Varan_DataMover
//=================================================================================================
//Init of class
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Varan_DataMover::Init
  VAR
    sd_retval	: DINT;
    sz_name		: ARRAY[0..31] OF CHAR;
    sz_no  		: ARRAY[0..31] OF CHAR;
    // For NewInst command 
    _Para 	            : CmdStruct;  
    _Result 	          : Results;   
		paraGetModuleHandel : t_VM_CMD_GetModuleHandle; 
    
    LastError : DINT;
  END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    return;
  END_IF;
#endif
  
	//only one time
	if ( us_Firstscan = 0 ) then
    
     //get client values
     CodeStartAddress := CodeStartAddress.Read();
     CodeSize         := CodeSize.Read();
     TimeSliceErrorOn := TimeSliceErrorOn.Read();

    //get interface for hardwaretree functions
    if ( OS_CILGET(INTERFACE_HARDWARETREE, #pHardwareTree)) then
      pHardwareTree := NIL;
    end_if;

		//mark class as valid
		State := _ClassOk;

		//read client
		AddDIASTime := AddDIASTime.read();

		//get varan manager number and varan pointer
		ud_VaranManagerNr := ( VaranIn.VaranIn.GetManagerNumber( p_varan := #pVaran ) )$UDINT;
    
    // Check for payload support
    _Para.uiCmd := VM_CMD_IS_PAYLOAD_SUPPORTED;
    _Result.aData[0]$BOOL := 0;   // Set to 0 in case the NewInst Method is not Implemented
    VaranIn.VaranIn.NewInst(#_Para, #_Result);
    b_PayloadSupport := _Result.aData[0]$BOOL;

		//look for an error
		if ( pVaran = NIL 
        & b_PayloadSupport = FALSE) then  // pVaran is always Nil with Payload support, another interface is used
			State 	:= _NoVaranInterface;
			return;
		end_if;

    //dummy memory area for first mover callback
    p_DummyDataRdWr := (To_StdLib.Malloc(size:=128))$^USINT; //#WP003

		//_GetObjName( this, #sz_name[ 0 ] );
		
		//Semaphore for direct access calls
    if p_SemaHandle = NIL then
      //create name for handle
      MtxCnt        += 1;
      _strcpy(#sz_name[0], "VaranDataMover");
      _itoa(MtxCnt, #sz_no[0]);
      _strcat(#sz_name[0], #sz_no[0]);
            
      p_SemaHandle := To_Multitask.CreateSemaphore( MTSEMATYPE_RESOURCE, 1, 0, ( #sz_name )$^CHAR );
      if( p_SemaHandle = NIL )then
        State := _NoVaranInterface;
        LastError := To_Multitask.GETLASTERROR();
        TRACE( "Varan DataMover: Unable to create semaphore for direct access!");
        TRACE( (#sz_name)$^CHAR );
      end_if;
    
    end_if;

		//get required setting
		sd_Required := VaranIn.Required.read();

    //get right varan position
    if ( p_nodeString = NIL ) then
    p_NodeString := VaranIn.GetPointer2NodeString();
    end_if;
    //do not come here
    if ( p_NodeString = NIL ) then
      State := _RootError;
      return;
    end_if;
    
    if  b_PayloadSupport then
    
      // Get the pointer for the Payload inteface
      if ( OS_CILGet( INTERFACE_MULTIVARANMANAGER, #pMultiVaran ) <> SYS_ERR_NONE) then
        // Should be impossible b_PayloadSupport is only set when this interface was already called succesfully
        TRACE( "Varan_DataMover::Varan_DataMover No Multi_Varan Interface found" );        
        return;
      end_if;
      
      _Para.uiCmd := VM_CMD_GET_MODULE_HANDLE;
      
      paraGetModuleHandel.p_us_position_info := p_NodeString;
      paraGetModuleHandel.p_ud_module_handle := #ud_HandleModule;
      
      _Para.aPara[0]  := (#paraGetModuleHandel)$DINT;
      
      VaranIn.NewInst(#_Para, #_Result); //get module handle
      
      sd_retval := VaranIn.AddRdPayloadDO(  ud_dol_type   := VARAN_DOL_ASY
                                  , p_ud_handle   := ( #s_ConfigDO.p_Handle)$^UDINT
                                  , ud_offset_read:= CodeStartAddress                               
                                  , ud_length_read:= SIZEOF( t_DataMoverConfig )
                                  , p_ud_data_read:= ( #s_ConfigDO.p_DataRead)$^UDINT
                                  , ud_type       := VM_MEMORY_ACCESS);
      

      
      //look for an error
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _CreateDOFailed;
        VaranIn.SetState( State );
        return;
      end_if;
    else
		//install DO to read config data
		sd_retval := VaranIn.VaranIn.AddRdDO( p_us_position_info	:= p_NodeString
											, ud_dol_type			:= VARAN_DOL_ASY
											, p_ud_handle			:= ( #s_ConfigDO.p_Handle )$^UDINT
											, ud_address			:= 0
											, ud_length				:= sizeof( t_DataMoverConfig )
											, p_ud_data				:= ( #s_ConfigDO.p_DataRead )$^UDINT
											, ud_type				:= VM_MEMORY_ACCESS
											);

		//look for an error
		if ( sd_retval <> VARANMANAGER_OK ) then
			State := _CreateDOFailed;
			VaranIn.SetState( State );
			return;
		end_if;
    

		s_ConfigDO.p_Settings := s_ConfigDO.p_DataRead - VM_DO_OFFSET_RD;
    end_if;
//-------------------------------------------------------------------------------------------------
#ifdef VM_DATAMOVER_ISO_TIME
    if b_PayloadSupport then   
      sd_retval := VaranIn.AddRdPayloadDO(  ud_dol_type   := VARAN_DOL_ISO
                                  , p_ud_handle   := ( #s_ISO_Time_DO.p_Handle)$^UDINT
                                  , ud_offset_read:= CodeStartAddress + t_DataMoverConfig.ud_SyncTimeReg                               
                                  , ud_length_read:= SIZEOF( UDINT )
                                  , p_ud_data_read:= ( #s_ISO_Time_DO.p_DataRead)$^UDINT
                                  , ud_type       := VM_MEMORY_ACCESS);
      
    
      //look for an error
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _CreateDOFailed;
        VaranIn.SetState( State );
        return;
      end_if;
    else
		//install DO to read ISO time (must be in ISO Task because it's only a counter -> crazy FPGA)
		sd_retval := VaranIn.VaranIn.AddRdDO( p_us_position_info	:= p_NodeString
                                        , ud_dol_type			:= VARAN_DOL_ISO
                                        , p_ud_handle			:= ( #s_ISO_Time_DO.p_Handle )$^UDINT
                                        , ud_address			:= 0
                                        , ud_length				:= sizeof( UDINT )
                                        , p_ud_data				:= ( #s_ISO_Time_DO.p_DataRead )$^UDINT
                                        , ud_type				:= VM_MEMORY_ACCESS
                                        );

		//look for an error
		if ( sd_retval <> VARANMANAGER_OK ) then
			State := _CreateDOFailed;
			VaranIn.SetState( State );
			return;
      end_if;    
		  s_ISO_Time_DO.p_Settings := s_ISO_Time_DO.p_DataRead - VM_DO_OFFSET_RD;
		end_if;
#endif
//-------------------------------------------------------------------------------------------------
		
	end_if;

	us_Firstscan += 1;

END_FUNCTION //VIRTUAL GLOBAL Varan_DataMover::Init
//[#ENGLISH]
//=================================================================================================
//Function for read direct access
//=================================================================================================
//[>ud_address]address for reading
//[>ud_length]max. 128 Byte access
//[>p_data]address  of pointer (pointer value is set)
FUNCTION GLOBAL Varan_DataMover::DirectAccessRead
  VAR_INPUT
    ud_address		: UDINT;
    ud_length		: UDINT;
    p_data			: ^void;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    ud_timemark		: UDINT;
  END_VAR

	if ( State = _ClassOk ) then

		//check length
		if ( ud_length > 122 | p_data = NIL ) then
			sd_retval := -101;
			return;
		end_if;

		LOCK_DA;
		
		//set command settings
		s_FastDAData.ud_Address := ud_address;
		s_FastDAData.us_Control := 16#14;
		s_FastDAData.us_Bytes 	:= ud_length$USINT;
		
		if b_PayloadSupport then
      //write config data (because we need direct accesses in init)
      sd_retval := MULTI_VARAN_iExecuteDirectAccess(hNodeHandle := ud_HandleModule
                                                  , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                  , udOffset    := (s_DAData.ud_CodeAddress and 16#FFFF) // Remove DeviceAddress so that offset remains
                                                  , udLength    := 6
                                                  , pusData     := ( #s_FastDAData )$^USINT
                                                  , pudErrorInfo:= NIL);  
                                                
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _DirectAccessFailed;
        VaranIn.SetState( State );
        UNLOCK_DA;
        return;
      end_if;
    else
		  //write config data (because we need direct accesses in init)
      sd_retval := VARAN_iWriteMemoryDA(uiManager     := ud_VaranManagerNr
                                      , uiAddress     := s_DAData.ud_CodeAddress
                                      , uiLen         := 6
                                      , uiRetryTimeout:= s_DAData.ud_RetryTimeout
                                      , pvData        := #s_FastDAData
                                      , puiError      := NIL
                                      );
		
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _DirectAccessFailed;
        VaranIn.SetState( State );
        UNLOCK_DA;
        return;
      end_if;
    end_if;

    //poll if list is ready or timeout
    ud_timemark := Varanin.VaranIn.GetNsTime();
		
    repeat  
      if b_PayloadSupport then
        sd_retval := MULTI_VARAN_iExecuteDirectAccess(hNodeHandle := ud_HandleModule
                                                    , udCommand   := VARAN_CMD_MEMORY_READ
                                                    , udOffset    := s_DAData.ud_CodeAddress and 16#FFFF // Remove DeviceAddress so that offset remains
                                                    , udLength    := 6 + ud_length
                                                    , pusData     := ( #s_FastDAData )$^USINT
                                                    , pudErrorInfo:= NIL);  
                                                  
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _DirectAccessFailed;
          VaranIn.SetState( State );
          UNLOCK_DA;
          return;
        end_if;
      else
        sd_retval := VARAN_iReadMemoryDA( uiManager     := ud_VaranManagerNr
                                        , uiAddress     := s_DAData.ud_CodeAddress
                                        , uiLen         := 6 + ud_length
                                        , uiRetryTimeout:= s_DAData.ud_RetryTimeout
                                        , pvData        := #s_FastDAData
                                        , puiError      := NIL
                                        );
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _DirectAccessFailed;
          VaranIn.SetState( State );
          UNLOCK_DA;
          return;
        end_if;
      end_if;			
      
    until ( (( s_FastDAData.us_Control and 2#10000 ) = 0) | ( VaranIn.VaranIn.GetNsTime() - ud_timemark ) > 1000000 ) end_repeat;

    //check timeout
    if ( s_FastDAData.us_Control and 2#10000 ) then
      sd_retval := -102;
      Timeout += 1;
      TRACE("(Varan_DataMover::DirectAccessRead) Direct Access Failed, Timeout");
      UNLOCK_DA;
      return;
    end_if;

    //copy data
    To_StdLib.MemCpy( p_data, #s_FastDAData.a_Data[ 0 ], ud_length );

    UNLOCK_DA;

  else
    TRACE("(Varan_DataMover::DirectAccessRead) Direct Access Failed, Class Not ready");
    sd_retval := -100;
  end_if;

END_FUNCTION //GLOBAL Varan_DataMover::DirectAccessRead
//[#ENGLISH]
//=================================================================================================
//Function for write direct access
//=================================================================================================
//[>ud_address]address of write access
//[>ud_length]max. 128 Byte access
//[>p_data]address of pointer (pointer value is set)
FUNCTION GLOBAL Varan_DataMover::DirectAccessWrite
  VAR_INPUT
    ud_address		: UDINT;
    ud_length		: UDINT;
    p_data			: ^void;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    ud_timemark		: UDINT;
  END_VAR

	if ( State = _ClassOk ) then

		//check length
		if ( ud_length > 122 | p_data = NIL ) then
			sd_retval := -101;
			return;
		end_if;

		LOCK_DA;
		
		//set command settings
		s_FastDAData.ud_Address := ud_address;
		s_FastDAData.us_Control := 16#15;
		s_FastDAData.us_Bytes 	:= ud_length$USINT;
  
		//copy data
		To_StdLib.MemCpy( #s_FastDAData.a_Data[ 0 ], p_data, ud_length );
    if b_PayloadSupport then
      sd_retval := MULTI_VARAN_iExecuteDirectAccess(hNodeHandle := ud_HandleModule
                                                  , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                  , udOffset    := s_DAData.ud_CodeAddress and 16#FFFF // Remove DeviceAddress so that offset remains
                                                  , udLength    := 6 + ud_length
                                                  , pusData     := ( #s_FastDAData )$^USINT
                                                  , pudErrorInfo:= NIL);  
		
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _DirectAccessFailed;
        VaranIn.SetState( State );        
        UNLOCK_DA;
        return;
      end_if;
    else
      //write config data (because we need direct accesses in init)
      sd_retval := VARAN_iWriteMemoryDA(uiManager     := ud_VaranManagerNr
                                      , uiAddress     := s_DAData.ud_CodeAddress
                                      , uiLen         := 6 + ud_length
                                      , uiRetryTimeout:= s_DAData.ud_RetryTimeout
                                      , pvData        := #s_FastDAData
                                      , puiError      := NIL
                                      );
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _DirectAccessFailed;
        VaranIn.SetState( State );
        UNLOCK_DA;
        return;      
      end_if;                                        
		
		end_if;
    
    
    //poll if da is ready or timeout
    ud_timemark := Varanin.VaranIn.GetNsTime();
    repeat
      
      if b_PayloadSupport then
        sd_retval := MULTI_VARAN_iExecuteDirectAccess(hNodeHandle := ud_HandleModule
                                                    , udCommand   := VARAN_CMD_MEMORY_READ
                                                    , udOffset    := s_DAData.ud_CodeAddress and 16#FFFF // Remove DeviceAddress so that offset remains
                                                    , udLength    := 6 
                                                    , pusData     := ( #s_FastDAData )$^USINT
                                                    , pudErrorInfo:= NIL);  
                                              
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _DirectAccessFailed;
          VaranIn.SetState( State );
          UNLOCK_DA;
          return;
        end_if;
      else
        sd_retval := VARAN_iReadMemoryDA( uiManager     := ud_VaranManagerNr
                                        , uiAddress     := s_DAData.ud_CodeAddress
                                        , uiLen         := 6
                                        , uiRetryTimeout:= s_DAData.ud_RetryTimeout
                                        , pvData        := #s_FastDAData
                                        , puiError      := NIL
                                        );

        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _DirectAccessFailed;
          VaranIn.SetState( State );
          UNLOCK_DA;
          return;
        end_if;
      end_if;
      
    until ( (( s_FastDAData.us_Control and 2#10000 ) = 0) | ( VaranIn.VaranIn.GetNsTime() - ud_timemark ) > 1000000 ) end_repeat;

    //check timeout
    if ( s_FastDAData.us_Control and 2#10000 ) then
      sd_retval := -102;
      Timeout += 1;
      TRACE("(Varan_DataMover::DirectAccessWrite) Direct Access Failed, Timeout");
      UNLOCK_DA;
      return;
    end_if;

    UNLOCK_DA;

  else
    TRACE("(Varan_DataMover::DirectAccessWrite) Direct Access Failed, Class Not ready");
    sd_retval := -100;
  end_if;

END_FUNCTION //GLOBAL Varan_DataMover::DirectAccessWrite
//[#ENGLISH]
//=================================================================================================
//Function to add a ISO Rd command
//=================================================================================================
//[>ud_add]address of access
//[>ud_length]length of data
//[>p_data]address of pointer variable to save data address
FUNCTION GLOBAL Varan_DataMover::AddRdISO
  VAR_INPUT
    ud_add			: UDINT;
    ud_length		: UDINT;
    p_data			: ^void;
      ud_Priority 	: HDINT;
    p_DataAddr : ^HDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    p_Mov			: ^t_StructMove;
    ud_dest_add		: UDINT;
  END_VAR

	//get free memory space
	sd_retval := GetMemoryISORd	( p_add		:= #ud_dest_add
                              , p_data	:= p_data
                              , ud_len	:= ud_length
                              , ud_Priority := ud_Priority
                              );

	if ( sd_retval <> VARANMANAGER_OK ) then
		return;
	end_if;
  
  //give back the address if requested
  if p_DataAddr then
    p_DataAddr^ := ud_dest_add;
  end_if;

	//save opcodes in class
	if ( p_ISOMoverCode = NIL ) then
		//allocate memory
		p_ISOMoverCode$^void := To_StdLib.Malloc( s_Set_ISO_RD.ui_DPRAMSize + s_Set_ISO_WR.ui_DPRAMSize );

		if ( p_ISOMoverCode  = NIL ) then
			State := _MemoryFault;
			sd_retval := -103;
			VaranIn.SetState( State );
			return;
		end_if;
	end_if;

	//first check length
	if ( CheckLengthOfCode() = FALSE ) then
		sd_retval := -102;
		return;
	end_if;

	//check size of free memory
	if (( ui_ISOByteCount + sizeof( t_StructMove )) > ( s_Set_ISO_RD.ui_DPRAMSize + s_Set_ISO_WR.ui_DPRAMSize )) then
		State := _MemoryFault;
		sd_retval := -102;
		VaranIn.SetState( State );
		return;
	end_if;

	//get right pointer
	p_Mov := p_ISOMoverCode + ui_ISOByteCount;

	p_Mov^.us_Command 	:= VM_DATAMOVER_MOVE_OP;
	p_Mov^.ui_Length	:= ud_length$UINT;
	p_Mov^.us_Length	:= ( ud_length shr 16 )$USINT;
	p_Mov^.ud_SourceAdd	:= ud_add;
	p_Mov^.ud_DestAdd	:= ud_dest_add;
	
	ui_ISOByteCount += sizeof( t_StructMove );

	sd_retval := VARANMANAGER_OK;

END_FUNCTION //GLOBAL Varan_DataMover::AddRdIso
//[#ENGLISH]
//=================================================================================================
//Function to add a ISO Wr command
//=================================================================================================
//[>ud_add]address of access
//[>ud_length]length of data
//[>p_data]address of pointer variable to save data address
FUNCTION GLOBAL Varan_DataMover::AddWrISO
  VAR_INPUT
    ud_add			: UDINT;
    ud_length		: UDINT;
    p_data			: ^void;
      ud_Priority 	: HDINT;
    p_DataAddr : ^HDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    p_Mov			: ^t_StructMove;
    ud_dest_add		: UDINT;
  END_VAR

	//get free memory space
	sd_retval := GetMemoryISOWr	( p_add		:= #ud_dest_add
                              , p_data	:= p_data
                              , ud_len	:= ud_length
                              , ud_Priority := ud_Priority
                              );

	if ( sd_retval <> VARANMANAGER_OK ) then
		return;
	end_if;

  //give back the address if requested
  if p_DataAddr then
    p_DataAddr^ := ud_dest_add;
  end_if;

	//save opcodes in class
	if ( p_ISOMoverCode = NIL ) then
		//allocate memory
		p_ISOMoverCode$^void := To_StdLib.Malloc( s_Set_ISO_WR.ui_DPRAMSize + s_Set_ISO_RD.ui_DPRAMSize );

		if ( p_ISOMoverCode = NIL ) then
			State := _MemoryFault;
			sd_retval := -103;
			VaranIn.SetState( State );
			return;
		end_if;
	end_if;

	//first check length
	if ( CheckLengthOfCode() = FALSE ) then
		sd_retval := -102;
		return;
	end_if;

	//check size of free memory
	if (( ui_ISOByteCount + sizeof( t_StructMove )) > ( s_Set_ISO_RD.ui_DPRAMSize + s_Set_ISO_WR.ui_DPRAMSize )) then
		State := _MemoryFault;
		sd_retval := -102;
		VaranIn.SetState( State );
		return;
	end_if;

	//get right pointer
	p_Mov := p_ISOMoverCode + ui_ISOByteCount;

	p_Mov^.us_Command 	:= VM_DATAMOVER_MOVE_OP;
	p_Mov^.ui_Length	:= ud_length$UINT;
	p_Mov^.us_Length	:= ( ud_length shr 16 )$USINT;
	p_Mov^.ud_SourceAdd	:= ud_dest_add;
	p_Mov^.ud_DestAdd	:= ud_add;
	
	ui_ISOByteCount += sizeof( t_StructMove );

	sd_retval := VARANMANAGER_OK;

END_FUNCTION //GLOBAL Varan_DataMover::AddWrISO
//[#ENGLISH]
//=================================================================================================
//Function to add a ISO Wr command on first position (necessary for DIAS - Sync)
//=================================================================================================
//[>ud_add]address of access
//[>ud_length]length of data
//[>p_data]address of pointer variable to save data address
FUNCTION GLOBAL Varan_DataMover::AddFirstWrISO
  VAR_INPUT
    ud_add		: UDINT;
    ud_length	: UDINT;
    p_data		: ^void;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    p_Mov			: ^t_StructMove;
    ud_dest_add		: UDINT;
    p_temp			: ^void;
  END_VAR

	//get free memory space
	sd_retval := GetMemoryISOWr	( p_add		:= #ud_dest_add
                              , p_data	:= p_data
                              , ud_len	:= ud_length
                              );

	if ( sd_retval <> VARANMANAGER_OK ) then
		return;
	end_if;

	//save opcodes in class
	if ( p_ISOMoverCode = NIL ) then
		//allocate memory
		p_ISOMoverCode$^void := To_StdLib.Malloc( s_Set_ISO_WR.ui_DPRAMSize + s_Set_ISO_RD.ui_DPRAMSize );

		if ( p_ISOMoverCode = NIL ) then
			State := _MemoryFault;
			sd_retval := -103;
			VaranIn.SetState( State );
			return;
		end_if;
	end_if;

	//first check length
	if ( CheckLengthOfCode() = FALSE ) then
		sd_retval := -102;
		return;
	end_if;

	//check size of free memory
	if (( ui_ISOByteCount + sizeof( t_StructMove )) > ( s_Set_ISO_RD.ui_DPRAMSize + s_Set_ISO_WR.ui_DPRAMSize )) then
		State := _MemoryFault;
		sd_retval := -102;
		VaranIn.SetState( State );
		return;
	end_if;

	//check if we must copy something
	if ( ui_ISOByteCount ) then
		p_temp := To_StdLib.Malloc( ui_ISOByteCount );
		
		if( p_temp = NIL ) then
			State := _MemoryFault;
			sd_retval := -103;
			VaranIn.SetState( State );
			return;
		end_if;

		To_StdLib.MemCpy( p_temp, p_ISOMoverCode, ui_ISOByteCount );
		To_StdLib.MemCpy( p_ISOMoverCode + sizeof( t_StructMove ), p_temp, ui_ISOByteCount );
		To_StdLib.Free( p_temp );
	end_if;

	//get right pointer
	p_Mov$^USINT := p_ISOMoverCode;

	p_Mov^.us_Command 	:= VM_DATAMOVER_MOVE_OP;
	p_Mov^.ui_Length	:= ud_length$UINT;
	p_Mov^.us_Length	:= ( ud_length shr 16 )$USINT;
	p_Mov^.ud_SourceAdd	:= ud_dest_add;
	p_Mov^.ud_DestAdd	:= ud_add;
	
	ui_ISOByteCount += sizeof( t_StructMove );

	sd_retval := VARANMANAGER_OK;

END_FUNCTION //GLOBAL Varan_DataMover::AddFirstWrISO
//[#ENGLISH]
//=================================================================================================
//Function to add a ASY Rd command
//=================================================================================================
//[>ud_add]address of access
//[>ud_length]length of data
//[>p_data]address of pointer variable to save data address
FUNCTION GLOBAL Varan_DataMover::AddRdASY
  VAR_INPUT
    ud_add			: UDINT;
    ud_length		: UDINT;
    p_data			: ^void;
      ud_Priority 	: HDINT;
    p_DataAddr : ^HDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    p_Mov			: ^t_StructMove;
    ud_dest_add		: UDINT;
  END_VAR

	//get free memory space
	sd_retval := GetMemoryASYRd	( p_add		:= #ud_dest_add
                              , p_data	:= p_data
                              , ud_len	:= ud_length
                              , ud_Priority := ud_Priority
                              );

	if ( sd_retval <> VARANMANAGER_OK ) then
		return;
	end_if;

  //give back the address if requested
  if p_DataAddr then
    p_DataAddr^ := ud_dest_add;
  end_if;

	//save opcodes in class
	if ( p_ASYMoverCode = NIL ) then
		//allocate memory
		p_ASYMoverCode$^void := To_StdLib.Malloc( s_Set_ASY_RD.ui_DPRAMSize + s_Set_ASY_WR.ui_DPRAMSize );

		if ( p_ASYMoverCode  = NIL ) then
			State := _MemoryFault;
			sd_retval := -103;
			VaranIn.SetState( State );
			return;
		end_if;
	end_if;

	//first check length
	if ( CheckLengthOfCode() = FALSE ) then
		sd_retval := -102;
		return;
	end_if;

	//check size of free memory
	if (( ui_ASYByteCount + sizeof( t_StructMove )) > ( s_Set_ASY_RD.ui_DPRAMSize + s_Set_ASY_WR.ui_DPRAMSize )) then
		State := _MemoryFault;
		sd_retval := -102;
		VaranIn.SetState( State );
		return;
	end_if;

	//get right pointer
	p_Mov := p_ASYMoverCode + ui_ASYByteCount;

	p_Mov^.us_Command 	:= VM_DATAMOVER_MOVE_OP;
	p_Mov^.ui_Length	:= ud_length$UINT;
	p_Mov^.us_Length	:= ( ud_length shr 16 )$USINT;
	p_Mov^.ud_SourceAdd	:= ud_add;
	p_Mov^.ud_DestAdd	:= ud_dest_add;
	
	ui_ASYByteCount += sizeof( t_StructMove );

	sd_retval := VARANMANAGER_OK;

END_FUNCTION //GLOBAL Varan_DataMover::AddRdASY
//[#ENGLISH]
//=================================================================================================
//Function to add a ASY Wr command
//=================================================================================================
//[>ud_add]address of access
//[>ud_length]length of data
//[>p_data]address of pointer variable to save data address
FUNCTION GLOBAL Varan_DataMover::AddWrASY
  VAR_INPUT
    ud_add			: UDINT;
    ud_length		: UDINT;
    p_data			: ^void;
      ud_Priority 	: HDINT;
    p_DataAddr : ^HDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    p_Mov			: ^t_StructMove;
    ud_dest_add		: UDINT;
  END_VAR

	//get free memory space
	sd_retval := GetMemoryASYWr	( p_add		:= #ud_dest_add
                              , p_data	:= p_data
                              , ud_len	:= ud_length
                              , ud_Priority := ud_Priority
                              );

	if ( sd_retval <> VARANMANAGER_OK ) then
		return;
	end_if;

  //give back the address if requested
  if p_DataAddr then
    p_DataAddr^ := ud_dest_add;
  end_if;

	//save opcodes in class
	if ( p_ASYMoverCode = NIL ) then
		//allocate memory
		p_ASYMoverCode$^void := To_StdLib.Malloc( s_Set_ASY_WR.ui_DPRAMSize + s_Set_ASY_RD.ui_DPRAMSize );

		if ( p_ASYMoverCode = NIL ) then
			State := _MemoryFault;
			sd_retval := -103;
			VaranIn.SetState( State );
			return;
		end_if;
	end_if;

	//first check length
	if ( CheckLengthOfCode() = FALSE ) then
		sd_retval := -102;
		return;
	end_if;

	//check size of free memory
	if (( ui_ASYByteCount + sizeof( t_StructMove )) > ( s_Set_ASY_RD.ui_DPRAMSize + s_Set_ASY_WR.ui_DPRAMSize )) then
		State := _MemoryFault;
		sd_retval := -102;
		VaranIn.SetState( State );
		return;
	end_if;

	//get right pointer
	p_Mov := p_ASYMoverCode + ui_ASYByteCount;

	p_Mov^.us_Command 	:= VM_DATAMOVER_MOVE_OP;
	p_Mov^.ui_Length	:= ud_length$UINT;
	p_Mov^.us_Length	:= ( ud_length shr 16 )$USINT;
	p_Mov^.ud_SourceAdd	:= ud_dest_add;
	p_Mov^.ud_DestAdd	:= ud_add;
	
	ui_ASYByteCount += sizeof( t_StructMove );

	sd_retval := VARANMANAGER_OK;

END_FUNCTION //GLOBAL Varan_DataMover::AddWrASY
//[#ENGLISH]
//=================================================================================================
//Function to add a Delay on a list
//=================================================================================================
//[>ud_task]VARAN_DOL_ISO = Realtime, VARAN_DOL_ASY= Cyclic
//[>ud_time]delay time in µs
FUNCTION GLOBAL Varan_DataMover::AddDelay
  VAR_INPUT
    ud_task		: UDINT;
    ud_time		: UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    p_Del		: ^t_StructDelay;
  END_VAR

	//------------------------------------------------------------------------------------------------
	//isochron
	if ( ud_task = VARAN_DOL_ISO ) then

		//save opcodes in class
		if ( p_ISOMoverCode = NIL ) then
			//allocate memory
			p_ISOMoverCode$^void := To_StdLib.Malloc( s_Set_ISO_WR.ui_DPRAMSize + s_Set_ISO_RD.ui_DPRAMSize );

			if ( p_ISOMoverCode = NIL ) then
				State := _MemoryFault;
				sd_retval := -103;
				VaranIn.SetState( State );
				return;
			end_if;
		end_if;

		//first check length
		if ( CheckLengthOfCode() = FALSE ) then
			sd_retval := -102;
			return;
		end_if;

		//check size of free memory
		if (( ui_ISOByteCount + sizeof( t_StructDelay )) > ( s_Set_ISO_RD.ui_DPRAMSize + s_Set_ISO_WR.ui_DPRAMSize )) then
			State := _MemoryFault;
			sd_retval := -102;
			VaranIn.SetState( State );
			return;
		end_if;

		//get right pointer
		p_Del := p_ISOMoverCode + ui_ISOByteCount;

		p_Del^.us_Command 	:= VM_DATAMOVER_DELAY_OP;
		p_Del^.ui_DelayTime	:= ud_time$UINT;
		p_Del^.us_DelayTime	:= ( ud_time shr 16 )$USINT;
	
		ui_ISOByteCount += sizeof( t_StructDelay );

	//------------------------------------------------------------------------------------------------
	//asychron
	else
	
		//save opcodes in class
		if ( p_ASYMoverCode = NIL ) then
			//allocate memory
			p_ASYMoverCode$^void := To_StdLib.Malloc( s_Set_ASY_WR.ui_DPRAMSize + s_Set_ASY_RD.ui_DPRAMSize );

			if ( p_ASYMoverCode = NIL ) then
				State := _MemoryFault;
				sd_retval := -103;
				VaranIn.SetState( State );
				return;
			end_if;
		end_if;

		//first check length
		if ( CheckLengthOfCode() = FALSE ) then
			sd_retval := -102;
			return;
		end_if;

		//check size of free memory
		if (( ui_ASYByteCount + sizeof( t_StructDelay )) > ( s_Set_ASY_RD.ui_DPRAMSize + s_Set_ASY_WR.ui_DPRAMSize )) then
			State := _MemoryFault;
			sd_retval := -102;
			VaranIn.SetState( State );
			return;
		end_if;

		//get right pointer
		p_Del := p_ASYMoverCode + ui_ASYByteCount;

		p_Del^.us_Command 	:= VM_DATAMOVER_DELAY_OP;
		p_Del^.ui_DelayTime	:= ud_time$UINT;
		p_Del^.us_DelayTime	:= ( ud_time shr 16 )$USINT;
	
		ui_ASYByteCount += sizeof( t_StructDelay );
	end_if;

END_FUNCTION //GLOBAL Varan_DataMover::AddDelay
//=================================================================================================
//Function to set Pointers for DA
//=================================================================================================
FUNCTION GLOBAL Varan_DataMover::SetDASettings
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR

	//----------------------------------------------------------------------------------------------
	//get varan node info
	p_NodeInfo := VaranIn.GetPointer2NodeInfo();	

	//look for right Node pointer
	if ( p_NodeInfo = NIL ) then
		State := _NoHardware;
		return;
	end_if;

	//get device address
	ud_DeviceAddress := p_NodeInfo^.uiAddress;

	//get right varan position
	p_NodeString := VaranIn.GetPointer2NodeString();

	//look if component is ok
	if ( p_NodeString = NIL ) then
		State 	:= _RootError;
		return;
	end_if;		
  if b_PayloadSupport then
    sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                              , udCommand   := VARAN_CMD_MEMORY_READ
                                              , udOffset    := CodeStartAddress + t_DataMoverConfig.us_ErrorReg
                                              , udLength    := sizeof( USINT )
                                              , pusData     := ( #sd_retval )$^USINT
                                              , pudErrorInfo:= NIL);  
                                              
    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      VaranIn.SetState( State );
      return;
    end_if;
  else

	sd_retval := VARAN_iReadMemoryDA	( uiManager		:= ud_VaranManagerNr
										, uiAddress		:= ud_DeviceAddress + CodeStartAddress + t_DataMoverConfig.us_ErrorReg
                      , uiLen			:= sizeof(USINT)
										, uiRetryTimeout:= VaranIn.GetRetryTimeout( ud_bytes := 1 )
										, pvData		:= #sd_retval
										, puiError		:= NIL
										);

	if ( sd_retval <> VARANMANAGER_OK ) then
		State := _DirectAccessFailed;
		VaranIn.SetState( State );
		return;
	end_if;
  end_if;

	//set some settings
	s_DAData.ud_CodeAddress			:= ud_DeviceAddress + CodeStartAddress + VM_DATAMOVER_DA_OFFSET;
	s_DAData.ud_DataAddress			:= 0;
	s_DAData.ud_RetryTimeout		:= VaranIn.GetRetryTimeout( ud_bytes := 128 );
	s_DAData.ud_DataAddressSub		:= 0;
	s_DAData.ud_StartAddress		:= 0;
	s_DAData.s_DAMove.us_Command	:= VM_DATAMOVER_MOVE_OP;

	//----------------------------------------------------------------------------------------------
	//Config mover
  s_Config.us_ControlReg                  := 0;
  s_Config.us_ControlReg.MoverEnable      := TRUE;
	s_Config.us_ControlReg.HoldOPError			:= TRUE;
	s_Config.us_ControlReg.HoldWBError			:= TRUE;
	
	//check hold on by Timelice Error
	if ( TimeSliceErrorOn ) then
		s_Config.us_ControlReg.HoldTimeSliceError	:= TRUE;
	end_if;

//	s_Config.ud_SyncTimeReg := VaranIn.GetVaranTime() / 2000;		//in µs
	s_Config.ud_SyncTimeReg := AddDIASTime;

	//write config data (because we need direct accesses in init)
  if b_PayloadSupport then
    sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                              , udCommand   := VARAN_CMD_MEMORY_WRITE
                                              , udOffset    := CodeStartAddress 
                                              , udLength    := sizeof( t_DataMoverConfig )
                                              , pusData     := ( #s_Config )$^USINT
                                              , pudErrorInfo:= NIL);  
                                              
    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      VaranIn.SetState( State );
      return;
    end_if;
  else
	sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
										, uiAddress		:= ud_DeviceAddress + CodeStartAddress
										, uiLen			:= sizeof( t_DataMoverConfig )
										, uiRetryTimeout:= VaranIn.GetRetryTimeout( ud_bytes := sizeof( t_DataMoverConfig ) )
										, pvData		:= #s_Config
										, puiError		:= NIL
										);

	if ( sd_retval <> VARANMANAGER_OK ) then
		State := _DirectAccessFailed;
		VaranIn.SetState( State );
		return;
	end_if;
  end_if;

	//----------------------------------------------------------------------------------------------
	//write end command at end of Code DPRAM
	ui_EndAddressOff := TO_UINT( VM_DATAMOVER_HEADER + CodeSize - sizeof( t_StructEnd ) );
  
  if b_PayloadSupport then
    sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                              , udCommand   := VARAN_CMD_MEMORY_WRITE
                                              , udOffset    := CodeStartAddress + ui_EndAddressOff
                                              , udLength    := sizeof( t_StructEnd )
                                              , pusData     := ( #s_End )$^USINT
                                              , pudErrorInfo:= NIL);  
                                              
    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      VaranIn.SetState( State );
      return;
    end_if;
  else
	sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
										, uiAddress		:= ud_DeviceAddress + CodeStartAddress + ui_EndAddressOff
										, uiLen			:= sizeof( t_StructEnd )
										, uiRetryTimeout:= VaranIn.GetRetryTimeout( ud_bytes := sizeof( t_StructEnd ) )
										, pvData		:= #s_End
										, puiError		:= NIL
										);

	//look for error
	if ( sd_retval <> VARANMANAGER_OK ) then
		State := _DirectAccessFailed;
		VaranIn.SetState( State );
		return;
	end_if;
  end_if;

	//not needed (we use fast access)
	//s_ListSettings.ui_DAListStart 	:= ui_EndAddressOff;
	//s_ListSettings.ui_DAListEnd		:= ui_EndAddressOff;

END_FUNCTION //GLOBAL Varan_DataMover::SetDASettings

//[#ENGLISH]
//=================================================================================================
//Function for Varan Callback
//=================================================================================================
//[>ud_reason]reason of callback
//[>ud_data]data of callback
FUNCTION GLOBAL Varan_DataMover::Varan_Callback
  VAR_INPUT
    ud_reason		: UDINT;
    ud_data			: UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    i			: UINT;
    p_DO_RD		: ^t_DO_RD;
    p_DO_WR		: ^t_DO_WR;
  END_VAR
	
	sd_retval := -1;
	
	case ( ud_reason ) of

		//================================================================================================
		//=************************************* Connect ************************************************=
		//================================================================================================
		VARANMANAGER_CB_CONNECT:
	
			//----------------------------------------------------------------------------------------------
			//get varan node info
			p_NodeInfo := VaranIn.GetPointer2NodeInfo();	

			//look for right Node pointer
			if ( p_NodeInfo = NIL ) then
				State := _NoHardware;
				VaranIn.SetState( State );
				return;
			end_if;

			ud_DeviceAddress := p_NodeInfo^.uiAddress;

			//get right varan position
			p_NodeString := VaranIn.GetPointer2NodeString();
		
			//look if component is ok
			if ( p_NodeString = NIL ) then
				State 	:= _RootError;
				VaranIn.SetState( State );
				return;
			end_if;		

			if ( State = _MemoryFault ) then
				VaranIn.SetState( State );
				return;
			end_if;

			us_Wait := 16#FF;
			
			//----------------------------------------------------------------------------------------------
			//start config DO
      if b_PayloadSupport then
        VaranIn.EnableDO(ud_DOHandle:=s_ConfigDO.p_Handle$UDINT);
      else
			s_ConfigDO.p_Settings^.ud_Address := ud_DeviceAddress + CodeStartAddress;

			VaranIn.ResetDataObject	( p_handleDO	:= s_ConfigDO.p_Handle
                              , us_state		:= VARAN_DO_CONT_RUN
                              , ud_bytes		:= sizeof( t_DataMoverConfig )
                              );
      end_if;


//-------------------------------------------------------------------------------------------------
#ifdef VM_DATAMOVER_ISO_TIME
			//start ISO Time DO
      if b_PayloadSupport then
        VaranIn.EnableDO(ud_DOHandle:=s_ISO_Time_DO.p_Handle$UDINT);
      else
			s_ISO_Time_DO.p_Settings^.ud_Address := ud_DeviceAddress + CodeStartAddress + t_DataMoverConfig.ud_SyncTimeReg;

			VaranIn.ResetDataObject	( p_handleDO	:= s_ISO_Time_DO.p_Handle
                              , us_state		:= VARAN_DO_CONT_RUN
                              , ud_bytes		:= sizeof( UDINT )
                              );
      end_if;
#endif
//-------------------------------------------------------------------------------------------------

			//install DO to start async list
//			if ( us_ASYDOCount < ( s_Set_ASY_RD.us_DOCount + s_Set_ASY_WR.us_DOCount ) ) then

				//we must create it after all asy DOs (if number of ASY DO's increase after new connect we can have a dead DO!)
      if b_PayloadSupport then
      
        sd_retval := VaranIn.AddWrPayloadDO(  ud_dol_type   := VARAN_DOL_ASY
                                  , p_ud_handle   := ( #s_ConfigWrDO.p_Handle)$^UDINT                                  
                                  , ud_offset_write:= CodeStartAddress                               
                                  , ud_length_write:= SIZEOF( USINT )
                                  , p_ud_data_write:= ( #s_ConfigWrDO.p_DataWrite)$^UDINT
                                  , ud_type       := VM_MEMORY_ACCESS);
      

      
				//look for an error
				if ( sd_retval <> VARANMANAGER_OK ) then
					State := _CreateDOFailed;
					VaranIn.SetState( State );
					return;
				end_if;
      else
				sd_retval := VaranIn.VaranIn.AddWrDO( p_us_position_info	:= p_NodeString
                                            , ud_dol_type			:= VARAN_DOL_ASY
                                            , p_ud_handle			:= ( #s_ConfigWrDO.p_Handle )$^UDINT
                                            , ud_address			:= 0
                                            , ud_length				:= sizeof(USINT)
                                            , p_ud_data				:= ( #s_ConfigWrDO.p_DataWrite )$^UDINT
                                            , ud_type				:= VM_MEMORY_ACCESS
                                            );

				//look for an error
				if ( sd_retval <> VARANMANAGER_OK ) then
					State := _CreateDOFailed;
					VaranIn.SetState( State );
					return;
				end_if;
     

				s_ConfigWrDO.p_Settings := s_ConfigWrDO.p_DataWrite - VM_DO_OFFSET_WR;
      
      end_if;
				us_ASYDOCount := s_Set_ASY_RD.us_DOCount + s_Set_ASY_WR.us_DOCount;
//			end_if;

			//set right address
			if ( s_ConfigWrDO.p_Handle <> NIL ) then
      
        if b_PayloadSupport then
          VaranIn.DisableDO(ud_DOHandle:=s_ConfigWrDO.p_Handle$UDINT);
        else
				s_ConfigWrDO.p_Settings^.ud_Address := ud_DeviceAddress + CodeStartAddress;
				
				s_ConfigWrDO.p_DataWrite^ := s_Config.us_ControlReg;

				VaranIn.ResetDataObject	( p_handleDO	:= s_ConfigWrDO.p_Handle
                                , us_state		:= VARAN_DO_NO_RUN
                                , ud_bytes		:= 1
                                );
			end_if;
	
			end_if;
	
			//----------------------------------------------------------------------------------------------
			//insert end commmand in sync list
			if ( ui_ISOByteCount ) then
				( ( p_ISOMoverCode + ui_ISOByteCount )$^t_StructEnd )^ := s_End;
				ui_ISOByteCount += sizeof( t_StructEnd );		

				//sync list starts with offset (first config data, then Fast access data )
				s_ListSettings.ui_SyncListStart	:= VM_DATAMOVER_HEADER + VM_DATAMOVER_CODE_OFFEST;
				s_ListSettings.ui_SyncListEnd	:= s_ListSettings.ui_SyncListStart + ui_ISOByteCount - sizeof( t_StructEnd );
			else
				//set pointers to end command
				s_ListSettings.ui_SyncListStart 	:= ui_EndAddressOff;
				s_ListSettings.ui_SyncListEnd		:= ui_EndAddressOff;
			end_if;

			//insert end commmand in async list
			if ( ui_ASYByteCount ) then
				( ( p_ASYMoverCode + ui_ASYByteCount )$^t_StructEnd )^ := s_End;
				ui_ASYByteCount += sizeof( t_StructEnd );		

				//sync list starts after ISO
				if ( ui_ISOByteCount <> 0 ) then
					s_ListSettings.ui_AsyncListStart:= s_ListSettings.ui_SyncListEnd + sizeof( t_StructEnd );
					s_ListSettings.ui_AsyncListEnd	:= s_ListSettings.ui_AsyncListStart + ui_ASYByteCount - sizeof( t_StructEnd );
				else
					s_ListSettings.ui_AsyncListStart:= VM_DATAMOVER_HEADER + VM_DATAMOVER_CODE_OFFEST;
					s_ListSettings.ui_AsyncListEnd	:= s_ListSettings.ui_AsyncListStart + ui_ASYByteCount - sizeof( t_StructEnd );
				end_if;
			else
				s_ListSettings.ui_AsyncListStart 	:= ui_EndAddressOff;
				s_ListSettings.ui_AsyncListEnd		:= ui_EndAddressOff;			
			end_if;
      
      if b_PayloadSupport then
        sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                  , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                  , udOffset    := CodeStartAddress + VM_LIST_CONFIG_OFFSET
                                                  , udLength    := sizeof( t_ListConfig )
                                                  , pusData     := ( #s_ListSettings )$^USINT
                                                  , pudErrorInfo:= NIL);  
                                                  
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _DirectAccessFailed;
          VaranIn.SetState( State );
          return;
        end_if;

			//write other list pointers
      else
			sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
                                        , uiAddress		:= ud_DeviceAddress + CodeStartAddress + VM_LIST_CONFIG_OFFSET
                                        , uiLen			:= sizeof( t_ListConfig )
                                        , uiRetryTimeout:= VaranIn.GetRetryTimeout( ud_bytes := sizeof( t_ListConfig ) )
                                        , pvData		:= #s_ListSettings
                                        , puiError		:= NIL
                                        );

			if ( sd_retval <> VARANMANAGER_OK ) then
				State := _DirectAccessFailed;
				VaranIn.SetState( State );
				return;
			end_if;
      end_if;

			//----------------------------------------------------------------------------------------------
			//write code of ISO
			sd_retval := WriteCode	( ud_address	:= ud_DeviceAddress + CodeStartAddress + s_ListSettings.ui_SyncListStart
                              , ud_length		:= ui_ISOByteCount
                              , p_data		:= p_ISOMoverCode$^UDINT
                              );

			//break when error
			if ( sd_retval <> VARANMANAGER_OK ) then
				return;
			end_if;

			//----------------------------------------------------------------------------------------------
			//we must start all handles
			//ISO RD
			if ( s_Set_ISO_RD.us_DOCount ) then 
      
        //we work with pointer (is faster)
        p_DO_RD := #a_DO_ISO_RD[ 0 ];
        
				for i := 0 to s_Set_ISO_RD.us_DOCount - 1 do
        
          if b_PayloadSupport then
            VaranIn.ChangeDOLengthOffset(ud_DOHandle:=p_DO_RD^.p_Handle$UDINT, ud_length_read:=p_DO_RD^.us_Length);
            VaranIn.EnableDO(ud_DOHandle:=p_DO_RD^.p_Handle$UDINT);            
          else
          
					//first set Device Address for DO
					p_DO_RD^.p_Settings^.ud_Address := ( p_DO_RD^.p_Settings^.ud_Address and 16#FFFF ) or ud_DeviceAddress;

					//change size of DO
					if ( p_DO_RD^.us_Length < 128 ) then
						p_DO_RD^.p_Handle^.usLengthofExpAnswer := p_DO_RD^.us_Length + 1;		//+1 for response
						p_DO_RD^.p_Settings^.us_ByteCnt := p_DO_RD^.us_Length;
					end_if;

					//start DO
					VaranIn.ResetDataObject	( p_handleDO	:= p_DO_RD^.p_Handle
                                  , us_state		:= VARAN_DO_CONT_RUN
                                  , ud_bytes		:= p_DO_RD^.us_Length
                                  );
          end_if;    
                      
          p_DO_RD += sizeof(t_DO_RD);
				end_for;
			end_if;


			//----------------------------------------------------------------------------------------------
			//we must start all handles
			//ISO WR
			if ( s_Set_ISO_WR.us_DOCount ) then 
      
        //we work with pointer (is faster)
        p_DO_WR := #a_DO_ISO_WR[ 0 ];
				for i := 0 to s_Set_ISO_WR.us_DOCount - 1 do
					if b_PayloadSupport then
            VaranIn.ChangeDOLengthOffset(ud_DOHandle:=p_DO_WR^.p_Handle$UDINT, ud_length_write:=p_DO_WR^.us_Length);
            VaranIn.EnableDO(ud_DOHandle:=p_DO_WR^.p_Handle$UDINT);           
          else
					
					//first set Device Address for DO
					p_DO_WR^.p_Settings^.ud_Address := ( p_DO_WR^.p_Settings^.ud_Address and 16#FFFF ) or ud_DeviceAddress;

					//change size of DO
					if ( p_DO_WR^.us_Length < 128 ) then

						p_DO_WR^.p_Handle^.usSendBufferLength := p_DO_WR^.us_Length + 6;		//+for command
						p_DO_WR^.p_Settings^.us_ByteCnt := p_DO_WR^.us_Length;

					end_if;

					//start DO
					VaranIn.ResetDataObject	( p_handleDO	:= p_DO_WR^.p_Handle
                                  , us_state		:= VARAN_DO_CONT_RUN
                                  , ud_bytes		:= p_DO_WR^.us_Length
                                  );
          end_if;
          p_DO_WR += sizeof(t_DO_WR);
				end_for;
			end_if;

			//----------------------------------------------------------------------------------------------
			//write code of ASY
			sd_retval := WriteCode	( ud_address	:= ud_DeviceAddress + CodeStartAddress + s_ListSettings.ui_AsyncListStart
                              , ud_length		:= ui_ASYByteCount
                              , p_data		:= p_ASYMoverCode$^UDINT
                              );

			//break when error
			if ( sd_retval <> VARANMANAGER_OK ) then
				return;
			end_if;

			//----------------------------------------------------------------------------------------------
			//we must start all handles
			//ASY RD
			if ( s_Set_ASY_RD.us_DOCount ) then 
      
        //we work with pointer (is faster)
        p_DO_RD := #a_DO_ASY_RD[ 0 ];
        
				for i := 0 to s_Set_ASY_RD.us_DOCount - 1 do
          if b_PayloadSupport then
            VaranIn.ChangeDOLengthOffset(ud_DOHandle:=p_DO_RD^.p_Handle$UDINT,  ud_length_read:=p_DO_RD^.us_Length);          
            VaranIn.EnableDO(ud_DOHandle:=p_DO_RD^.p_Handle$UDINT);           
          else
					//first set Device Address for DO
					p_DO_RD^.p_Settings^.ud_Address := ( p_DO_RD^.p_Settings^.ud_Address and 16#FFFF ) or ud_DeviceAddress;

					//change size of DO
					if ( p_DO_RD^.us_Length < 128 ) then

						p_DO_RD^.p_Handle^.usLengthofExpAnswer := p_DO_RD^.us_Length + 1;		//+1 for response
						p_DO_RD^.p_Settings^.us_ByteCnt := p_DO_RD^.us_Length;

					end_if;

					//start DO
					VaranIn.ResetDataObject	( p_handleDO	:= p_DO_RD^.p_Handle
                                  , us_state		:= VARAN_DO_CONT_RUN
                                  , ud_bytes		:= p_DO_RD^.us_Length
                                  );
          end_if;
          p_DO_RD += sizeof(t_DO_RD);
				end_for;
			end_if;
			//----------------------------------------------------------------------------------------------
			//we must start all handles
			//ASY WR
			if ( s_Set_ASY_WR.us_DOCount ) then 
      
        //we work with pointer (is faster)
        p_DO_WR := #a_DO_ASY_WR[ 0 ];
        
				for i := 0 to s_Set_ASY_WR.us_DOCount - 1 do
          if b_PayloadSupport then
            p_DO_WR^.b_DOIsRunning.StartRequest := TRUE;
            VaranIn.ChangeDOLengthOffset(ud_DOHandle:=p_DO_WR^.p_Handle$UDINT, ud_length_write:=p_DO_WR^.us_Length);
          else
					//first set Device Address for DO
					p_DO_WR^.p_Settings^.ud_Address := ( p_DO_WR^.p_Settings^.ud_Address and 16#FFFF ) or ud_DeviceAddress;

					//change size of DO
					if ( p_DO_WR^.us_Length < 128 ) then

						p_DO_WR^.p_Handle^.usSendBufferLength := p_DO_WR^.us_Length + 6;		//+for command
						p_DO_WR^.p_Settings^.us_ByteCnt := p_DO_WR^.us_Length;

					end_if;

					//start DO
					VaranIn.ResetDataObject	( p_handleDO	:= p_DO_WR^.p_Handle
                                  , us_state		:= VaranIn.SetRunStatus(VARAN_DO_SINGLE_RUN)
                                  , ud_bytes		:= p_DO_WR^.us_Length
                                  );
          end_if;
          p_DO_WR += sizeof(t_DO_WR);
				end_for;
			end_if;

			//----------------we have special DO----------------------------------------------------
			if ( us_SpecialDOCnt <> 0 ) then

				for i := 0 to us_SpecialDOCnt - 1 do
				
          if b_PayloadSupport then
            VaranIn.DisableDO(ud_DOHandle:=a_SpecialDO$UDINT);
          else
					//set address
					a_SpecialDO[ i ].p_Settings^.ud_Address := ( a_SpecialDO[ i ].p_Settings^.ud_Address and 16#FFFF ) + ud_DeviceAddress;

					//set values
					VaranIn.ResetDataObject	( p_handleDO	:= a_SpecialDO[ i ].p_Handle
                                  , us_state		:= VARAN_DO_NO_RUN
                                  , ud_bytes		:= a_SpecialDO[ i ].us_Length
              
                                  );
          end_if;      
				end_for;
			end_if;

      //start list (only first time
      if ( ui_ISOByteCount ) then

        s_Config.us_ControlReg.SyncListEnable	:= TRUE;

        //write config data (because we need direct accesses in init)
         if b_PayloadSupport then
          sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                    , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                    , udOffset    := CodeStartAddress
                                                    , udLength    := sizeof( t_DataMoverConfig )
                                                    , pusData     := ( #s_Config )$^USINT
                                                    , pudErrorInfo:= NIL);  
                                                    

          if ( sd_retval <> VARANMANAGER_OK ) then
            Varan_DataMover::State := _DirectAccessFailed;
            VaranIn.SetState( Varan_DataMover::State );
            return;
          end_if;
      
        else			
          sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
                                            , uiAddress		:= ud_DeviceAddress + CodeStartAddress
                                            , uiLen			:= sizeof( t_DataMoverConfig )
                                            , uiRetryTimeout:= VaranIn.GetRetryTimeout( ud_bytes := sizeof( t_DataMoverConfig ) )
                                            , pvData		:= #s_Config
                                            , puiError		:= NIL
                                            );

          if ( sd_retval <> VARANMANAGER_OK ) then
            Varan_DataMover::State := _DirectAccessFailed;
            VaranIn.SetState( Varan_DataMover::State );
            return;
          end_if;
        end_if;	
      end_if;	

      State := _ClassOk;

		//================================================================================================
		//=************************************* Disconnect *********************************************=
		//================================================================================================
		VARANMANAGER_CB_DISCONNECT:
			
      State := _NoHardware;
      
			SetDOsOff();
      
      // When useing the new Payload interface all DOs in the Projekt are created even if the module is not found 
      // This is done to avoid Recreating the same DOs again on Reconnect and leaving past DOs dangling around.
      if b_PayloadSupport = false then

			//----------------------------------------------------------------------------------------------
			//we must clear all length of DOs
			//ISO RD
			if ( s_Set_ISO_RD.us_DOCount ) then 
				for i := 0 to s_Set_ISO_RD.us_DOCount - 1 do
					
					//we work with pointer (is faster)
					a_DO_ISO_RD[ i ].us_Length := 0;
				end_for;
			end_if;
					
			//ISO WR
			if ( s_Set_ISO_WR.us_DOCount ) then 
				for i := 0 to s_Set_ISO_WR.us_DOCount - 1 do
					
					//we work with pointer (is faster)
					a_DO_ISO_WR[ i ].us_Length := 0;
				end_for;
			end_if;

			//ASY RD
			if ( s_Set_ASY_RD.us_DOCount ) then 
				for i := 0 to s_Set_ASY_RD.us_DOCount - 1 do
					
					//we work with pointer (is faster)
					a_DO_ASY_RD[ i ].us_Length := 0;
				end_for;
			end_if;
					
			//ASY WR
			if ( s_Set_ASY_WR.us_DOCount ) then 
				for i := 0 to s_Set_ASY_WR.us_DOCount - 1 do
					
					//we work with pointer (is faster)
					a_DO_ASY_WR[ i ].us_Length := 0;
				end_for;
			end_if;

			//set back length of code and creation information (on connect all info is collected again!)
			ui_ASYByteCount := 0;			
			ui_ISOByteCount := 0;			
			s_DAData.b_Init := FALSE;
      DO_Created      := FALSE; //#WP003a
      
      end_if;
    
	end_case;

	sd_retval := 0;

END_FUNCTION // Varan_DataMover::Varan_Callback
//=================================================================================================
//Rt Function of Varan Data Mover
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Varan_DataMover::RtWork
  VAR_INPUT
    EAX		: UDINT;
  END_VAR
  VAR_OUTPUT
    state		: UDINT;
  END_VAR

//-------------------------------------------------------------------------------------------------
#ifdef VM_DATAMOVER_ISO_TIME
	ISO_Time := TO_UINT( s_ISO_Time_DO.p_DataRead^ - ui_OldISOCounter );
	ui_OldISOCounter := s_ISO_Time_DO.p_DataRead^;
#endif
//-------------------------------------------------------------------------------------------------
	
	state:= READY;

END_FUNCTION //VIRTUAL GLOBAL Varan_DataMover::RtWork
//=================================================================================================
//Cy Function of Varan Data Mover
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Varan_DataMover::CyWork
  VAR_INPUT
    EAX			: UDINT;
  END_VAR
  VAR_OUTPUT
    state		: UDINT;
  END_VAR
  VAR
  	i :     UDINT;
  END_VAR

  state := ERROR;

	//we have two different states
	case ( EAX ) of

		0:	//check errors
			if ( s_ConfigDO.p_DataRead^.us_ErrorReg <> 0 ) then

				if ( s_ConfigDO.p_DataRead^.us_ErrorReg.TimeSliceError ) then
					TimeSliceError += 1;
					if ( TimeSliceErrorOn ) then
						VaranIn.SetState( _TimeSliceError );
					end_if;
					return;
				end_if;

				if ( s_ConfigDO.p_DataRead^.us_ErrorReg.WishboneError ) then
					WishboneError += 1;
				end_if;

				if ( s_ConfigDO.p_DataRead^.us_ErrorReg and 16#7 ) then
					OpcodeError += 1;
				end_if;
			end_if;
		
      if ( b_AdminStarted = TRUE & s_ConfigDO.p_DataRead^.us_StateReg.AdminActive = FALSE) then
        b_AdminStarted := FALSE;
        us_ControlRd.AdminActive := FALSE;
        ud_AdminCnt += 1;
      end_if;
      
      //check state of server
			if ( s_ConfigDO.p_DataRead^.us_ControlReg.AsyncListEnable = FALSE & us_Wait = 0 ) then
				state := READY;
			else

				state := BUSY;

				//first time after connect
				if ( us_Wait = 16#FF ) then
					StartAsyncList();
				
				//we must wait because of handshake
				elsif ( us_Wait ) then
					us_Wait -= 1;
				end_if;
			end_if;

		1:	//start list
			StartAsyncList();
      
      if b_PayloadSupport then
    
        if ( s_Set_ASY_WR.us_DOCount ) then  
          for i := 0 to s_Set_ASY_WR.us_DOCount - 1 do
            case a_DO_ASY_WR[i].b_DOIsRunning of
          
            SR_STATE_ENABLE_ME :  // DO is not running and start request is set ----------------------------------------
              VaranIn.EnableDO(ud_DOHandle := a_DO_ASY_WR[i].p_Handle$UDINT);        
              a_DO_ASY_WR[i].b_DOIsRunning  := SR_STATE_DISABLE_ME;
              
            SR_STATE_DISABLE_ME : // DO is running and start request is not set ----------------------------------------
              VaranIn.DisableDO(ud_DOHandle:= a_DO_ASY_WR[i].p_Handle$UDINT);
              a_DO_ASY_WR[i].b_DOIsRunning := SR_STATE_NOTHING;
              
            SR_STATE_LEAVE_ME_ENABLED : // DO is running and another start request is set ------------------------------
              a_DO_ASY_WR[i].b_DOIsRunning := SR_STATE_DISABLE_ME;
              
            end_case;
          end_for;
        end_if;
        
        case s_ConfigWrDO.b_DOIsRunning of

        SR_STATE_ENABLE_ME :  // DO is not running and start request is set ----------------------------------------
          VaranIn.EnableDO(ud_DOHandle := s_ConfigWrDO.p_Handle$UDINT);        
          s_ConfigWrDO.b_DOIsRunning  := SR_STATE_DISABLE_ME;
          
        SR_STATE_DISABLE_ME : // DO is running and start request is not set ----------------------------------------
          VaranIn.DisableDO(ud_DOHandle:= s_ConfigWrDO.p_Handle$UDINT);
          s_ConfigWrDO.b_DOIsRunning := SR_STATE_NOTHING;
          
        SR_STATE_LEAVE_ME_ENABLED : // DO is running and another start request is set ------------------------------
          s_ConfigWrDO.b_DOIsRunning := SR_STATE_DISABLE_ME;
          
	end_case;
    end_if;

  end_case;  
	
  
	

END_FUNCTION //VIRTUAL GLOBAL Varan_DataMover::CyWork
//=================================================================================================
//Function that varan class gets retry counter
//=================================================================================================
FUNCTION GLOBAL Varan_DataMover::GetRetryCounter
  VAR_OUTPUT
    ud_retries		: UDINT;
  END_VAR
  VAR
    i			: USINT;
  END_VAR

	ud_retries := 0;
	//check ISO RD DO's
	for i := 0 to VM_DATAMOVER_MAX_DO - 1 do

		//if handle not exists
		if ( a_DO_ISO_RD[ i ].p_Handle = NIL ) then
			exit;
		end_if;

		//if counter changes
    ud_retries := VaranIn.GetRetryCounter(ud_DOHandle := a_DO_ISO_RD[ i ].p_Handle$UDINT);
    if ( ud_retries <> a_DO_ISO_RD[ i ].us_OldRetryCounter ) then
      VaranIn.RetryCounter += TO_USINT( ud_retries - a_DO_ISO_RD[ i ].us_OldRetryCounter );
      a_DO_ISO_RD[ i ].us_OldRetryCounter := ud_retries$USINT;
		end_if;
	end_for;
	
	//check ISO WR DO's
	for i := 0 to VM_DATAMOVER_MAX_DO - 1 do

		//if handle not exists
		if ( a_DO_ISO_WR[ i ].p_Handle = NIL ) then
			exit;
		end_if;

    ud_retries := VaranIn.GetRetryCounter(ud_DOHandle := a_DO_ISO_WR[ i ].p_Handle$UDINT);
    if ( ud_retries <> a_DO_ISO_WR[ i ].us_OldRetryCounter ) then
      VaranIn.RetryCounter += TO_USINT( ud_retries - a_DO_ISO_WR[ i ].us_OldRetryCounter );
      a_DO_ISO_WR[ i ].us_OldRetryCounter := ud_retries$USINT;
		end_if;
	end_for;

	//check ASY RD DO's
	for i := 0 to VM_DATAMOVER_MAX_DO - 1 do

		//if handle not exists
		if ( a_DO_ASY_RD[ i ].p_Handle = NIL ) then
			exit;
		end_if;


    ud_retries := VaranIn.GetRetryCounter(ud_DOHandle := a_DO_ASY_RD[ i ].p_Handle$UDINT);
    if ( ud_retries <> a_DO_ASY_RD[ i ].us_OldRetryCounter ) then
      VaranIn.RetryCounter += TO_USINT( ud_retries - a_DO_ASY_RD[ i ].us_OldRetryCounter );
      a_DO_ASY_RD[ i ].us_OldRetryCounter := ud_retries$USINT;
		end_if;
	end_for;
	
	//check ASY WR DO's
	for i := 0 to VM_DATAMOVER_MAX_DO - 1 do

		//if handle not exists
		if ( a_DO_ASY_WR[ i ].p_Handle = NIL ) then
			exit;
		end_if;

    ud_retries := VaranIn.GetRetryCounter(ud_DOHandle := a_DO_ASY_WR[ i ].p_Handle$UDINT);
    if ( ud_retries <> a_DO_ASY_WR[ i ].us_OldRetryCounter ) then
      VaranIn.RetryCounter += TO_USINT( ud_retries - a_DO_ASY_WR[ i ].us_OldRetryCounter );
      a_DO_ASY_WR[ i ].us_OldRetryCounter := ud_retries$USINT;
		end_if;
	end_for;

	//check config DO
	if ( s_ConfigDO.p_Handle <> NIL ) then
	
		ud_retries := VaranIn.GetRetryCounter(ud_DOHandle := s_ConfigDO.p_Handle$UDINT);
    if ( ud_retries <> s_ConfigDO.us_OldRetryCounter ) then
      VaranIn.RetryCounter += TO_USINT( ud_retries - s_ConfigDO.us_OldRetryCounter );
      s_ConfigDO.us_OldRetryCounter := ud_retries$USINT;
		end_if;
	end_if;

	//check config DO
	if ( s_ConfigWrDO.p_Handle <> NIL ) then
	
		//if counter changes
    ud_retries := VaranIn.GetRetryCounter(ud_DOHandle := s_ConfigWrDO.p_Handle$UDINT);
    if ( ud_retries <> s_ConfigWrDO.us_OldRetryCounter ) then
      VaranIn.RetryCounter += TO_USINT( ud_retries - s_ConfigWrDO.us_OldRetryCounter );
      s_ConfigWrDO.us_OldRetryCounter := ud_retries$USINT;
		end_if;
	end_if;

//-------------------------------------------------------------------------------------------------
#ifdef VM_DATAMOVER_ISO_TIME
	//check ISO Time DO
	if ( s_ISO_Time_DO.p_Handle <> NIL ) then
	
    ud_retries := VaranIn.GetRetryCounter(ud_DOHandle := s_ISO_Time_DO.p_Handle$UDINT);
    if ( ud_retries <> s_ISO_Time_DO.us_OldRetryCounter ) then
      VaranIn.RetryCounter += TO_USINT( ud_retries - s_ISO_Time_DO.us_OldRetryCounter );
      s_ISO_Time_DO.us_OldRetryCounter := ud_retries$USINT;
		end_if;
	end_if;
#endif
//-------------------------------------------------------------------------------------------------

	//----------------we have special DO----------------------------------------------------
	if ( us_specialDOCnt <> 0 ) then

		for i := 0 to us_SpecialDOCnt - 1 do
    
      ud_retries := VaranIn.GetRetryCounter(ud_DOHandle := a_SpecialDO[ i ].p_Handle$UDINT);
      if ( ud_retries <> a_SpecialDO[ i ].us_OldRetryCounter ) then
        VaranIn.RetryCounter += TO_USINT( ud_retries - a_SpecialDO[ i ].us_OldRetryCounter );
        a_SpecialDO[ i ].us_OldRetryCounter := ud_retries$USINT;
			end_if;
		end_for;
	end_if;

END_FUNCTION //GLOBAL Varan_DataMover::GetRetryCounter
//=================================================================================================
//Function to set off all DO's
//=================================================================================================
FUNCTION GLOBAL Varan_DataMover::SetDOsOff
  VAR
    i		: USINT;
  END_VAR

	//check ISO RD DO's
	for i := 0 to VM_DATAMOVER_MAX_DO - 1 do

		//if handle not exists
		if ( a_DO_ISO_RD[ i ].p_Handle = NIL ) then
			exit;
		end_if;

		//set DO off
    VaranIn.DisableDO(ud_DOHandle := a_DO_ISO_RD[ i ].p_Handle$UDINT);
    a_DO_ISO_RD[ i ].b_DOIsRunning := 0;
	end_for;
	
	//check ISO WR DO's
	for i := 0 to VM_DATAMOVER_MAX_DO - 1 do

		//if handle not exists
		if ( a_DO_ISO_WR[ i ].p_Handle = NIL ) then
			exit;
		end_if;

		//set DO off
    VaranIn.DisableDO(ud_DOHandle := a_DO_ISO_WR[ i ].p_Handle$UDINT);
    a_DO_ISO_WR[ i ].b_DOIsRunning := 0;
	end_for;

	//check ASY RD DO's
	for i := 0 to VM_DATAMOVER_MAX_DO - 1 do

		//if handle not exists
		if ( a_DO_ASY_RD[ i ].p_Handle = NIL ) then
			exit;
		end_if;

		//set DO off
    VaranIn.DisableDO(ud_DOHandle := a_DO_ASY_RD[ i ].p_Handle$UDINT);
    a_DO_ASY_RD[ i ].b_DOIsRunning := 0;
	end_for;
	
	//check ASY WR DO's
	for i := 0 to VM_DATAMOVER_MAX_DO - 1 do

		//if handle not exists
		if ( a_DO_ASY_WR[ i ].p_Handle = NIL ) then
			exit;
		end_if;

		//set DO off
    VaranIn.DisableDO(ud_DOHandle := a_DO_ASY_WR[ i ].p_Handle$UDINT);
    a_DO_ASY_WR[ i ].b_DOIsRunning := 0;
	end_for;

	//check config DO
	if ( s_ConfigDO.p_Handle <> NIL ) then
	
		//set DO off
		VaranIn.DisableDO(ud_DOHandle := s_ConfigDO.p_Handle$UDINT);
	end_if;

	//check config WR DO
	if ( s_ConfigWrDO.p_Handle <> NIL ) then
	
		//set DO off
		VaranIn.DisableDO(ud_DOHandle := s_ConfigWrDO.p_Handle$UDINT);
    s_ConfigWrDO.b_DOIsRunning := 0;
	end_if;

//-------------------------------------------------------------------------------------------------
#ifdef VM_DATAMOVER_ISO_TIME
	//check ISO Time DO
	if ( s_ISO_Time_DO.p_Handle <> NIL ) then
	
		//set DO off
		VaranIn.DisableDO(ud_DOHandle := s_ISO_Time_DO.p_Handle$UDINT);
	end_if;
#endif
//-------------------------------------------------------------------------------------------------

	//----------------we have special DO----------------------------------------------------
	if ( us_SpecialDOCnt <> 0 ) then

		for i := 0 to us_SpecialDOCnt - 1 do
			//set DO off
			VaranIn.DisableDO(ud_DOHandle := a_SpecialDO[i].p_Handle$UDINT);
      a_SpecialDO[i].b_DOIsRunning := 0;
		end_for;
	end_if;

END_FUNCTION //GLOBAL Varan_DataMover::SetDOsOff
//=================================================================================================
//Function to start ASY List
//=================================================================================================
FUNCTION  Varan_DataMover::StartAsyncList
  VAR
    i			: USINT;
    StartIt : BOOL;
    lbs_ControlReg : t_MoverConfigReg;
  END_VAR

  // switch off dias alive enable
	s_Config.us_ControlReg.DiasAliveEnable	:= FALSE;

	//if we have ASY DO's
	if ( s_Set_ASY_WR.us_DOCount ) then 
		for i := 0 to s_Set_ASY_WR.us_DOCount - 1 do   
			//start DO single
      if b_PayloadSupport then
        a_DO_ASY_WR[ i ].b_DOIsRunning.StartRequest := TRUE;
      else       
      a_DO_ASY_WR[ i ].p_Handle^.ucCtrlStat := VaranIn.SetRunStatus(VARAN_DO_SINGLE_RUN);
      end_if;
		end_for;
	end_if;

  StartIt := FALSE;
	//if we have ASY code
	if ( ui_ASYByteCount ) then
  	//start async list
    s_Config.us_ControlReg.AsyncListEnable	:= TRUE;
    StartIt := TRUE;
  else
  	//don't start async list
    s_Config.us_ControlReg.AsyncListEnable	:= FALSE;
    
    // if there is no ASY code => don't wait for anything
    us_Wait := 0;
  end_if;
  lbs_ControlReg := s_Config.us_ControlReg;

  if ( lbs_ControlReg.AdminEnable = TRUE ) then
    b_AdminStarted := TRUE;
    us_ControlRd.AdminActive := TRUE;
    StartIt := TRUE;
  end_if;
    
  if StartIt then  
    s_ConfigWrDO.p_DataWrite^ := lbs_ControlReg;
    
    // reset flag for starting admin task
    IF lbs_ControlReg.AdminEnable = TRUE THEN 
      s_Config.us_ControlReg.AdminEnable := FALSE;
    END_IF;
    
    if b_PayloadSupport then
      s_ConfigWrDO.b_DOIsRunning.StartRequest :=TRUE;
    else     
    s_ConfigWrDO.p_Handle^.ucCtrlStat := VaranIn.SetRunStatus(VARAN_DO_SINGLE_RUN);
    end_if;
		us_Wait := 1;		//because otherwise we have old async ready bit
    
	end_if;

END_FUNCTION // Varan_DataMover::StartAsyncList
//[#ENGLISH]
//=================================================================================================
//Function to add an ISO Rd Enable
//=================================================================================================
//[>ud_add]address of access
//[>ud_length]length of data
//[>p_data]address of pointer variable to save data address
//[>p_enable]address of pointer to start single call
FUNCTION GLOBAL Varan_DataMover::AddRdISOEnable
  VAR_INPUT
    ud_add			: UDINT;
    ud_length		: UDINT;
    p_data			: ^void;
    p_enable		: ^USINT;
      ud_Priority 	: HDINT;
    p_DataAddr : ^HDINT;
		p_UserDOHandle 	: ^UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    p_Mov			: ^t_StructMoveEn;
    ud_dest_add		: UDINT;
    ud_en_add		: UDINT;
  END_VAR

	//get memory for single call
  sd_retval := GetMemoryISORd(p_add         := #ud_dest_add
                              , p_data	:= p_data
                              , ud_len	:= ud_length
                              , ud_Priority := ud_Priority
                            , p_UserDOHandle:= p_UserDOHandle
                              );

	if ( sd_retval <> VARANMANAGER_OK ) then
		return;
	end_if;

  //give back the address if requested
  if p_DataAddr then
    p_DataAddr^ := ud_dest_add;
  end_if;

	//for enable byte
	sd_retval := GetMemoryISOWr	( p_add		:= #ud_en_add
                              , p_data	:= p_enable
                              , ud_len	:= 1
                              );

	if ( sd_retval <> VARANMANAGER_OK ) then
		return;
	end_if;

	//give back address of enable byte
	( ( ( p_enable$^UDINT )^ )$^USINT )^ := 0;

	//save opcodes in class
	if ( p_ISOMoverCode = NIL ) then
		//allocate memory
		p_ISOMoverCode$^void := To_StdLib.Malloc( s_Set_ISO_RD.ui_DPRAMSize + s_Set_ISO_WR.ui_DPRAMSize );

		if ( p_ISOMoverCode  = NIL ) then
			State := _MemoryFault;
			sd_retval := -103;
			VaranIn.SetState( State );
			return;
		end_if;
	end_if;

	//first check length
	if ( CheckLengthOfCode() = FALSE ) then
		sd_retval := -102;
		return;
	end_if;

	//check size of free memory
	if (( ui_ISOByteCount + sizeof( t_StructMoveEn )) > ( s_Set_ISO_RD.ui_DPRAMSize + s_Set_ISO_WR.ui_DPRAMSize )) then
		State := _MemoryFault;
		sd_retval := -102;
		VaranIn.SetState( State );
		return;
	end_if;

	//get right pointer
	p_Mov := p_ISOMoverCode + ui_ISOByteCount;

	p_Mov^.us_Command 		:= VM_DATAMOVER_MOVE_EN_OP;
	p_Mov^.ui_Length		:= ud_length$UINT;
	p_Mov^.us_Length		:= ( ud_length shr 16 )$USINT;
	p_Mov^.ud_SourceAdd		:= ud_add;
	p_Mov^.ud_DestAdd		:= ud_dest_add;
	p_Mov^.ud_EnableAddByte	:= ud_en_add;
	
	ui_ISOByteCount += sizeof( t_StructMoveEn );

	sd_retval := VARANMANAGER_OK;

END_FUNCTION //GLOBAL Varan_DataMover::AddRdISOSingle
//[#ENGLISH]
//=================================================================================================
//Function to add an ISO Wr Enable
//=================================================================================================
//[>ud_add]address of access
//[>ud_length]length of data
//[>p_data]address of pointer variable to save data address
//[>p_enable]address of pointer to start single call
FUNCTION GLOBAL Varan_DataMover::AddWrISOEnable
  VAR_INPUT
    ud_add			: UDINT;
    ud_length		: UDINT;
    p_data			: ^void;
    p_enable		: ^USINT;
      ud_Priority 	: HDINT;
    p_DataAddr : ^HDINT;
		p_UserDOHandle 	: ^UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    p_Mov			: ^t_StructMoveEn;
    ud_dest_add		: UDINT;
  END_VAR

	//get memory for write single call (+1 because of enable byte)
  sd_retval := GetMemoryISOWr(p_add         := #ud_dest_add
                              , p_data	:= p_data
                              , ud_len	:= ud_length + 1
                              , ud_Priority := ud_Priority
                            , p_UserDOHandle:= p_UserDOHandle
                              );

	if ( sd_retval <> VARANMANAGER_OK ) then
		return;
	end_if;

  //give back the address if requested
  if p_DataAddr then
    p_DataAddr^ := ud_dest_add;
  end_if;

	//give back address of enable byte
	( p_enable$^UDINT )^ := ( p_data$^UDINT )^ + ud_length;
	( ( ( p_enable$^UDINT )^ )$^USINT )^ := 0;

	//save opcodes in class
	if ( p_ISOMoverCode = NIL ) then
		//allocate memory
		p_ISOMoverCode$^void := To_StdLib.Malloc( s_Set_ISO_WR.ui_DPRAMSize + s_Set_ISO_RD.ui_DPRAMSize );

		if ( p_ISOMoverCode = NIL ) then
			State := _MemoryFault;
			sd_retval := -103;
			VaranIn.SetState( State );
			return;
		end_if;
	end_if;

	//first check length
	if ( CheckLengthOfCode() = FALSE ) then
		sd_retval := -102;
		return;
	end_if;

	//check size of free memory
	if (( ui_ISOByteCount + sizeof( t_StructMoveEn )) > ( s_Set_ISO_RD.ui_DPRAMSize + s_Set_ISO_WR.ui_DPRAMSize )) then
		State := _MemoryFault;
		sd_retval := -102;
		VaranIn.SetState( State );
		return;
	end_if;

	//get right pointer
	p_Mov := p_ISOMoverCode + ui_ISOByteCount;

	p_Mov^.us_Command 		:= VM_DATAMOVER_MOVE_EN_OP;
	p_Mov^.ui_Length		:= ud_length$UINT;
	p_Mov^.us_Length		:= ( ud_length shr 16 )$USINT;
	p_Mov^.ud_SourceAdd		:= ud_dest_add;
	p_Mov^.ud_DestAdd		:= ud_add;
	p_Mov^.ud_EnableAddByte	:= ud_dest_add + ud_length;

	ui_ISOByteCount += sizeof( t_StructMoveEn );

	sd_retval := VARANMANAGER_OK;

END_FUNCTION //GLOBAL Varan_DataMover::AddWrISOSingle
//[#ENGLISH]
//=================================================================================================
//Function to add an ASY Rd Enable
//=================================================================================================
//[>ud_add]address of access
//[>ud_length]length of data
//[>p_data]address of pointer variable to save data address
//[>p_enable]address of pointer to start single call
FUNCTION GLOBAL Varan_DataMover::AddRdASYEnable
  VAR_INPUT
    ud_add			: UDINT;
    ud_length		: UDINT;
    p_data			: ^void;
    p_enable		: ^USINT;
      ud_Priority 	: HDINT;
    p_DataAddr : ^HDINT;
		p_UserDOHandle 	: ^UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    p_Mov			: ^t_StructMoveEn;
    ud_dest_add		: UDINT;
    ud_en_add		: UDINT;
  END_VAR

	//get memory for write single call
  sd_retval := GetMemoryASYRd(p_add         := #ud_dest_add
                              , p_data	:= p_data
                              , ud_len	:= ud_length
                              , ud_Priority := ud_Priority
                            , p_UserDOHandle:=p_UserDOHandle
                              );

	if ( sd_retval <> VARANMANAGER_OK ) then
		return;
	end_if;

  //give back the address if requested
  if p_DataAddr then
    p_DataAddr^ := ud_dest_add;
  end_if;

	//for enable byte
	sd_retval := GetMemoryASYWr	( p_add		:= #ud_en_add
                              , p_data	:= p_enable
                              , ud_len	:= 1
                              , ud_Priority := ud_Priority
                              );

	if ( sd_retval <> VARANMANAGER_OK ) then
		return;
	end_if;

	//give back address of enable byte
	( ( ( p_enable$^UDINT )^ )$^USINT )^ := 0;

	//save opcodes in class
	if ( p_ASYMoverCode = NIL ) then
		//allocate memory
		p_ASYMoverCode$^void := To_StdLib.Malloc( s_Set_ASY_RD.ui_DPRAMSize + s_Set_ASY_WR.ui_DPRAMSize );

		if ( p_ASYMoverCode  = NIL ) then
			State := _MemoryFault;
			sd_retval := -103;
			VaranIn.SetState( State );
			return;
		end_if;
	end_if;

	//first check length
	if ( CheckLengthOfCode() = FALSE ) then
		sd_retval := -102;
		return;
	end_if;

	//check size of free memory
	if (( ui_ASYByteCount + sizeof( t_StructMoveEn )) > ( s_Set_ASY_RD.ui_DPRAMSize + s_Set_ASY_WR.ui_DPRAMSize )) then
		State := _MemoryFault;
		sd_retval := -102;
		VaranIn.SetState( State );
		return;
	end_if;

	//get right pointer
	p_Mov := p_ASYMoverCode + ui_ASYByteCount;

	p_Mov^.us_Command 		:= VM_DATAMOVER_MOVE_EN_OP;
	p_Mov^.ui_Length		:= ud_length$UINT;
	p_Mov^.us_Length		:= ( ud_length shr 16 )$USINT;
	p_Mov^.ud_SourceAdd		:= ud_add;
	p_Mov^.ud_DestAdd		:= ud_dest_add;
	p_Mov^.ud_EnableAddByte	:= ud_en_add;
	
	ui_ASYByteCount += sizeof( t_StructMoveEn );

	sd_retval := VARANMANAGER_OK;

END_FUNCTION //GLOBAL Varan_DataMover::AddRdASYEnable
//[#ENGLISH]
//=================================================================================================
//Function to add an ASY Wr Enable
//=================================================================================================
//[>ud_add]address of access
//[>ud_length]length of data
//[>p_data]address of pointer variable to save data address
//[>p_enable]address of pointer to start single call
FUNCTION GLOBAL Varan_DataMover::AddWrASYEnable
  VAR_INPUT
    ud_add			: UDINT;
    ud_length		: UDINT;
    p_data			: ^void;
    p_enable		: ^USINT;
    ud_Priority 	: HDINT;
    p_DataAddr : ^HDINT;
		p_UserDOHandle 	: ^UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    p_Mov			: ^t_StructMoveEn;
    ud_dest_add		: UDINT;
  END_VAR

	//get memory for write single call (+1 because of enable byte)
  sd_retval := GetMemoryASYWr(p_add         := #ud_dest_add
                              , p_data	:= p_data
                              , ud_len	:= ud_length + 1
                              , ud_Priority := ud_Priority
                            , p_UserDOHandle:= p_UserDOHandle
                              );

	if ( sd_retval <> VARANMANAGER_OK ) then
		return;
	end_if;

  //give back the address if requested
  if p_DataAddr then
    p_DataAddr^ := ud_dest_add;
  end_if;

	//give back address of enable byte
	( p_enable$^UDINT )^ := ( p_data$^UDINT )^ + ud_length;
	( ( ( p_enable$^UDINT )^ )$^USINT )^ := 0;

	//save opcodes in class
	if ( p_ASYMoverCode = NIL ) then
		//allocate memory
		p_ASYMoverCode$^void := To_StdLib.Malloc( s_Set_ASY_WR.ui_DPRAMSize + s_Set_ASY_RD.ui_DPRAMSize );

		if ( p_ASYMoverCode = NIL ) then
			State := _MemoryFault;
			sd_retval := -103;
			VaranIn.SetState( State );
			return;
		end_if;
	end_if;

	//first check length
	if ( CheckLengthOfCode() = FALSE ) then
		sd_retval := -102;
		return;
	end_if;

	//check size of free memory
	if (( ui_ASYByteCount + sizeof( t_StructMoveEn )) > ( s_Set_ASY_RD.ui_DPRAMSize + s_Set_ASY_WR.ui_DPRAMSize )) then
		State := _MemoryFault;
		sd_retval := -102;
		VaranIn.SetState( State );
		return;
	end_if;

	//get right pointer
	p_Mov := p_ASYMoverCode + ui_ASYByteCount;

	p_Mov^.us_Command 		:= VM_DATAMOVER_MOVE_EN_OP;
	p_Mov^.ui_Length		:= ud_length$UINT;
	p_Mov^.us_Length		:= ( ud_length shr 16 )$USINT;
	p_Mov^.ud_SourceAdd		:= ud_dest_add;
	p_Mov^.ud_DestAdd		:= ud_add;
	p_Mov^.ud_EnableAddByte	:= ud_dest_add + ud_length;

	ui_ASYByteCount += sizeof( t_StructMoveEn );

	sd_retval := VARANMANAGER_OK;

END_FUNCTION //GLOBAL Varan_DataMover::AddWrASYSingle
//[#ENGLISH]
//=================================================================================================
//Function to get next free space for ISO read
//=================================================================================================
//[>p_add]value for destination address
//[>p_data]pointer to data in DO
//[>ud_len]length of data
FUNCTION  Varan_DataMover::GetMemoryISORd
  VAR_INPUT
    p_add			: ^UDINT;
    p_data			: ^void;
    ud_len			: UDINT;
    ud_Priority 	: HDINT;
    p_UserDOHandle 	: ^UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    p_DO			: ^t_DO_RD;
    i				: UINT;
  END_VAR

	sd_retval := 0;
	p_DO := NIL;

	//not more than 128 Byte
	if ( ud_len > 128 ) then
		sd_retval := -100;
		return;
	end_if;

	//search for free space
	if ( s_Set_ISO_RD.us_DOCount ) then
		for i := 0 to s_Set_ISO_RD.us_DOCount - 1 do
			if ( a_DO_ISO_RD[ i ].us_Length + ud_len <= 128 ) then
				p_DO := #a_DO_ISO_RD[ i ];
				p_add^ := ( i * 128 ) + p_DO^.us_Length + s_Set_ISO_RD.ui_DPRAMOffsetSub;
				exit;
			end_if;
		end_for;
	end_if;

	//if no space create DO
	if ( p_DO = NIL ) then

    //#WP003 start
    //check for error -> after creation, no DO change is possible
    if DO_Created then
      State := _CreateDOFailed;
      VaranIn.SetState( State );
      return;
    end_if; 

    //check if we have enough space
    if ( s_Set_ISO_RD.ui_DPRAMSize / 128 <= s_Set_ISO_RD.us_DOCount ) then
      sd_retval := -101;
      State := _MemoryFault;
      VaranIn.SetState( State );
      return;
    end_if;

    p_DO := #a_DO_ISO_RD[ s_Set_ISO_RD.us_DOCount ];
	  p_add^ := s_Set_ISO_RD.us_DOCount * 128 + s_Set_ISO_RD.ui_DPRAMOffsetSub;
	  s_Set_ISO_RD.us_DOCount += 1;
	end_if;			
		
	//give back data pointer of DO
	( p_data$^UDINT )^ := p_DO^.p_DataRead$UDINT + p_DO^.us_Length;

	//set new length of DO
	p_DO^.us_Length += ud_len$USINT;

  // save the priority with the DO
  p_DO^.ud_Priority := ud_Priority;
  
  // save pointer to save the DO Handle to
  p_DO^.p_UserDOHandle := p_UserDOHandle;

  //WP003 start
  //if first callback give back data-pointer to dummy memory area
  if DO_Created = 0 then
    p_DO^.p_DataRead := p_DummyDataRdWr;
    ( p_data$^UDINT )^ := p_DO^.p_DataRead$UDINT;
  end_if; 
  //WP003 end
END_FUNCTION // Varan_DataMover::GetMemoryISORd
//[#ENGLISH]
//=================================================================================================
//Function to get next free space for ISO write
//=================================================================================================
//[>p_add]value for destination address
//[>p_data]pointer to data in DO
//[>ud_len]length of data
FUNCTION  Varan_DataMover::GetMemoryISOWr
  VAR_INPUT
    p_add		: ^UDINT;
    p_data		: ^void;
    ud_len		: UDINT;
    ud_Priority 	: HDINT;
    p_UserDOHandle 	: ^UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    p_DO			: ^t_DO_WR;
    i				: UINT;
  END_VAR

	sd_retval := 0;
	p_DO := NIL;

	//not more than 128 Byte
	if ( ud_len > 128 ) then
		sd_retval := -100;
		return;
	end_if;

	//search for free space
	if ( s_Set_ISO_WR.us_DOCount ) then
		for i := 0 to s_Set_ISO_WR.us_DOCount - 1 do
			if ( a_DO_ISO_WR[ i ].us_Length + ud_len <= 128 ) then
				p_DO := #a_DO_ISO_WR[ i ];
				p_add^ := ( i * 128 ) + p_DO^.us_Length + s_Set_ISO_WR.ui_DPRAMOffsetSub;
				exit;
			end_if;
		end_for;
	end_if;

	//if no space create new DO
	if ( p_DO = NIL ) then

    //#WP003 start
    //check for error -> after creation, no DO change is possible
    if DO_Created then
      State := _CreateDOFailed;
      VaranIn.SetState( State );
      return;
    end_if;

		//check if we have enough space
		if ( s_Set_ISO_WR.ui_DPRAMSize / 128 <= s_Set_ISO_WR.us_DOCount ) then
			sd_retval := -101;
			State := _MemoryFault;
			VaranIn.SetState( State );
			return;
		end_if;
    //#WP003 end

		p_DO := #a_DO_ISO_WR[ s_Set_ISO_WR.us_DOCount ];
		p_add^ := s_Set_ISO_WR.us_DOCount * 128 + s_Set_ISO_WR.ui_DPRAMOffsetSub;
		s_Set_ISO_WR.us_DOCount += 1;
	end_if;

	//give back data pointer of DO
	( p_data$^UDINT )^ := p_DO^.p_DataWrite$UDINT + p_DO^.us_Length;

	//set new length of DO
	p_DO^.us_Length += ud_len$USINT;

  // save the priority with the DO
  p_DO^.ud_Priority := ud_Priority;

  // save pointer to save the DO Handle to
  p_DO^.p_UserDOHandle := p_UserDOHandle;
  
  //WP003 start
  //if first callback give back data-pointer to dummy memory area
  if DO_Created = 0 then
    p_DO^.p_DataWrite := p_DummyDataRdWr;
    ( p_data$^UDINT )^ := p_DO^.p_DataWrite$UDINT;
  end_if; 
  //WP003 end
END_FUNCTION // Varan_DataMover::GetMemoryISOWr
//[#ENGLISH]
//=================================================================================================
//Function to get next free space for ASY read
//=================================================================================================
//[>p_add]value for destination address
//[>p_data]pointer to data in DO
//[>ud_len]length of data
FUNCTION  Varan_DataMover::GetMemoryASYRd
  VAR_INPUT
    p_add		: ^UDINT;
    p_data		: ^void;
    ud_len		: UDINT;
    ud_Priority 	: HDINT;
    p_UserDOHandle 	: ^UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    p_DO			: ^t_DO_RD;
    i				: UINT;
  END_VAR

	sd_retval := 0;
	p_DO := NIL;

	//not more than 128 Byte
	if ( ud_len > 128 ) then
		sd_retval := -100;
		return;
	end_if;

	p_DO := NIL;
	
	//search for free space
	if ( s_Set_ASY_RD.us_DOCount ) then
		for i := 0 to s_Set_ASY_RD.us_DOCount - 1 do
			if ( a_DO_ASY_RD[ i ].us_Length + ud_len <= 128 ) then
				p_DO := #a_DO_ASY_RD[ i ];
				p_add^ := ( i * 128 ) + p_DO^.us_Length + s_Set_ASY_RD.ui_DPRAMOffsetSub;
				exit;
			end_if;
		end_for;
	end_if;

	//if no space in DOs allocate new DO
	if ( p_DO = NIL ) then

      //#WP003 start
      //check for error -> after creation, no DO change is possible
      if DO_Created then
        State := _CreateDOFailed;
	    VaranIn.SetState( State );
	    return;
      end_if;

	  //check if we have enough space
	  if ( s_Set_ASY_RD.ui_DPRAMSize / 128 <= s_Set_ASY_RD.us_DOCount ) then
		sd_retval := -101;
		State := _MemoryFault;
		VaranIn.SetState( State );
		return;
	  end_if;
      //#WP003 end

	  p_DO := #a_DO_ASY_RD[ s_Set_ASY_RD.us_DOCount ];
	  p_add^ := s_Set_ASY_RD.us_DOCount * 128 + s_Set_ASY_RD.ui_DPRAMOffsetSub;
	  s_Set_ASY_RD.us_DOCount += 1;
    end_if;

	//give back data pointer of DO
	( p_data$^UDINT )^ := p_DO^.p_DataRead$UDINT + p_DO^.us_Length;

	//set new length of DO
	p_DO^.us_Length += ud_len$USINT;

  // save the priority with the DO
  p_DO^.ud_Priority := ud_Priority;

  // save pointer to save the DO Handle to
  p_DO^.p_UserDOHandle := p_UserDOHandle;
  
  //WP003 start
  //if first callback give back data-pointer to dummy memory area
  if DO_Created = 0 then
    p_DO^.p_DataRead := p_DummyDataRdWr;
    ( p_data$^UDINT )^ := p_DO^.p_DataRead$UDINT;
  end_if; 
  //WP003 end

END_FUNCTION // Varan_DataMover::GetMemoryASYRd
//[#ENGLISH]
//=================================================================================================
//Function to get next free space for ASY write
//=================================================================================================
//[>p_add]value for destination address
//[>p_data]pointer to data in DO
//[>ud_len]length of data
FUNCTION  Varan_DataMover::GetMemoryASYWr
  VAR_INPUT
    p_add		: ^UDINT;
    p_data		: ^void;
    ud_len		: UDINT;
      ud_Priority 	: HDINT;
    p_UserDOHandle 	: ^UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    p_DO			: ^t_DO_WR;
    i				: UINT;
  END_VAR

	sd_retval := 0;
	p_DO := NIL;

	//not more than 128 Byte
	if ( ud_len > 128 ) then
		sd_retval := -100;
		return;
	end_if;
	
	//search for free space
	if ( s_Set_ASY_WR.us_DOCount ) then
		for i := 0 to s_Set_ASY_WR.us_DOCount - 1 do
			if ( a_DO_ASY_WR[ i ].us_Length + ud_len <= 128 ) then
				p_DO := #a_DO_ASY_WR[ i ];
				p_add^ := ( i * 128 ) + p_DO^.us_Length + s_Set_ASY_WR.ui_DPRAMOffsetSub;
				exit;
			end_if;
		end_for;
	end_if;

  //if no space in DOs allocate new DO
  if ( p_DO = NIL ) then

  //#WP003 start
  //check for error -> after creation, no DO change is possible
    if DO_Created then
      State := _CreateDOFailed;
      VaranIn.SetState( State );
      return;
    end_if;

	  //check if we have enough space
	  if ( s_Set_ASY_WR.ui_DPRAMSize / 128 <= s_Set_ASY_WR.us_DOCount ) then
      sd_retval := -101;
      State := _MemoryFault;
      VaranIn.SetState( State );
      return;
	  end_if;
      //#WP003 end

	  p_DO := #a_DO_ASY_WR[ s_Set_ASY_WR.us_DOCount ];
	  p_add^ := s_Set_ASY_WR.us_DOCount * 128 + s_Set_ASY_WR.ui_DPRAMOffsetSub;
	  s_Set_ASY_WR.us_DOCount += 1;
	end_if;

	//give back data pointer of DO
	( p_data$^UDINT )^ := p_DO^.p_DataWrite$UDINT + p_DO^.us_Length;

	//set new length of DO
	p_DO^.us_Length += ud_len$USINT;

  // save the priority with the DO
  p_DO^.ud_Priority := ud_Priority;

  // save pointer to save the DO Handle to
  p_DO^.p_UserDOHandle := p_UserDOHandle;
  
  //WP003 start
  //if first callback give back data-pointer to dummy memory area
  if DO_Created = 0 then
    p_DO^.p_DataWrite := p_DummyDataRdWr;
    ( p_data$^UDINT )^ := p_DO^.p_DataWrite$UDINT;
  end_if; 
  //WP003 end
    
END_FUNCTION // Varan_DataMover::GetMemoryASYWr
//[#ENGLISH]
//=================================================================================================
//Function to set DIAS Alvie Signal Address
//=================================================================================================
//[>ud_address]address of dias module
FUNCTION GLOBAL Varan_DataMover::SetDiasAliveSignal
  VAR_INPUT
    ud_address		: UDINT;
    us_mode			: USINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    a_data			: ARRAY[0..4] OF USINT;
  END_VAR

	a_data[ 0 ]$UDINT := ud_address;
	a_data[ 4 ] := us_mode;
  if b_PayloadSupport then
    //write config data (because we need direct accesses in init)
    sd_retval := MULTI_VARAN_iExecuteDirectAccess(hNodeHandle := ud_HandleModule
                                                , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                , udOffset    := CodeStartAddress + VM_DATAMOVER_DIAS_ALIVE
                                                , udLength    := sizeof(  a_data )
                                                , pusData     := ( #a_data )$^USINT
                                                , pudErrorInfo:= NIL);  
                                              
    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      VaranIn.SetState( State );
      return;
    end_if;
    
    s_Config.us_ControlReg.DiasAliveEnable := TRUE;
    
    //write config data (because we need direct accesses in init)
    sd_retval := MULTI_VARAN_iExecuteDirectAccess(hNodeHandle := ud_HandleModule
                                                , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                , udOffset    := CodeStartAddress
                                                , udLength    := sizeof( t_DataMoverConfig )
                                                , pusData     := ( #s_Config )$^USINT
                                                , pudErrorInfo:= NIL);  
                                              
    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      VaranIn.SetState( State );
      return;
    end_if;
    
  else			
    //write config data (because we need direct accesses in init)
    sd_retval := VARAN_iWriteMemoryDA(uiManager     := ud_VaranManagerNr
                                    , uiAddress     := ud_DeviceAddress + CodeStartAddress + VM_DATAMOVER_DIAS_ALIVE
                                    , uiLen         := sizeof( a_data )
                                    , uiRetryTimeout:= s_DAData.ud_RetryTimeout
                                    , pvData        := #a_data
                                    , puiError      := NIL
                                    );
    
    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      VaranIn.SetState( State );
      return;
    end_if;

    s_Config.us_ControlReg.DiasAliveEnable := TRUE;

    //write config data (because we need direct accesses in init)
    sd_retval := VARAN_iWriteMemoryDA(uiManager     := ud_VaranManagerNr
                                    , uiAddress     := ud_DeviceAddress + CodeStartAddress
                                    , uiLen         := sizeof( t_DataMoverConfig )
                                    , uiRetryTimeout:= VaranIn.GetRetryTimeout( ud_bytes := sizeof( t_DataMoverConfig ) )
                                    , pvData        := #s_Config
                                    , puiError      := NIL
                                     );

    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      VaranIn.SetState( State );
      return;
    end_if;
  end_if;

END_FUNCTION //GLOBAL Varan_DataMover::SetDiasAliveSignal
//=================================================================================================
//Function check if we have enough code space
//=================================================================================================
FUNCTION  Varan_DataMover::CheckLengthOfCode
  VAR_OUTPUT
    b_available		: BOOL;
  END_VAR

	b_available := TRUE;	

	//check length
	if ( ui_ISOByteCount + ui_ASYByteCount + sizeof( t_StructMove ) + sizeof( t_StructEnd ) > ( CodeSize - VM_DATAMOVER_CODE_OFFEST ) ) then
		State := _MemoryFault;
		VaranIn.SetState( State );
		b_available := FALSE;	
		return;
	end_if;

END_FUNCTION // Varan_DataMover::CheckLengthOfCode
//[#ENGLISH]
//=================================================================================================
//Function to write code to DPRAM
//=================================================================================================
//[>ud_address]address where code should be written
//[>ud_length]length of code
//[>p_data]pointer to data
FUNCTION  Varan_DataMover::WriteCode
  VAR_INPUT
    ud_address		: UDINT;
    ud_length		: UDINT;
    p_data			: ^UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR
  VAR
    ud_cnt			: UDINT;
  END_VAR

	//first set fault
	sd_retval := -100;
	ud_cnt := 0;

	//while bytes are available
	while ( ud_length ) do

		//if we have more than 128 bytes or exactly 128 bytes
		if ( ud_length >= 128 ) then
      if b_PayloadSupport then
			//write with direct access
        sd_retval := MULTI_VARAN_iExecuteDirectAccess(hNodeHandle := ud_HandleModule
                                                , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                    , udOffset    := (ud_address + ( ud_cnt * 128 )) and 16#FFFF // Remove DeviceAddress so that offset remains                                                
                                                    , udLength    := 128
                                                    , pusData     := ( p_data + ( ud_cnt * 128 ))$^USINT
                                                , pudErrorInfo:= NIL);  
                                                
        //look for error
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _DirectAccessFailed;
          VaranIn.SetState( State );
          return;
        end_if;
      else
        sd_retval := VARAN_iWriteMemoryDA	( uiManager     := ud_VaranManagerNr
                                          , uiAddress     := ud_address + ( ud_cnt * 128 )
                                          , uiLen         := 128
                                        , uiRetryTimeout:= VaranIn.GetRetryTimeout( ud_bytes := 128 ) //s_DAData.ud_RetryTimeout
                                          , pvData        := p_data + ( ud_cnt * 128 )
                                          , puiError      := NIL
                                        );

			//look for error
			if ( sd_retval <> VARANMANAGER_OK ) then
				State := _DirectAccessFailed;
				VaranIn.SetState( State );
				return;
			end_if;
      end_if;
			
			ud_length -= 128;
			ud_cnt += 1;
      

		else
      if b_PayloadSupport then
        //write with direct access
        sd_retval := MULTI_VARAN_iExecuteDirectAccess(hNodeHandle := ud_HandleModule
                                                , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                    , udOffset    := (ud_address + ( ud_cnt * 128 )) and 16#FFFF // Remove DeviceAddress so that offset remains                                                
                                                , udLength    := ud_length
                                                    , pusData     := ( p_data + ( ud_cnt * 128 ))$^USINT
                                                , pudErrorInfo:= NIL);  
                                                
        //look for error
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _DirectAccessFailed;
          VaranIn.SetState( State );
          return;
        end_if;
      else

			//write rest with direct access
        sd_retval := VARAN_iWriteMemoryDA(uiManager     := ud_VaranManagerNr
                                        , uiAddress     := ( ud_address + ( ud_cnt * 128 ))
                                        , uiLen         := ( ud_length )
                                        , uiRetryTimeout:= VaranIn.GetRetryTimeout( ud_bytes := ud_length ) //s_DAData.ud_RetryTimeout - doesn`t work with CIV 513 => -27
                                        , pvData        := p_data + ( ud_cnt * 128 )
                                        , puiError      := NIL
                                        );

			//look for error
			if ( sd_retval <> VARANMANAGER_OK ) then
				State := _DirectAccessFailed;
				VaranIn.SetState( State );
				return;
			end_if;
		  end_if;
			ud_length := 0;
		end_if;
	end_while;

	//everything OK
	sd_retval := 0;

END_FUNCTION // Varan_DataMover::WriteCode
//[#ENGLISH]
//=================================================================================================
//Function to get actual pointer to code address
//=================================================================================================
//[>ud_type] Bit31: get pointer to ISO code in heap, Bit30: get code start address (available after connect), else actual ISO Byte count 
FUNCTION GLOBAL Varan_DataMover::GetActualAddressPointerISO
  VAR_INPUT
    ud_type		: UDINT;
  END_VAR
  VAR_OUTPUT
    ud_add_off		: UDINT;
  END_VAR

	//if type is set we return mover code pointer in heap
	if ( ud_type and 16#8000_0000 ) then
		ud_add_off := p_ISOMoverCode$UDINT;
	
	//or get code start address (valid after Connect function)
	elsif ( ud_type and 16#4000_0000 ) then
		ud_add_off := CodeStartAddress + s_ListSettings.ui_SyncListStart;
		
	//otherwise we return actual offset in Code DPRAM	
	else
		ud_add_off := ui_ISOByteCount;
	end_if;

END_FUNCTION //GLOBAL Varan_DataMover::GetActualAddressPointerISO
//[#ENGLISH]
//=================================================================================================
//Function to get actual pointer to code address
//=================================================================================================
FUNCTION GLOBAL Varan_DataMover::GetActualAddressPointerASY
  VAR_INPUT
    ud_type		: UDINT;
  END_VAR
  VAR_OUTPUT
    ud_add_off		: UDINT;
  END_VAR

	//if type is set we return mover code pointer in heap
	if ( ud_type and 16#8000_0000 ) then
		ud_add_off := p_ASYMoverCode$UDINT;

	//or get code start address (valid after Connect function)
	elsif ( ud_type and 16#4000_0000 ) then
		ud_add_off := CodeStartAddress + s_ListSettings.ui_AsyncListStart;

	//otherwise we return actual offset in Code DPRAM	
	else
		ud_add_off := ui_ASYByteCount;
	end_if;

END_FUNCTION //GLOBAL Varan_DataMover::GetActualAddressPointerASY
//[#ENGLISH]
//=================================================================================================
//Function to install special write DO (for CRIF)
//=================================================================================================
//[>ud_dol_type] pointer to variable to set right handle
//[>p_ud_handle]pointer to variable to set right handle
//[>ud_address] Address of data object
//[>ud_length] Length of data object
//[>p_ud_data] pointer to variable to get pointer to data
//[>ud_type]0=control area, 1=memory area
//[<sd_retval] 0=OK, negative=error (look lsl_st_varan.h)
FUNCTION GLOBAL Varan_DataMover::AddVaranWrDO
  VAR_INPUT
    ud_dol_type		: UDINT;
    p_ud_handle		: ^UDINT;
    ud_address		: UDINT;
    ud_length		: UDINT;
    p_ud_data		: ^UDINT;
    ud_type			: UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval		: DINT;
  END_VAR

	//check number
	if ( us_SpecialDOCnt > 10 ) then
		sd_retval := -100;
		return;
	end_if;

	//create special DO	
  if b_PayloadSupport then
  
    sd_retval := VaranIn.AddWrPayloadDO(ud_dol_type     := ud_dol_type
                                      , p_ud_handle     := p_ud_handle
                                      , ud_offset_write := ud_address and 16#FFFF // Mask out die DeviceAddress 
                                      , ud_length_write := ud_length
                                      , p_ud_data_write := p_ud_data
                                      , ud_type         := VM_MEMORY_ACCESS
                                      );

    
    //look if an error occurs
    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _CreateDOFailed;
      VaranIn.SetState( State );
      return;
    end_if;	

  else
    sd_retval := VaranIn.VaranIn.AddWrDO( p_us_position_info:= p_NodeString
                                      , ud_dol_type			:= ud_dol_type
                                      , p_ud_handle			:= p_ud_handle
                                      , ud_address			:= ud_address
                                      , ud_length				:= ud_length
                                      , p_ud_data				:= p_ud_data
                                      , ud_type				:= VM_MEMORY_ACCESS
                                      );

	//look for an error
	if ( sd_retval <> VARANMANAGER_OK ) then
		State := _CreateDOFailed;
		VaranIn.SetState( State );
		return;
	end_if;
  end_if;
  
	//save pointer in array
	a_SpecialDO[ us_SpecialDOCnt ].p_Handle$^UDINT := ( p_ud_handle^ )$^UDINT;
  
  if b_PayloadSupport = FALSE then
	a_SpecialDO[ us_SpecialDOCnt ].p_Settings$^UDINT := ( p_ud_data^ )$^UDINT - VM_DO_OFFSET_WR;
  end_if;
	a_SpecialDO[ us_SpecialDOCnt ].p_DataWrite := ( p_ud_data^ )$^USINT;
	a_SpecialDO[ us_SpecialDOCnt ].us_Length := ud_length$USINT;
	
	us_SpecialDOCnt += 1;

END_FUNCTION //GLOBAL Varan_DataMover::AddVaranWrDO
(*
#if 0

//[#ENGLISH]
//[>ud_address]address for reading
//[>ud_length]max. 128 Byte access
//[>p_data]address  of pointer (pointer value is set)
FUNCTION GLOBAL Varan_DataMover::DirectAccessRead
VAR_INPUT
	ud_address		: UDINT;
	ud_length		: UDINT;
	p_data			: ^void;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR
VAR
	s_state			: t_DataMoverConfig;
	ud_timemark		: UDINT;
END_VAR

	if ( State = _ClassOk & s_DAData.b_Init = TRUE ) then

		//check length
		if ( ud_length > 128 | p_data = NIL ) then
			sd_retval := -101;
			return;
		end_if;

		LOCK_DA;
		
		//set command settings
		s_DAData.s_DAMove.ui_Length		:= ud_length$UINT;
		s_DAData.s_DAMove.ud_SourceAdd	:= ud_address;
		s_DAData.s_DAMove.ud_DestAdd	:= s_DAData.ud_DataAddressSub;		//max. 128 byte (1 varan data object)
		
		//write config data (because we need direct accesses in init)
		sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
											, uiAddress		:= s_DAData.ud_CodeAddress
											, uiLen			:= sizeof( t_StructMove )
											, uiRetryTimeout:= s_DAData.ud_RetryTimeout
											, pvData		:= #s_DAData.s_DAMove
											, puiError		:= NIL
											);
		
		if ( sd_retval <> VARANMANAGER_OK ) then
			State := _DirectAccessFailed;
			VaranIn.SetState( State );
			UNLOCK_DA;
			return;
		end_if;

		//start list (write config data)
		s_Config.us_ControlReg.AdminEnable := TRUE;

		sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
											, uiAddress		:= s_DAData.ud_StartAddress
											, uiLen			:= 1
											, uiRetryTimeout:= s_DAData.ud_RetryTimeout
											, pvData		:= #s_Config
											, puiError		:= NIL
											);

		if ( sd_retval <> VARANMANAGER_OK ) then
			State := _DirectAccessFailed;
			VaranIn.SetState( State );
			UNLOCK_DA;
			return;
		end_if;

		//poll if list is ready or timeout
		s_state.us_StateReg := 2#100;
		ud_timemark := Varanin.VaranIn.GetNsTime();
		while ( ( s_state.us_StateReg and 2#100 ) & ( VaranIn.VaranIn.GetNsTime() - ud_timemark ) < 50000 ) do

			sd_retval := VARAN_iReadMemoryDA	( uiManager		:= ud_VaranManagerNr
												, uiAddress		:= s_DAData.ud_StartAddress
												, uiLen			:= 4
												, uiRetryTimeout:= s_DAData.ud_RetryTimeout
												, pvData		:= #s_state
												, puiError		:= NIL
												);

			if ( sd_retval <> VARANMANAGER_OK ) then
				State := _DirectAccessFailed;
				VaranIn.SetState( State );
				UNLOCK_DA;
				return;
			end_if;
		end_while;

		//check timeout
		if ( s_state.us_StateReg and 2#100 ) then
			sd_retval := -102;
			Timeout += 1;
			UNLOCK_DA;
			return;
		end_if;

		if ( s_state.us_ErrorReg <> 0 ) then
			sd_retval := -102;
			State := _DirectAccessFailed;
			VaranIn.SetState( State );
			UNLOCK_DA;
			return;
		end_if;

		//read data
		sd_retval := VARAN_iReadMemoryDA	( uiManager		:= ud_VaranManagerNr
											, uiAddress		:= s_DAData.ud_DataAddress
											, uiLen			:= ud_length
											, uiRetryTimeout:= s_DAData.ud_RetryTimeout
											, pvData		:= p_data
											, puiError		:= NIL
											);

		if ( sd_retval <> VARANMANAGER_OK ) then
			State := _DirectAccessFailed;
			VaranIn.SetState( State );
			UNLOCK_DA;
			return;
		end_if;

		UNLOCK_DA;

	else
		sd_retval := -100;
	end_if;

END_FUNCTION //GLOBAL Varan_DataMover::DirectAccessRead

//[#ENGLISH]
//[>ud_address]address of write access
//[>ud_length]max. 128 Byte access
//[>p_data]address of pointer (pointer value is set)
FUNCTION GLOBAL Varan_DataMover::DirectAccessWrite
VAR_INPUT
	ud_address		: UDINT;
	ud_length		: UDINT;
	p_data			: ^void;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR
VAR
	s_state			: t_DataMoverConfig;
	ud_timemark		: UDINT;
END_VAR

	if ( State = _ClassOk & s_DAData.b_Init = TRUE ) then

		//check length
		if ( ud_length > 128 | p_data = NIL ) then
			sd_retval := -101;
			return;
		end_if;

		LOCK_DA;		

		//set command settings
		s_DAData.s_DAMove.ui_Length		:= ud_length$UINT;
		s_DAData.s_DAMove.ud_SourceAdd	:= s_DAData.ud_DataAddressSub;		//max. 128 byte (1 varan data object)
		s_DAData.s_DAMove.ud_DestAdd	:= ud_address;
		
		//write config data (because we need direct accesses in init)
		sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
											, uiAddress		:= s_DAData.ud_CodeAddress
											, uiLen			:= sizeof( t_StructMove )
											, uiRetryTimeout:= s_DAData.ud_RetryTimeout
											, pvData		:= #s_DAData.s_DAMove
											, puiError		:= NIL
											);
		
		if ( sd_retval <> VARANMANAGER_OK ) then
			State := _DirectAccessFailed;
			VaranIn.SetState( State );
      
			UNLOCK_DA;
			return;
		end_if;

		//write data
		sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
											, uiAddress		:= s_DAData.ud_DataAddress
											, uiLen			:= ud_length
											, uiRetryTimeout:= s_DAData.ud_RetryTimeout
											, pvData		:= p_data
											, puiError		:= NIL
											);

		if ( sd_retval <> VARANMANAGER_OK ) then
			State := _DirectAccessFailed;
			VaranIn.SetState( State );
			UNLOCK_DA;
			return;
		end_if;

		//start list (write config data)
		s_Config.us_ControlReg.AdminEnable := TRUE;

		sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
											, uiAddress		:= s_DAData.ud_StartAddress
											, uiLen			:= 1
											, uiRetryTimeout:= s_DAData.ud_RetryTimeout
											, pvData		:= #s_Config
											, puiError		:= NIL
											);

		if ( sd_retval <> VARANMANAGER_OK ) then
			State := _DirectAccessFailed;
			VaranIn.SetState( State );
			UNLOCK_DA;
			return;
		end_if;

		//poll if list is ready or timeout
		s_state.us_StateReg := 2#100;
		ud_timemark := Varanin.VaranIn.GetNsTime();
		while ( ( s_state.us_StateReg and 2#100 ) & ( VaranIn.VaranIn.GetNsTime() - ud_timemark ) < 1000000 ) do

			sd_retval := VARAN_iReadMemoryDA	( uiManager		:= ud_VaranManagerNr
												, uiAddress		:= s_DAData.ud_StartAddress
												, uiLen			:= 4
												, uiRetryTimeout:= s_DAData.ud_RetryTimeout
												, pvData		:= #s_state
												, puiError		:= NIL
												);

			if ( sd_retval <> VARANMANAGER_OK ) then
				State := _DirectAccessFailed;
				VaranIn.SetState( State );
				UNLOCK_DA;
				return;
			end_if;
		end_while;

		//check timeout
		if ( s_state.us_StateReg and 2#100 ) then
			sd_retval := -102;
			Timeout += 1;
			UNLOCK_DA;
			return;
		end_if;

		if ( s_state.us_ErrorReg <> 0 ) then
			sd_retval := -102;
			State := _DirectAccessFailed;
			VaranIn.SetState( State );
			UNLOCK_DA;
			return;
		end_if;

		UNLOCK_DA;

	else
		sd_retval := -100;
	end_if;

END_FUNCTION //GLOBAL Varan_DataMover::DirectAccessWrite

	//----------------------------------------------------------------------------------------------
	//Config mover
  s_Config.us_ControlReg                  := 0;
  s_Config.us_ControlReg.MoverEnable 			:= TRUE;
	s_Config.us_ControlReg.HoldOPError			:= TRUE;
	s_Config.us_ControlReg.HoldWBError			:= TRUE;
	s_Config.us_ControlReg.HoldTimeSliceError	:= TRUE;

	s_Config.ud_SyncTimeReg := VaranIn.GetVaranTime() / 2000;		//in µs

	//write config data (because we need direct accesses in init)
	sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
										, uiAddress		:= ud_DeviceAddress+ CodeStartAddress
										, uiLen			:= sizeof( t_DataMoverConfig )
										, uiRetryTimeout:= VaranIn.GetRetryTimeout( ud_bytes := sizeof( t_DataMoverConfig ) )
										, pvData		:= #s_Config
										, puiError		:= NIL
										);

	if ( sd_retval <> VARANMANAGER_OK ) then
		State := _DirectAccessFailed;
		VaranIn.SetState( State );
		return;
	end_if;

	//----------------------------------------------------------------------------------------------
	//last 16 bytes are for direct access list
	s_ListSettings.ui_DAListStart 	:= TO_UINT( VM_DATAMOVER_HEADER + CodeSize - ( sizeof( t_StructMove ) + sizeof( t_StructEnd ) ) );
	s_ListSettings.ui_DAListEnd		:= TO_UINT( VM_DATAMOVER_HEADER + CodeSize - sizeof( t_StructEnd ) );
	s_ListSettings.ui_SyncListStart	:= 0;
	s_ListSettings.ui_SyncListEnd	:= 0;
	s_ListSettings.ui_AsyncListStart:= 0;
	s_ListSettings.ui_AsyncListEnd	:= 0;

	//write list config data (because we need direct accesses in init)
	sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
										, uiAddress		:= ud_DeviceAddress + CodeStartAddress + VM_LIST_CONFIG_OFFSET
										, uiLen			:= sizeof( t_ListConfig )
										, uiRetryTimeout:= VaranIn.GetRetryTimeout( ud_bytes := sizeof( t_ListConfig ) )
										, pvData		:= #s_ListSettings
										, puiError		:= NIL
										);

	if ( sd_retval <> VARANMANAGER_OK ) then
		State := _DirectAccessFailed;
		VaranIn.SetState( State );
		return;
	end_if;

	//----------------------------------------------------------------------------------------------
	//settings for direct accesses
	s_DAData.ud_CodeAddress			:= ud_DeviceAddress + CodeStartAddress + s_ListSettings.ui_DAListStart;
	s_DAData.ud_DataAddress			:= ud_DeviceAddress + DPRAM_StartAddress + DPRAM_Size - 128;
	s_DAData.ud_RetryTimeout		:= VaranIn.GetRetryTimeout( ud_bytes := 128 );
	s_DAData.ud_DataAddressSub		:= DPRAM_StartAddress_SUBBus + DPRAM_Size - 128;
	s_DAData.ud_StartAddress		:= ud_DeviceAddress + CodeStartAddress + t_DataMoverConfig.us_ControlReg;
	s_DAData.s_DAMove.us_Command	:= VM_DATAMOVER_MOVE_OP;

	//write end command to da list
	ui_EndAddressOff := TO_UINT( s_ListSettings.ui_DAListStart + sizeof( t_StructMove ) );
	
	sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
										, uiAddress		:= s_DAData.ud_CodeAddress + sizeof( t_StructMove )
										, uiLen			:= sizeof( t_StructEnd )
										, uiRetryTimeout:= VaranIn.GetRetryTimeout( ud_bytes := sizeof( t_StructEnd ) )
										, pvData		:= #s_End
										, puiError		:= NIL
										);

	//look for error
	if ( sd_retval <> VARANMANAGER_OK ) then
		State := _DirectAccessFailed;
		VaranIn.SetState( State );
		return;
	end_if;

	s_DAData.b_Init := TRUE;

#endif

*)


FUNCTION GLOBAL Varan_DataMover::SafetyMoverDisable

  // tell the OS that we configured the Mover
  if ( ( pHardwareTree <> NIL ) & ( pHardwareTree^.udVersion >= 16#1002 ) ) then
    //LanSte 20.11.2013 17:19 This call will cause in Access Exception if the info block of the Module is incorrectly configured
    //LanSte 20.11.2013 17:20 Check if FPGA Info Block exists and contains an entry for DevType = 0E60
    HWT_iDataMoverDisable(ud_VaranManagerNr, VaranIn.GetPointer2ObjectPath());
  end_if;

END_FUNCTION


FUNCTION GLOBAL Varan_DataMover::SafetyMoverEnable
	VAR_INPUT
		MoverActive 	: DINT;
	END_VAR

  if ( ( pHardwareTree <> NIL ) & ( pHardwareTree^.udVersion >= 16#1002 ) ) then
    //LanSte 20.11.2013 17:19 This call will cause in Access Exception if the info block of the Module is incorrectly configured
    //LanSte 20.11.2013 17:20 Check if FPGA Info Block exists and contains an entry for DevType = 0E60
    HWT_iDataMoverEnable(ud_VaranManagerNr, VaranIn.GetPointer2ObjectPath(), (#s_Config.us_ControlReg)$^USINT, (#us_ControlRd)$^USINT, MoverActive$UDINT, #ud_AdminCnt);
  end_if;

END_FUNCTION


FUNCTION GLOBAL Varan_DataMover::SafetyMoverConfigured

  // check how many DPRAM is reserved by HW-Classes => OS uses the rest (if it's enough)
  
  // we start with the last entry in the DPRAM and work backwards (if there is no entry for it)
  if s_Set_ASY_WR.us_DOCount then
    // we have asynchronous write DOs => <reserved memory> = <offset of asy wr DOs inside DPRAM> + <number of DOs - 1> * <size of each DO> + <size of last DO>
    ud_MoverDPRAM_Used := (s_Set_ASY_WR.ui_DPRAMOffset - DPRAM_StartAddress) + (s_Set_ASY_WR.us_DOCount-1) * 128 + a_DO_ASY_WR[s_Set_ASY_WR.us_DOCount-1].us_Length;
  elsif s_Set_ASY_RD.us_DOCount then
    // we have asynchronous read DOs => <reserved memory> = <offset of asy rd DOs inside DPRAM> + <number of DOs - 1> * <size of each DO> + <size of last DO>
    ud_MoverDPRAM_Used := (s_Set_ASY_RD.ui_DPRAMOffset - DPRAM_StartAddress) + (s_Set_ASY_RD.us_DOCount-1) * 128 + a_DO_ASY_RD[s_Set_ASY_RD.us_DOCount-1].us_Length;
  elsif s_Set_ISO_WR.us_DOCount then
    // we have asynchronous write DOs => <reserved memory> = <offset of asy wr DOs inside DPRAM> + <number of DOs - 1> * <size of each DO> + <size of last DO>
    ud_MoverDPRAM_Used := (s_Set_ISO_WR.ui_DPRAMOffset - DPRAM_StartAddress) + (s_Set_ISO_WR.us_DOCount-1) * 128 + a_DO_ISO_WR[s_Set_ISO_WR.us_DOCount-1].us_Length;
  elsif s_Set_ISO_RD.us_DOCount then
    // we have asynchronous write DOs => <reserved memory> = <offset of asy wr DOs inside DPRAM> + <number of DOs - 1> * <size of each DO> + <size of last DO>
    ud_MoverDPRAM_Used := (s_Set_ISO_RD.ui_DPRAMOffset - DPRAM_StartAddress) + (s_Set_ISO_RD.us_DOCount-1) * 128 + a_DO_ISO_RD[s_Set_ISO_RD.us_DOCount-1].us_Length;
  else
    ud_MoverDPRAM_Used := 0;
  end_if;

  // tell the OS that we configure the DAs in a second
  if ( ( pHardwareTree <> NIL ) & ( pHardwareTree^.udVersion >= 16#1002 ) ) then
    HWT_iDataMoverConfigured(ud_VaranManagerNr, VaranIn.GetPointer2ObjectPath(), ud_MoverDPRAM_Used);
  end_if;

END_FUNCTION

//#WP003 start
FUNCTION GLOBAL Varan_DataMover::CreateDOs
  VAR
    i           : USINT;
    sd_retval		: DINT;  
  END_VAR

  //set back length of code (2nd callback get this infos again)
  ui_ASYByteCount := 0;			
  ui_ISOByteCount := 0;			
  s_DAData.b_Init := FALSE;
  
  //look if we have to create ISO Rd DO(s)
  if ( s_Set_ISO_RD.us_DOCount ) then
		for i := 0 to (s_Set_ISO_RD.us_DOCount - 1) do
      if b_PayloadSupport then
        sd_retval := VaranIn.AddRdPayloadDO(ud_dol_type   := VARAN_DOL_ISO
                                    , p_ud_handle   := ( #a_DO_ISO_RD[i].p_Handle)$^UDINT
                                    , ud_offset_read      := s_Set_ISO_RD.ui_DPRAMOffset + ( i * 128 )                                
                                    , ud_length_read      := a_DO_ISO_RD[i].us_Length
                                    , p_ud_data_read      := ( #a_DO_ISO_RD[i].p_DataRead)$^UDINT
                                    , ud_type             := VM_MEMORY_ACCESS
                                    , ud_priority         := a_DO_ISO_RD[i].ud_Priority
                                    , ud_WritePayloadType := 1);
      
        
        //look for an error
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _CreateDOFailed;
          VaranIn.SetState( State );
          return;
        end_if;  
      else
      //create DO
        sd_retval := VaranIn.VaranIn.AddRdDO( p_us_position_info  := p_NodeString
                                            , ud_dol_type         := VARAN_DOL_ISO
                                            , p_ud_handle         := ( #a_DO_ISO_RD[i].p_Handle )$^UDINT
                                            , ud_address          := s_Set_ISO_RD.ui_DPRAMOffset + ( i * 128 )
                                            , ud_length           := a_DO_ISO_RD[i].us_Length
                                            , p_ud_data           := ( #a_DO_ISO_RD[i].p_DataRead )$^UDINT
                                            , ud_type             := VM_MEMORY_ACCESS OR a_DO_ISO_RD[i].ud_Priority
                                          );

      //look for an error
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _CreateDOFailed;
        VaranIn.SetState( State );
        return;
      end_if;  
      
      //set settings pointer
      a_DO_ISO_RD[i].p_Settings$^USINT := a_DO_ISO_RD[i].p_DataRead - VM_DO_OFFSET_RD;
      end_if;
      
      //reset length of DO
      a_DO_ISO_RD[i].us_Length := 0;
    
      // Save Handle to external variable
      if a_DO_ISO_RD[i].p_UserDOHandle then
        a_DO_ISO_RD[i].p_UserDOHandle^ := a_DO_ISO_RD[i].p_Handle$UDINT;
      end_if;
    
    end_for;
  end_if;  

  //look if we have to create ISO Wr DO(s)    
  if ( s_Set_ISO_Wr.us_DOCount ) then
		for i := 0 to (s_Set_ISO_Wr.us_DOCount - 1) do
      
      //create DO
      if b_PayloadSupport then
        sd_retval := VaranIn.AddWrPayloadDO(ud_dol_type   := VARAN_DOL_ISO
                                    , p_ud_handle   := ( #a_DO_ISO_WR[i].p_Handle)$^UDINT
                                    , ud_offset_write     := s_Set_ISO_WR.ui_DPRAMOffset + ( i * 128 )                                
                                    , ud_length_write     := a_DO_ISO_WR[i].us_Length
                                    , p_ud_data_write     := ( #a_DO_ISO_WR[i].p_DataWrite)$^UDINT
                                    , ud_type             := VM_MEMORY_ACCESS
                                    , ud_priority         := a_DO_ISO_WR[i].ud_Priority
                                    , ud_WritePayloadType := 1);
        
        
        //look for an error
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _CreateDOFailed;
          VaranIn.SetState( State );
          return;
        end_if;  
      else
        sd_retval := VaranIn.VaranIn.AddWrDO( p_us_position_info  := p_NodeString
                                            , ud_dol_type         := VARAN_DOL_ISO
                                            , p_ud_handle         := ( #a_DO_ISO_WR[i].p_Handle )$^UDINT
                                            , ud_address          := s_Set_ISO_WR.ui_DPRAMOffset + ( i * 128 )
                                            , ud_length           := a_DO_ISO_WR[i].us_Length
                                            , p_ud_data           := ( #a_DO_ISO_WR[i].p_DataWrite )$^UDINT
                                            , ud_type             := VM_MEMORY_ACCESS OR a_DO_ISO_WR[i].ud_Priority
                                          );

      //look for an error
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _CreateDOFailed;
        VaranIn.SetState( State );
        return;
      end_if;      
      
      //set settings pointer
      a_DO_ISO_WR[i].p_Settings$^USINT := a_DO_ISO_WR[i].p_DataWrite - VM_DO_OFFSET_WR;
      end_if;
      
      //reset length of DO
      a_DO_ISO_WR[i].us_Length := 0;
    
      // Save Handle to external variable
      if a_DO_ISO_WR[i].p_UserDOHandle then
        a_DO_ISO_WR[i].p_UserDOHandle^ := a_DO_ISO_WR[i].p_Handle$UDINT;
      end_if;
    
    end_for;
  end_if;  
  
  //look if we have to create ASY Rd DO(s)
  if ( s_Set_ASY_RD.us_DOCount ) then
		for i := 0 to (s_Set_ASY_RD.us_DOCount - 1) do
      
      //create DO
      if b_PayloadSupport then
        sd_retval := VaranIn.AddRdPayloadDO(ud_dol_type   := VARAN_DOL_ASY
                                    , p_ud_handle   := ( #a_DO_ASY_RD[i].p_Handle)$^UDINT
                                    , ud_offset_read      := s_Set_ASY_RD.ui_DPRAMOffset + ( i * 128 )                                
                                    , ud_length_read      := a_DO_ASY_RD[i].us_Length
                                    , p_ud_data_read      := ( #a_DO_ASY_RD[i].p_DataRead)$^UDINT
                                    , ud_type             := VM_MEMORY_ACCESS
                                    , ud_priority         := a_DO_ASY_RD[i].ud_Priority
                                    , ud_WritePayloadType := 1);
        
        
        //look for an error
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _CreateDOFailed;
          VaranIn.SetState( State );
          return;
        end_if;  
      else
        sd_retval := VaranIn.VaranIn.AddRdDO( p_us_position_info  := p_NodeString
                                            , ud_dol_type         := VARAN_DOL_ASY
                                            , p_ud_handle         := ( #a_DO_ASY_RD[i].p_Handle )$^UDINT
                                            , ud_address          := s_Set_ASY_RD.ui_DPRAMOffset + ( i * 128 )
                                            , ud_length           := a_DO_ASY_RD[i].us_Length
                                            , p_ud_data           := ( #a_DO_ASY_RD[i].p_DataRead )$^UDINT
                                            , ud_type             := VM_MEMORY_ACCESS OR a_DO_ASY_RD[i].ud_Priority
                                          );

      //look for an error
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _CreateDOFailed;
        VaranIn.SetState( State );
        return;
      end_if;      
      
      //set settings pointer
      a_DO_ASY_RD[i].p_Settings$^USINT := a_DO_ASY_RD[i].p_DataRead - VM_DO_OFFSET_RD;
      end_if;
      
      //reset length of DO
      a_DO_ASY_RD[i].us_Length := 0;
    
      // Save Handle to external variable
      if a_DO_ASY_RD[i].p_UserDOHandle then
        a_DO_ASY_RD[i].p_UserDOHandle^ := a_DO_ASY_RD[i].p_Handle$UDINT;
      end_if;
    
    end_for;
  end_if;  
  
  //look if we have to create ASY Wr DO(s)
  if ( s_Set_ASY_WR.us_DOCount ) then
		for i := 0 to (s_Set_ASY_WR.us_DOCount - 1) do
      
      //create DO
      
      if b_PayloadSupport then
        sd_retval := VaranIn.AddWrPayloadDO(ud_dol_type   := VARAN_DOL_ASY
                                    , p_ud_handle   := ( #a_DO_ASY_WR[i].p_Handle)$^UDINT
                                    , ud_offset_write     := s_Set_ASY_WR.ui_DPRAMOffset + ( i * 128 )                                
                                    , ud_length_write     := a_DO_ASY_WR[i].us_Length
                                    , p_ud_data_write     := ( #a_DO_ASY_WR[i].p_DataWrite)$^UDINT
                                    , ud_type             := VM_MEMORY_ACCESS
                                    , ud_priority         := a_DO_ASY_WR[i].ud_Priority
                                    , ud_WritePayloadType := 1);
        
        
        //look for an error
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _CreateDOFailed;
          VaranIn.SetState( State );
          return;
        end_if;  
      else
        sd_retval := VaranIn.VaranIn.AddWrDO( p_us_position_info  := p_NodeString
                                            , ud_dol_type         := VARAN_DOL_ASY
                                            , p_ud_handle         := ( #a_DO_ASY_WR[i].p_Handle )$^UDINT
                                            , ud_address          := s_Set_ASY_WR.ui_DPRAMOffset + ( i * 128 )
                                            , ud_length           := a_DO_ASY_WR[i].us_Length
                                            , p_ud_data           := ( #a_DO_ASY_WR[i].p_DataWrite )$^UDINT
                                            , ud_type             := VM_MEMORY_ACCESS OR a_DO_ASY_WR[i].ud_Priority
                                          );

      //look for an error
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _CreateDOFailed;
        VaranIn.SetState( State );
        return;
      end_if;      
      
      //set settings pointer
      a_DO_ASY_WR[i].p_Settings$^USINT := a_DO_ASY_WR[i].p_DataWrite - VM_DO_OFFSET_WR;
      end_if;
      
      //reset length of DO
      a_DO_ASY_WR[i].us_Length := 0;
    
      // Save Handle to external variable
      if a_DO_ASY_WR[i].p_UserDOHandle then
        a_DO_ASY_WR[i].p_UserDOHandle^ := a_DO_ASY_WR[i].p_Handle$UDINT;
      end_if;
    
    end_for;
  end_if;  

  //mark as created well
  DO_Created := true;

END_FUNCTION
//#WP003 end

FUNCTION GLOBAL Varan_DataMover::AddMoveISO
VAR_INPUT
  SourceAddr 	: HDINT;
  DestAddr 	: HDINT;
  MoveLen 	: UDINT;
  pEnable 	: ^USINT;
  udPriority 	: UDINT;
END_VAR
VAR_OUTPUT
  sd_retval 	: DINT;
END_VAR
VAR
	p_Mov			    : ^t_StructMove;
	p_MovEn			  : ^t_StructMoveEn;
	ud_en_add		  : UDINT;
END_VAR

  if pEnable then
    //for enable byte
    sd_retval := GetMemoryISOWr	( p_add		:= #ud_en_add
                  , p_data	:= pEnable
                  , ud_len	:= 1
                  , ud_Priority := udPriority
                  );

    if ( sd_retval <> VARANMANAGER_OK ) then
      return;
    end_if;

    //give back address of enable byte
    ( ( ( pEnable$^UDINT )^ )$^USINT )^ := 0;
  
  end_if;

	//save opcodes in class
	if ( p_ISOMoverCode = NIL ) then
		//allocate memory
		p_ISOMoverCode$^void := To_StdLib.Malloc( s_Set_ISO_RD.ui_DPRAMSize + s_Set_ISO_WR.ui_DPRAMSize );

		if ( p_ISOMoverCode  = NIL ) then
			State := _MemoryFault;
			sd_retval := -103;
			VaranIn.SetState( State );
			return;
		end_if;
	end_if;

	//first check length
	if ( CheckLengthOfCode() = FALSE ) then
		sd_retval := -102;
		return;
	end_if;

  if pEnable then
    //check size of free memory
    if (( ui_ISOByteCount + sizeof( t_StructMoveEn )) > ( s_Set_ISO_RD.ui_DPRAMSize + s_Set_ISO_WR.ui_DPRAMSize )) then
      State := _MemoryFault;
      sd_retval := -102;
      VaranIn.SetState( State );
      return;
    end_if;

    //get right pointer
    p_MovEn := p_ISOMoverCode + ui_ISOByteCount;

    p_MovEn^.us_Command 		:= VM_DATAMOVER_MOVE_EN_OP;
    p_MovEn^.ui_Length		:= MoveLen$UINT;
    p_MovEn^.us_Length		:= ( MoveLen shr 16 )$USINT;
    p_MovEn^.ud_SourceAdd		:= SourceAddr;
    p_MovEn^.ud_DestAdd		:= DestAddr;
    p_MovEn^.ud_EnableAddByte	:= ud_en_add;
    
    ui_ISOByteCount += sizeof( t_StructMoveEn );
  else
    //check size of free memory
    if (( ui_ISOByteCount + sizeof( t_StructMove )) > ( s_Set_ISO_RD.ui_DPRAMSize + s_Set_ISO_WR.ui_DPRAMSize )) then
      State := _MemoryFault;
      sd_retval := -102;
      VaranIn.SetState( State );
      return;
    end_if;

    //get right pointer
    p_Mov := p_ISOMoverCode + ui_ISOByteCount;

    p_Mov^.us_Command 		:= VM_DATAMOVER_MOVE_OP;
    p_Mov^.ui_Length		:= MoveLen$UINT;
    p_Mov^.us_Length		:= ( MoveLen shr 16 )$USINT;
    p_Mov^.ud_SourceAdd		:= SourceAddr;
    p_Mov^.ud_DestAdd		:= DestAddr;
    
    ui_ISOByteCount += sizeof( t_StructMove );
  end_if;
  
	sd_retval := VARANMANAGER_OK;

END_FUNCTION


FUNCTION GLOBAL Varan_DataMover::AddMoveASY
	VAR_INPUT
		SourceAddr 	: HDINT;
		DestAddr 	: HDINT;
		MoveLen 	: UDINT;
		pEnable 	: ^USINT;
		udPriority 	: UDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
VAR
	p_Mov			    : ^t_StructMove;
	p_MovEn			  : ^t_StructMoveEn;
	ud_en_add		  : UDINT;
END_VAR

  if pEnable then
    //for enable byte
    sd_retval := GetMemoryASYWr	( p_add		:= #ud_en_add
                  , p_data	:= pEnable
                  , ud_len	:= 1
                  , ud_Priority := udPriority
                  );

    if ( sd_retval <> VARANMANAGER_OK ) then
      return;
    end_if;

    //give back address of enable byte
    ( ( ( pEnable$^UDINT )^ )$^USINT )^ := 0;
  
  end_if;

	//save opcodes in class
	if ( p_ASYMoverCode = NIL ) then
		//allocate memory
		p_ASYMoverCode$^void := To_StdLib.Malloc( s_Set_ASY_RD.ui_DPRAMSize + s_Set_ASY_WR.ui_DPRAMSize );

		if ( p_ASYMoverCode  = NIL ) then
			State := _MemoryFault;
			sd_retval := -103;
			VaranIn.SetState( State );
			return;
		end_if;
	end_if;

	//first check length
	if ( CheckLengthOfCode() = FALSE ) then
		sd_retval := -102;
		return;
	end_if;

  if pEnable then
    //check size of free memory
    if (( ui_ASYByteCount + sizeof( t_StructMoveEn )) > ( s_Set_ASY_RD.ui_DPRAMSize + s_Set_ASY_WR.ui_DPRAMSize )) then
      State := _MemoryFault;
      sd_retval := -102;
      VaranIn.SetState( State );
      return;
    end_if;

    //get right pointer
    p_MovEn := p_ASYMoverCode + ui_ASYByteCount;

    p_MovEn^.us_Command 		:= VM_DATAMOVER_MOVE_EN_OP;
    p_MovEn^.ui_Length		:= MoveLen$UINT;
    p_MovEn^.us_Length		:= ( MoveLen shr 16 )$USINT;
    p_MovEn^.ud_SourceAdd		:= SourceAddr;
    p_MovEn^.ud_DestAdd		:= DestAddr;
    p_MovEn^.ud_EnableAddByte	:= ud_en_add;
    
    ui_ASYByteCount += sizeof( t_StructMoveEn );
  else
    //check size of free memory
    if (( ui_ASYByteCount + sizeof( t_StructMove )) > ( s_Set_ASY_RD.ui_DPRAMSize + s_Set_ASY_WR.ui_DPRAMSize )) then
      State := _MemoryFault;
      sd_retval := -102;
      VaranIn.SetState( State );
      return;
    end_if;

    //get right pointer
    p_Mov := p_ASYMoverCode + ui_ASYByteCount;

    p_Mov^.us_Command 		:= VM_DATAMOVER_MOVE_OP;
    p_Mov^.ui_Length		:= MoveLen$UINT;
    p_Mov^.us_Length		:= ( MoveLen shr 16 )$USINT;
    p_Mov^.ud_SourceAdd		:= SourceAddr;
    p_Mov^.ud_DestAdd		:= DestAddr;
    
    ui_ASYByteCount += sizeof( t_StructMove );
  end_if;
  
	sd_retval := VARANMANAGER_OK;
  
END_FUNCTION