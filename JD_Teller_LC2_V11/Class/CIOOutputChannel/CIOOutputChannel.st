//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "CIOOutputChannel"
	Revision           = "2.20"
	GUID               = "{2F19C28F-846F-4EFB-8E33-4E720C881DC0}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="Data" WriteProtected="false">
		</Server>
		<Server Name="State" GUID="{B709A0A6-80E0-4BA8-A8AB-DBEE7CF7E9AB}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="CBias" Required="false" Internal="false"/>
		<Client Name="CInvert" Required="false" Internal="false"/>
		<Client Name="Connect" Required="true" Internal="false"/>
		<Client Name="CScale" Required="true" Internal="false"/>
		<Client Name="TypeOfChannel" Required="false" Internal="false" Comment="0=+/-10V, 1=0-20mA"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\DiasMaster\DIASMaster.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="renste"/>
		<Dokumentation Revision="2.20" Date="05.12.2013" Author="FucHer&#13;&#10;LanSte" Company="Sigmatek" Description="Changed AWL to Structured Text&#13;&#10;Added payload support"/>
		<Dokumentation Revision="2.12" Date="04.03.2010" Author="BleErn" Company="Sigmatek" Description="Added support for RtPostScan (new BaseClass)"/>
		<Dokumentation Revision="2.11" Date="29.01.2010" Author="wocpet" Company="Sigmatek" Description="Added method Get_Binary for direct access of CIO016"/>
	</RevDoku>
	<Network Name="CIOOutputChannel">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{82F58B48-D966-4E99-BBE4-AF53ED26432C}"
				Class      = "ChannelBaseDataWriteOnly"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Data" Destination="_base.Data" Vertices="(690,210),(518,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using ChannelBaseDataWriteOnly

CIOOutputChannel : CLASS
: ChannelBaseDataWriteOnly
  //Servers:
	State 	: SvrCh_IO_State;
  //Clients:
	Connect 	: CltChCmd_HwBaseCDIAS;
	CScale 	: CltCh_DINT;
	CBias 	: CltCh_DINT;
	CInvert 	: CltCh_DINT;
	TypeOfChannel 	: CltCh_DINT;
  //Variables:
		factory 	: EEData;
		udMaxBin 	: UDINT;
		udOffAct 	: UDINT;
		udMulAct 	: UDINT;
		udDivAct 	: UDINT;
		udBiasBin 	: UDINT;
		HandleWRValue 	: DINT;
		udBinaryData 	: UDINT;
		Firstscan 	: UINT;
		HandleCall 	: DINT;
		dBinary 	: DINT;
		dBinaryOld 	: DINT;
		UpDateType 	: UDINT;
		us_NotNeg 	: USINT;			//! <Variable Comment="//#SR00x" Name="us_NotNeg"/>
		b_VaranAvailable 	: BOOL;
		b_PayloadSupport 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL UpdateCy
		VAR_INPUT
			Handle 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan
		VAR_INPUT
			Handle 	: DINT;
		END_VAR;
	
	FUNCTION CalFactory;
	
	FUNCTION GLOBAL ReCallFactory;
	
	FUNCTION GLOBAL SetStateOff;
	
	FUNCTION GLOBAL Get_Binary
		VAR_OUTPUT
			Bin 	: DINT;
		END_VAR;
	
	FUNCTION AWL VIRTUAL GLOBAL UpdateCy_AWL
		VAR_INPUT
			Handle 	: DINT;
		END_VAR;
	
	FUNCTION AWL CalFactory_AWL;
	
	FUNCTION VIRTUAL GLOBAL Data::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd HwBaseCDIAS


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB CIOOutputChannel::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_CIOOUTPUTCHANNEL
2$UINT, 20$UINT, (SIZEOF(::CIOOutputChannel))$UINT, 
1$UINT, 5$UINT, 0$UINT, 
TO_UDINT(3867554050), "CIOOutputChannel", //Class
TO_UDINT(3340137983), "ChannelBaseDataWriteOnly", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::CIOOutputChannel.State.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1422331979), "State", 
//Clients:
(::CIOOutputChannel.Connect.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1267336965), "Connect", TO_UDINT(1800499398), "HwBaseCDIAS", 2$UINT, 50$UINT, 
(::CIOOutputChannel.CScale.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3846097224), "CScale", 
(::CIOOutputChannel.CBias.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2351402359), "CBias", 
(::CIOOutputChannel.CInvert.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1537718392), "CInvert", 
(::CIOOutputChannel.TypeOfChannel.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2310128295), "TypeOfChannel", 
END_FUNCTION


#define USER_CNT_CIOOutputChannel 4

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_CIOOutputChannel] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION CIOOutputChannel::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= ChannelBaseDataWriteOnly::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= ChannelBaseData::Data.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, ChannelBaseData::Data.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_CIOOutputChannel;
	vmt.CmdTable.Write		:= #Data::Write();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #UpdateCy_AWL();

#pragma warning (default : 74)
	ChannelBaseData::Data.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ChannelBaseData::Data.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma usingLtd DiasMaster

(******************************************************************************
*
*	Analog Output class for a CIO011 
*	Created: Sigmatek / BS / 22.07.2004
*	Changes: 
*		2.6 => 2.10	/	05.12.2007	/	Mark:	//#SR004
*			- [DB 713]: make compatible to CIV/DIV DataMover
*		2.5 => 2.6	/	14.05.2007	/	Mark:	//#SR003
*			- [DB 575]: set init values to prevent division error via varan if hardware not connected
*		1.3 => 2.5	/	08.03.2007	/	Mark:	//#SR002
*			- [DB 421]: now class is ready for plug & play over CIV
*		1.2 => 1.3	/	24.08.2006	/	Mark:	//#SR001
*			insert client "TypeOfChannel" to make compatibel to CIO014
*		1.1 => 1.2	/	13.09.2005	/	no Mark	/ SR
*			add time measurement for class (activate with define DM_Profiler)
*		0.1 => 1.1 / 23.12.2004 / no Mark / ws
*			compatibility with Lasal Class 2
*			removed visible flags from internal servers
*		0.0 => 0.1	/	08.11.2004	/	Mark:	//#SR000
*			recursive call of Rt -> Stack Overflow
*
******************************************************************************)

FUNCTION VIRTUAL GLOBAL CIOOutputChannel::Init
VAR
	  //LanSte 12.04.2013 13:35
  // For NewInst command 
  _Para 	            : CmdStruct;
  _Result 	          : Results;
END_VAR

	 if firstscan = 0 then
		CScale			:= CScale.read();
		CBias			:= CBias.read(); 
		CInvert			:= CInvert.read();
		UpDateType		:= connect.MasterConnect.GetMasterType();
		TypeOfChannel	:= TypeOfChannel.read();					//#SR001

		//#SR002 start
		b_VaranAvailable := connect.MasterConnect.IsVaranAvailable() <> 0;

		if ( b_VaranAvailable ) then

			//#SR003 start
			//default values to prevent division error
	  		factory.dOffEE := 2050;
	  	  	factory.dMulEE := 4000;
	  	  	factory.dDivEE := 4000;
			CalFactory();
			//#SR003 end

//#SR004			HandleWRValue := connect.AddOneChannel( thisp := this, RTCY := 0, channel := 8 );
//#SR004		  	HandleCall := connect.GetCallHandle( 8 );

			State.uiIO_Flags := 16#FFFF;
			UpDateType := 0;
			Firstscan := 1;
	 
      // LanSte 10.04.2013 17:23
      // Check if Payload is supported by the VM
      _Para.uiCmd := VM_CMD_IS_PAYLOAD_SUPPORTED;
      _Result.aData[0]$BOOL := 0;   // Set to 0 in case the NewInst Method is not Implemented
      Connect.MasterConnect.NewInst(#_Para, #_Result);
      b_PayloadSupport := _Result.aData[0]$BOOL;
	 
		else
		//#SR002 end

			//------------------------------------------------------------------------------------------		
			IF connect.MasterConnect.GetConnection() = 0 THEN
				UpDateType := 1;
			END_IF;
	
			//#SR001 start
			if ( TypeOfChannel = 1 ) then
				us_NotNeg := 1;
			end_if;
			//#SR001 end
		
			if connect.GetEEState() then
			   	udMaxBin := 4000; 
			  	// no data on the EEPROM channel or wrong
		  		factory.dOffEE := 2050;
		  	  	factory.dMulEE := 4000;
		  	  	factory.dDivEE := 4000;
				CalFactory();
			else
				firstscan:=1;
				udMaxBin := 4000; 
 
			  	factory.dOffEE := TO_DINT(connect.GetEEData(16#C8))$INT;
			  	factory.dMulEE := TO_DINT(connect.GetEEData(16#C8+2))$INT;
			  	factory.dDivEE := TO_DINT(connect.GetEEData(16#C8+4))$INT;
				CalFactory();

	// to calculate the factory we have to use 4000 and 16000 but later for min and max
	// we have to use the real hardware range
			    udMaxBin := 4095;  //  12 Bit realy

	    	  	// now we tell the controller that we want to be connected 
		      	// if we are in cyclic or realtime and we get back a handle on the data
			  	HandleWRValue:=connect.AddOneChannel(thisp:=this, RTCY:=0, channel:=8);
			  	HandleCall := connect.GetCallHandle(8);
				dBinaryOld :=16#80000000$DINT; // invalid
				dBinary := factory.dOffEE;
			 end_if;
		end_if;		//#SR002
	end_if;


END_FUNCTION //VIRTUAL GLOBAL CIOOutputChannel::Init

FUNCTION VIRTUAL GLOBAL CIOOutputChannel::UpdateCy
VAR_INPUT
	Handle		: DINT;
END_VAR

  if State.uiIO_Flags = 0 then
    if dBinary <> dBinaryOld then
      dBinaryOld := dBinary;
      
      // ** now store the data to the controller **
      (_IOSegment$^UINT+HandleWRValue)^ := dBinary$UINT;
      
      if b_VaranAvailable = FALSE then
        if UpDateType = 2 then    // if IM
          (_IOSegment$^USINT+HandleCall)^ := DmSingle;   // single call
        end_if;
      else
        // Cont Run with payload support
        if b_PayloadSupport = 0 then
          HandleCall$^LSL_VARANFRAME^.ucCtrlStat := VARAN_DO_SINGLE_RUN;
        end_if;
      end_if;
    end_if;
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIOOutputChannel::UpdateCy

FUNCTION AWL VIRTUAL GLOBAL CIOOutputChannel::UpdateCy_AWL
VAR_INPUT
	Handle		: DINT;
END_VAR
#ifdef _LSL_TARGETARCH_X86
	//#SR002 start
	cmp.w		State.uiIO_Flags,0
	jne			UpDateCyRet
	//#SR002 end

	l.eax		dBinary
	cmp.eax		dBinaryOld
	je			UpDateCyRet
	s.eax		dBinaryOld

// ** now store the data to the controller **
	l.edi		_iosegment
	l.ebx		HandleWRValue
	s.ax		(ebx+edi)

	//#SR002 start
	cmp.b		b_VaranAvailable,TRUE
	je			LABEL_VaranSingle
	//#SR002 end

	cmp.d		UpDateType,2 // if IM
	jne			UpDateCyRet

	l.ebx		HandleCall
	l.b			(ebx+edi),Dmsingle   // single call
	
	//#SR002 start
	jmp			UpDateCyRet
LABEL_VaranSingle

  // Cont Run with payload support
  l.eax   b_PayloadSupport
  cmp.eax 0
  jne     UpDateCyRet

	l.ebx		HandleCall
	add.ebx		LSL_VARANFRAME.ucCtrlStat
	l.b			( ebx ), VARAN_DO_SINGLE_RUN
	//#SR002 end	

UpDateCyRet

#endif
END_FUNCTION //VIRTUAL GLOBAL CIOOutputChannel::UpdateCy

FUNCTION VIRTUAL GLOBAL CIOOutputChannel::UpDateRTPostScan
	VAR_INPUT
		Handle 	: DINT;
	END_VAR

	UpdateCy(handle);					//#SR000

END_FUNCTION //VIRTUAL GLOBAL CIOOutputChannel::UpDateRTPostScan

FUNCTION VIRTUAL GLOBAL CIOOutputChannel::Data::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  result := input;
 
  if input <> Data then
    Data := input;

    // clr limit flags
    State.uiIO_Flags.PhysicHiLimit := 0;
    State.uiIO_Flags.PhysicLoLimit := 0;
    
    // chk for invert !
    if CInvert then
      input := -input;
    end_if;

    input := input * udMulAct$DINT / udDivAct$DINT + udOffAct$DINT;

    // limit to Da - limits !
    if input > udMaxBin$DINT then
      State.uiIO_Flags.PhysicHiLimit := 1;
    elsif input < 0 then
      State.uiIO_Flags.PhysicLoLimit := 1;
    end_if;

    if State.uiIO_Flags.PhysicAccessOff = 0 then
      // now write to the channel
      dBinary := input;
    end_if;
  end_if;
  
//#SR003	no_change				
END_FUNCTION //VIRTUAL GLOBAL CIOOutputChannel::Data::Write

FUNCTION CIOOutputChannel::CalFactory

// -- calculate binary offset

  udBiasBin$DINT := udMaxBin$DINT * CBias / 1000;

// -- calculate physical offset --

  udOffAct$DINT := udBiasBin$DINT * Factory.dMulEE / Factory.dDivEE + Factory.dOffEE;

// -- dDivAct --

  if us_NotNeg <> 1 then
    udDivAct$DINT := CScale SHL 1;   // *2 cause +/-	10 Volt
  else
    udDivAct$DINT := CScale;
  end_if;

// -- dMulAct --

  udMulAct$DINT := (udMaxBin - udBiasBin)$DINT * Factory.dMulEE / Factory.dDivEE;

END_FUNCTION 

FUNCTION AWL CIOOutputChannel::CalFactory_AWL
#ifdef _LSL_TARGETARCH_X86
// -- calculate binary offset

         L.EAX     udMaxBin
         IMUL.D    cBias
         L.EBX     1000
         IDIV      EBX
         S.EAX     udBiasBin

// -- calculate physical offset --

         IMUL.D    Factory.dMulEE
         IDIV.D    Factory.dDivEE
         ADD.EAX   Factory.dOffEE
         S.EAX     udOffAct

// -- dDivAct --

         L.EAX     cScale
		 
		 //#SR001 start
		 cmp.b		us_NotNeg,1
		 je			LABEL_NotNegative
		 //#SR001 end

		 shl.eax   1			// *2 cause +/-	10 Volt

LABEL_NotNegative				//#SR001
         S.EAX     udDivAct

// -- dMulAct --

         L.EAX     udMaxBin
         SUB.EAX   udBiasBin
         IMUL.D    Factory.dMulEE
         IDIV.D    Factory.dDivEE
         S.EAX     udMulAct

#endif
END_FUNCTION 
FUNCTION GLOBAL CIOOutputChannel::ReCallFactory		//#SR002

	if ( TypeOfChannel = 1 ) then
		us_NotNeg := 1;
	end_if;
		
	udMaxBin := 4000; 
 
  	factory.dOffEE := TO_DINT(connect.GetEEData(16#C8))$INT;
  	factory.dMulEE := TO_DINT(connect.GetEEData(16#C8+2))$INT;
  	factory.dDivEE := TO_DINT(connect.GetEEData(16#C8+4))$INT;
	CalFactory();

	// to calculate the factory we have to use 4000 and 16000 but later for min and max
	// we have to use the real hardware range
    udMaxBin := 4095;  //  12 Bit realy

	dBinaryOld :=16#80000000$DINT; // invalid
	dBinary := factory.dOffEE;

	State.uiIO_Flags := 0;

	Data.write( 0 );

	HandleWRValue := connect.AddOneChannel( thisp := this, RTCY := 0, channel := 8 );		//#SR004
  	HandleCall := connect.GetCallHandle( 8 );												//#SR004

	
END_FUNCTION //GLOBAL CIOOutputChannel::ReCallFactory

FUNCTION GLOBAL CIOOutputChannel::SetStateOff		//#SR002

	State.uiIO_Flags := 0;
	State.uiIO_Flags.WrongHW := 1;
	State.uiIO_Flags.PhysicAccessOff := 1;

END_FUNCTION //GLOBAL CIOOutputChannel::SetStateOff


FUNCTION GLOBAL CIOOutputChannel::Get_Binary
	VAR_OUTPUT
		Bin 	: DINT;
	END_VAR
  
  //check if there are new send data
  if dBinary <> dBinaryOld then
    Bin := dBinaryOld := dBinary;
  else  
    //bit 17 true to signal no new output data
    Bin := 16#10000;
  end_if;

END_FUNCTION
