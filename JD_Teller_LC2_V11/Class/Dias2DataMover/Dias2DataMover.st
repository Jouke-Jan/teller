//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Dias2DataMover"
	Revision           = "1.50"
	GUID               = "{71F0CFB8-4D13-46E4-B71F-48382DB84843}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(690,360)">
	<Channels>
		<Server
			Name           = "Control"
			Initialize     = "false"
			Visualized     = "true"
			WriteProtected = "true">
		</Server>
		<Server Name="DiasErrorPlace" GUID="{AEBD4330-B9E7-407D-8889-BDF06CEF3AA6}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server
			Name           = "DIASRetryCounter"
			Initialize     = "false"
			Visualized     = "false"
			WriteProtected = "true"
			Comment        = "Retrys on diasbus">
		</Server>
		<Server
			Name           = "Release"
			Initialize     = "false"
			Visualized     = "false"
			WriteProtected = "true"
			Comment        = "IPC: Hardware and software release(Bit 0-15 Softwareversion, Bit16-31 Hardwareversion); CIPC: only one value for hardware and software release(Bit0-7); Release=16#FFFFFFFF (Fehler Master nicht vorhanden)">
		</Server>
		<Client Name="DIAS_BusAddress" Required="true" Internal="false"/>
		<Client Name="DiasErrorOff" Required="false" Internal="false"/>
		<Client Name="To_DataMover" Required="true" Internal="false"/>
		<Client Name="VaranIn" Required="true" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="renste"/>
		<Dokumentation Revision="1.50" Date="12.02.2014" Author="PieSte" Company="Sigmatek" Description="Add read Client Dias_BusAddress and DiasErrorOff in Init to set value with connected server."/>
		<Dokumentation Revision="1.40" Date="06.12.2013" Author="LanSte" Company="Sigmatek" Description="Added NewInst Method to pass trough commands"/>
		<Dokumentation Revision="1.30" Date="18.07.2013" Author="ZoePat&#13;&#10;ZoePat" Company="Sigmatek" Description="Added function GetModuleInfo() to get the pointer of a hwclass by place.&#13;&#10;Added possibility to move data on CDIAS behind DataMover."/>
		<Dokumentation Revision="1.20" Date="07.03.2013" Author="RamAnd" Company="Sigmatek" Description="If connected DIAS modules are required but not available, the user now gets informed via UserAction client."/>
		<Dokumentation Revision="1.18" Date="03.05.2012" Author="HuiMan" Company="Sigmatek" Description="Method SetObjectCallback: Check for valid place number (&lt;=63)"/>
		<Dokumentation Revision="1.17" Date="19.01.2012" Author="ZoePat" Company="Sigmatek" Description="Corrected handling of RequiredError (In some cases it could have happened, that an error has been generated even if the module has been connected)"/>
		<Dokumentation Revision="1.16" Date="10.05.2011" Author="RamAnd" Company="Sigmatek" Description="Retrycounter of DIAS is now also available on plattforms with no intelligent master."/>
		<Dokumentation Revision="1.15" Date="04.01.2011" Author="BleErn" Company="Sigmatek" Description="Added Client Transparent that allows to disable a VARAN-HW-Class"/>
		<Dokumentation Revision="1.14" Date="02.12.2010" Author="BleErn" Company="Sigmatek" Description="Created derivation of method AddDiasIRQ to prevent an exception on CPUs without DIAS"/>
		<Dokumentation Revision="1.13" Date="17.11.2010" Author="WocPet" Company="Sigmatek" Description="Functionality for DIAS-modul retrycounter implemented"/>
		<Dokumentation Revision="1.12" Date="21.10.2010" Author="BleErn" Company="Sigmatek" Description="Removed client &quot;PreventMasterError&quot; which was a relict from development"/>
		<Dokumentation Revision="1.11" Date="15.10.2010" Author="RamAnd" Company="Sigmatek" Description="Added method AddMovDO for the move command in the VM."/>
		<Dokumentation Revision="1.10" Date="24.08.2010" Author="BleErn" Company="Sigmatek" Description="a misused global pointer let the system crash"/>
		<Dokumentation Revision="1.9" Date="25.06.2010" Author="WocPet" Company="Sigmatek" Description="changes in base class: new Server &quot;RetryCounter&quot; added"/>
		<Dokumentation Revision="1.8" Date="04.03.2010" Author="BleErn" Company="Sigmatek" Description="SetObjectCallback might have crashed"/>
		<Dokumentation Revision="1.7" Date="23.02.2010" Author="BleErn" Company="Sigmatek" Description="New Method UpdateRtPostScan"/>
		<Dokumentation Revision="1.6" Date="02.11.2009" Author="RamAnd" Company="Sigmatek" Description="Corrected an error, which caused that some modules on DIAS Bus weren&apos;t found correctly on startup."/>
		<Dokumentation Revision="1.5" Date="17.04.2009" Author="RamAnd" Company="Sigmatek" Description="Corrected former change to wait 50ms before starting the first access and deleted the second access."/>
		<Dokumentation Revision="1.4" Date="16.12.2008" Author="RamAnd" Company="Sigmatek" Description="Some DIAS modules could have been in reset (typically for 5ms every 130ms) on first access, therefore we do a second access 50ms after the first to ensure that we can access the module if it&apos;s available.&#13;&#10;Second access is only done if first access failed."/>
	</RevDoku>
	<Network Name="Dias2DataMover">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{40180EC4-AAE6-4CC8-AAEE-60596B091863}"
				Class      = "DiasMasterC"
				Position   = "(270,150)"
				Visualized = "true"
				RealTime   = "1 ms">
				<Channels>
					<Server Name="Chipstate"/>
					<Server Name="Control"/>
					<Server Name="CyTimeIM_us"/>
					<Server Name="DIASRetryCounter"/>
					<Server Name="HwControl"/>
					<Server Name="MasterON"/>
					<Server Name="Release"/>
					<Server Name="RiscState"/>
					<Server Name="Rt_Load"/>
					<Server Name="RtTimeIM_us"/>
					<Server Name="TimeAtRtPreEnd"/>
					<Client Name="RtDebug"/>
					<Client Name="To_HwControl"/>
					<Client Name="WaitSync"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Control" Destination="_base.Control" Vertices="(1004,210),(832,240),"/>
			<Connection Source="this.DIASRetryCounter" Destination="_base.DIASRetryCounter" Vertices="(1004,330),(832,540),"/>
			<Connection Source="this.Release" Destination="_base.Release" Vertices="(1004,270),(832,300),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using DiasMasterC

Dias2DataMover : CLASS
: DiasMasterC
	TYPE
	  t_DIASCallback : STRUCT
	    ud_CallBackFunction : UDINT;
	    ud_Thisp : UDINT;
	    ud_Flags : BDINT
	    [
	    ];
	    ud_Reserved : UDINT;
	  END_STRUCT;
#pragma pack(push, 1)
	  t_DiasMasterRegs : STRUCT
	    us_ErrorSourceReg : USINT;
	    us_Reserved1 : USINT;
	    ui_Reserved1 : UINT;
	    ud_Reserved1 : UDINT;
	    us_RetryCounter : USINT;
	    us_Reserved2 : USINT;
	    us_RetryReg : USINT;
	    us_ErrorReg : USINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	DiasErrorPlace 	: SvrCh_DINT;
  //Clients:
	VaranIn 	: CltChCmd_Varan_Base;
	To_DataMover 	: CltChCmd_Varan_DataMover;
	DIAS_BusAddress 	: CltCh_HDINT;
	DiasErrorOff 	: CltCh_DINT;
  //Variables:
		a_DiasCallbacks : ARRAY [0..127] OF t_DIASCallback;

		ui_DIASCounter 	: UINT;
		p_DiasRegs 	: ^t_DiasMasterRegs;
		s_DummyHeader 	: LSL_VARANFRAME;
		ui_old_ISOTime 	: UINT;
		ui_old_ASYTime 	: UINT;
		us_DIASAliveModule 	: USINT;
		b_ReadKennungAllowed 	: BOOL;
		dummy 	: pHwBaseCDIAS;
		SetAliveTime 	: UDINT;
		b_HWRtPostScan 	: BOOL;
		ModuleRetryCntEnable 	: BOOL;
		FirstUpdate 	: BOOL;
		s_ModuleInfo : ARRAY [0..63] OF t_s_ModulInfo;

  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;This Function is Called by PostScan from DiasMasterPostScan&#13;&#10;=================================================================================================&#13;&#10;" Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Rt Function&#13;&#10;=================================================================================================&#13;&#10;" Name="RtWork"/>
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION AWL VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;This Function returns Pll Time&#13;&#10;=================================================================================================&#13;&#10;" Name="GetPllTime"/>
	FUNCTION VIRTUAL GLOBAL GetPllTime
		VAR_OUTPUT
			PllTime 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function add a delay to list&#13;&#10;=================================================================================================&#13;&#10;" Name="AddWait"/>
	FUNCTION VIRTUAL GLOBAL AddWait
		VAR_INPUT
			RTCY 	: DINT;
			Time_uSec 	: DINT;			//! <Variable Comment="Time in uSec (valid from 0-255)" Name="AddWait.Time_uSec"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function is writing into controlarea of a diasmodul&#13;&#10;=================================================================================================&#13;&#10;[Globals]  _RTOSVersion  : OS version&#13;&#10;    _lsl_pos   : OS interface structure&#13;&#10;[Members]&#13;&#10;[Locals]&#13;&#10;" Name="WrCntr"/>
	FUNCTION VIRTUAL GLOBAL WrCntr
		VAR_INPUT
			adress 	: DINT;
			Data 	: USINT;
		END_VAR
		VAR_OUTPUT
			state 	: DINT;			//! <Variable Comment="  0..success" Name="WrCntr.state"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddWr8Bit
		VAR_INPUT
			adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			Data 	: USINT;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment=" ***************************************&#13;&#10;   put programm into the buffer&#13;&#10; ***************************************&#13;&#10;  this is a 16 bit read&#13;&#10;  the thispointer we need to call the update method&#13;&#10;&#13;&#10;" Name="AddWR16Bit"/>
	FUNCTION VIRTUAL GLOBAL AddWR16Bit
		VAR_INPUT
			adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			data 	: UINT;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add dias sync&#13;&#10;=================================================================================================&#13;&#10; *************************************************&#13;&#10;   RTB is fixed reserved for one MODUL&#13;&#10; *************************************************&#13;&#10;&#13;&#10;  if FirstRTB &lt;&gt; 0 then this modul is the first with RTB&#13;&#10;  and has to do perhaps something special&#13;&#10;  if FirstRTB = 0 then it already exists a modul with RTBSYNC&#13;&#10;&#13;&#10;" Name="AddRTBSync"/>
	FUNCTION VIRTUAL GLOBAL AddRTBSync
		VAR_INPUT
			Adress 	: HINT;
		END_VAR
		VAR_OUTPUT
			FirstRTB 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddRet
		VAR_INPUT
			RTCY 	: DINT;
		END_VAR;
				//! <Function Comment=" ***************************************&#13;&#10;   put programm into the buffer&#13;&#10; ***************************************&#13;&#10;  this is a 16 bit read&#13;&#10;  the thispointer we need to call the update method&#13;&#10;&#13;&#10;" Name="AddRd32Bit"/>
	FUNCTION VIRTUAL GLOBAL AddRd32Bit
		VAR_INPUT
			Adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment=" ***************************************&#13;&#10;   put programm into the buffer&#13;&#10; ***************************************&#13;&#10;  this is a 16 bit read&#13;&#10;  the thispointer we need to call the update method&#13;&#10;&#13;&#10;" Name="AddRd16Bit"/>
	FUNCTION VIRTUAL GLOBAL AddRd16Bit
		VAR_INPUT
			Adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to read ID of Dias module&#13;&#10;=================================================================================================&#13;&#10;" Name="GetKennung"/>
	FUNCTION VIRTUAL GLOBAL GetKennung
		VAR_INPUT
			Place 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Kennung 	: UDINT;
		END_VAR;
				//! <Function Comment=" ***************************************&#13;&#10;     add a call to the main Programm&#13;&#10; ***************************************&#13;&#10;&#13;&#10; RTCY = 0 cyclic programm&#13;&#10; RTCY = constant realtime  --&gt; realtime programm&#13;&#10;&#13;&#10; MODE Bit 0 = continue&#13;&#10;   Bit 1 = single&#13;&#10;  Bit 4 = block execution   !!!  (important for Analogcards 3 opcodes must be together)&#13;&#10;&#13;&#10;&#13;&#10;" Name="AddCall2Main"/>
	FUNCTION VIRTUAL GLOBAL AddCall2Main
		VAR_INPUT
			Mode 	: UINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function does a 16 Bit read access&#13;&#10;=================================================================================================&#13;&#10;[Globals]  _RTOSVersion   : OS version&#13;&#10;    _lsl_pos    : OS interface structure&#13;&#10;[Members]&#13;&#10;[Locals]  ui_data   :R/W :intermediate storeage of data&#13;&#10;    di_ret   :R/W :returnvalue of OS&#13;&#10;" Name="Rd16Bit"/>
	FUNCTION VIRTUAL GLOBAL Rd16Bit
		VAR_INPUT
			Adress 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Data 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function does a 8 Bit read access&#13;&#10;=================================================================================================&#13;&#10;[Globals]  _RTOSVersion   : OS version&#13;&#10;    _lsl_pos    : OS interface structure&#13;&#10;[Members]&#13;&#10;[Locals]  us_data   :R/W :intermediate storage of data&#13;&#10;    di_ret   :R/W :return value of OS function&#13;&#10;" Name="Rd8Bit"/>
	FUNCTION VIRTUAL GLOBAL Rd8Bit
		VAR_INPUT
			Adress 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Data 	: DINT;			//! <Variable Comment="  Data read" Name="Rd8Bit.Data"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function does a 8 Bit write access&#13;&#10;=================================================================================================&#13;&#10;[Globals]  _RTOSVersion  : OS version&#13;&#10;    _lsl_pos   : OS interface structure&#13;&#10;[Members]&#13;&#10;[Locals]&#13;&#10;" Name="Wr8Bit"/>
	FUNCTION VIRTUAL GLOBAL Wr8Bit
		VAR_INPUT
			Adress 	: UDINT;			//! <Variable Comment="  High Byte Modulnumber, Low Byte offset in Controlarea" Name="Wr8Bit.Adress"/>
			Data 	: USINT;			//! <Variable Comment="  Data to write" Name="Wr8Bit.Data"/>
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function does a 16 Bit write access&#13;&#10;=================================================================================================&#13;&#10;[Globals]  _RTOSVersion  : OS version&#13;&#10;    _lsl_pos   : OS interface structure&#13;&#10;[Members]&#13;&#10;[Locals]&#13;&#10;" Name="Wr16Bit"/>
	FUNCTION VIRTUAL GLOBAL Wr16Bit
		VAR_INPUT
			Adress 	: UDINT;
			Data 	: UINT;
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
				//! <Function Comment=" ***************************************&#13;&#10;   put programm into the buffer&#13;&#10; ***************************************&#13;&#10;  this is a 8 bit read&#13;&#10;  the thispointer we need to call the update method&#13;&#10;&#13;&#10;" Name="AddRd8Bit"/>
	FUNCTION VIRTUAL GLOBAL AddRd8Bit
		VAR_INPUT
			Adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetMasterType
		VAR_OUTPUT
			MasterType 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddDiasIRQ
		VAR_INPUT
			Place 	: USINT;
			ActionPtr 	: pVoid;
			thisptr 	: pVoid;
		END_VAR
		VAR_OUTPUT
			ok 	: USINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function call function of VaranMaster to add a read data object to varan master and install a varan task&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRdDO"/>
	FUNCTION VIRTUAL GLOBAL AddRdDO
		VAR_INPUT
			ud_dol_type 	: UDINT;			//! <Variable Comment=" type of DOL list( Realtime = 3, cyclic = 4 )" Name="AddRdDO.ud_dol_type"/>
			p_ud_handle 	: ^UDINT;			//! <Variable Comment=" pointer to variable to set right handle" Name="AddRdDO.p_ud_handle"/>
			ud_address 	: UDINT;			//! <Variable Comment="address of do" Name="AddRdDO.ud_address"/>
			ud_length 	: UDINT;			//! <Variable Comment="length of data should read" Name="AddRdDO.ud_length"/>
			p_ud_data 	: ^UDINT;			//! <Variable Comment="variable to get pointer to readed data" Name="AddRdDO.p_ud_data"/>
			ud_type 	: UDINT;			//! <Variable Comment="0=control area, 1=memory area" Name="AddRdDO.ud_type"/>
			p_ud_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddRdDO.p_ud_DataAddr"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;			//! <Variable Comment=" 0=OK, negative=error (look lsl_st_varan.h)" Name="AddRdDO.sd_retval"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function call function of VaranMaster to add a write data object to varan master and install a varan task&#13;&#10;=================================================================================================&#13;&#10;" Name="AddWrDO"/>
	FUNCTION VIRTUAL GLOBAL AddWrDO
		VAR_INPUT
			ud_dol_type 	: UDINT;
			p_ud_handle 	: ^UDINT;
			ud_address 	: UDINT;
			ud_length 	: UDINT;
			p_ud_data 	: ^UDINT;
			ud_type 	: UDINT;
			p_ud_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddWrDO.p_ud_DataAddr"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a read/write data object&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRdWrDO"/>
	FUNCTION VIRTUAL GLOBAL AddRdWrDO
		VAR_INPUT
			ud_dol_type 	: UDINT;
			p_ud_handle 	: ^UDINT;
			ud_address_read 	: UDINT;			//! <Variable Comment="read address of do" Name="AddRdWrDO.ud_address_read"/>
			ud_length_read 	: UDINT;			//! <Variable Comment=" Length of read data object" Name="AddRdWrDO.ud_length_read"/>
			p_ud_data_read 	: ^UDINT;			//! <Variable Comment=" pointer to variable to get pointer to data" Name="AddRdWrDO.p_ud_data_read"/>
			ud_address_write 	: UDINT;			//! <Variable Comment="write address of do" Name="AddRdWrDO.ud_address_write"/>
			ud_length_write 	: UDINT;			//! <Variable Comment=" Length of write data object" Name="AddRdWrDO.ud_length_write"/>
			p_ud_data_write 	: ^UDINT;			//! <Variable Comment=" pointer to variable to get pointer to data" Name="AddRdWrDO.p_ud_data_write"/>
			ud_type 	: UDINT;
			p_ud_DataAddr_read 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the read data is given back" Name="AddRdWrDO.p_ud_DataAddr_read"/>
			p_ud_DataAddr_write 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the write data is given back" Name="AddRdWrDO.p_ud_DataAddr_write"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to read a direct access data object&#13;&#10;=================================================================================================&#13;&#10;" Name="RdDO"/>
	FUNCTION VIRTUAL GLOBAL RdDO
		VAR_INPUT
			ud_address 	: UDINT;			//! <Variable Comment=" Address of data object" Name="RdDO.ud_address"/>
			ud_length 	: UDINT;			//! <Variable Comment=" Length of data object" Name="RdDO.ud_length"/>
			p_ud_data 	: pVoid;			//! <Variable Comment=" pointer to variable to get pointer to data" Name="RdDO.p_ud_data"/>
			ud_type 	: UDINT;			//! <Variable Comment="0=control area, 1=memory area" Name="RdDO.ud_type"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;			//! <Variable Comment=" 0=OK, negative=error (look lsl_st_varan.h)" Name="RdDO.sd_retval"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to write a direct access data object&#13;&#10;=================================================================================================&#13;&#10;" Name="WrDO"/>
	FUNCTION VIRTUAL GLOBAL WrDO
		VAR_INPUT
			ud_address 	: UDINT;
			ud_length 	: UDINT;
			p_ud_data 	: pVoid;
			ud_type 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to install a callback function&#13;&#10;=================================================================================================&#13;&#10;" Name="SetObjectCallback"/>
	FUNCTION VIRTUAL GLOBAL SetObjectCallback
		VAR_INPUT
			us_place 	: USINT;			//! <Variable Comment="place of cdias module" Name="SetObjectCallback.us_place"/>
			ud_action_ptr 	: UDINT;			//! <Variable Comment="pointer to position info( first byte is length)" Name="SetObjectCallback.ud_action_ptr"/>
			ud_thisp 	: UDINT;			//! <Variable Comment="thispointer of object" Name="SetObjectCallback.ud_thisp"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to install a varan task&#13;&#10;=================================================================================================&#13;&#10;" Name="AddVaranTask"/>
	FUNCTION VIRTUAL GLOBAL AddVaranTask
		VAR_INPUT
			ud_dol_type 	: UDINT;
			p_this 	: ^void;			//! <Variable Comment=" Thispointer of connected varan class" Name="AddVaranTask.p_this"/>
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to find out if varan is available&#13;&#10;=================================================================================================&#13;&#10;" Name="IsVaranAvailable"/>
	FUNCTION VIRTUAL GLOBAL IsVaranAvailable
		VAR_OUTPUT
			sd_varan 	: DINT;			//! <Variable Comment="0=varan not available, 1=varan available, 2=CIV with DataMover available" Name="IsVaranAvailable.sd_varan"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get pointer to node string&#13;&#10;=================================================================================================&#13;&#10;" Name="GetPointer2NodeString"/>
	FUNCTION VIRTUAL GLOBAL GetPointer2NodeString
		VAR_OUTPUT
			p_us_node 	: ^USINT;			//! <Variable Comment="pointer to node string" Name="GetPointer2NodeString.p_us_node"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get addresses (specially for CRIF)&#13;&#10;=================================================================================================&#13;&#10;" Name="GetActualAddressPointer"/>
	FUNCTION VIRTUAL GLOBAL GetActualAddressPointer
		VAR_INPUT
			ud_dol_type 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ud_add 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL UpdateDIASRetryCounter;
	
	FUNCTION VIRTUAL GLOBAL AddRequiredObject
		VAR_INPUT
			thisp 	: ^void;
		END_VAR;
	
	FUNCTION VIRTUAL CheckforRequiredError;
	
	FUNCTION VIRTUAL GLOBAL GetModuleInfo
		VAR_INPUT
			us_place 	: USINT;
		END_VAR
		VAR_OUTPUT
			p_ModuleInfo 	: ^t_s_ModulInfo;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Callback - Function of Dias classes&#13;&#10;=================================================================================================&#13;&#10;" Name="Dias_Callback"/>
	FUNCTION GLOBAL Dias_Callback
		VAR_INPUT
			ud_reason 	: UDINT;			//! <Variable Comment="reason of callback" Name="Dias_Callback.ud_reason"/>
			ud_data 	: UDINT;			//! <Variable Comment="data of callback" Name="Dias_Callback.ud_data"/>
			b_RetryCounterAvailable 	: BOOL := 0;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Control::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd Varan_Base
#pragma usingLtd Varan_DataMover


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Dias2DataMover::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_DIAS2DATAMOVER
1$UINT, 50$UINT, (SIZEOF(::Dias2DataMover))$UINT, 
1$UINT, 4$UINT, 0$UINT, 
TO_UDINT(3820159437), "Dias2DataMover", //Class
TO_UDINT(3069482179), "DiasMasterC", 1$UINT, 70$UINT, //Baseclass
//Servers:
(::Dias2DataMover.DiasErrorPlace.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2088124791), "DiasErrorPlace", 
//Clients:
(::Dias2DataMover.VaranIn.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2999796184), "VaranIn", TO_UDINT(862125188), "Varan_Base", 2$UINT, 2$UINT, 
(::Dias2DataMover.To_DataMover.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1067327212), "To_DataMover", TO_UDINT(3752737333), "Varan_DataMover", 1$UINT, 50$UINT, 
(::Dias2DataMover.DIAS_BusAddress.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1850184988), "DIAS_BusAddress", 
(::Dias2DataMover.DiasErrorOff.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2996711206), "DiasErrorOff", 
END_FUNCTION


#define USER_CNT_Dias2DataMover 71

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Dias2DataMover] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Dias2DataMover::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= DiasMasterC::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= DiasMaster::Control.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, DiasMaster::Control.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_Dias2DataMover;
	vmt.CmdTable.NewInstr		:= #Control::NewInst();
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #GetPllTime();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #AddWait();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #WrCntr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddWr8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #AddWR16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #AddRTBSync();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #AddRet();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #AddRd32Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #AddRd16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #GetKennung();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #AddCall2Main();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Rd16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #Rd8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #Wr8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #Wr16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #AddRd8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #GetMasterType();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #AddDiasIRQ();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #AddRdDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[37]		:= #AddWrDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[38]		:= #AddRdWrDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #RdDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[41]		:= #WrDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[42]		:= #SetObjectCallback();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[43]		:= #AddVaranTask();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #IsVaranAvailable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[51]		:= #GetPointer2NodeString();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[52]		:= #GetActualAddressPointer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[58]		:= #UpdateDIASRetryCounter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[59]		:= #AddRequiredObject();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[60]		:= #CheckforRequiredError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[62]		:= #GetModuleInfo();

#pragma warning (default : 74)
	DiasMaster::Control.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DiasMaster::Control.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

#pragma usingLtd HwBaseCDIAS

//{{LSL_IMPLEMENTATION
#pragma usingLtd HWBase //BLEERN001
(************************************************************************************
*
*	Dias interface class for Varan Data Mover
*	Created : Sigmatek	/	SR	/	2007
*	Changes : 
*
*
*     FOR NEWER CHANGES SEE REVISION DOCUMENTATION IN CLASS PROPERTIES
*
*
*   1.2 => 1.3  /   28.07.2008
*           - [DB 920]: optimize call function for DIAS - classes (no mult in AWL code)
*		1.1 => 1.2	/	13.02.2008
*			- [ DB713 ]: - data type pHwBaseCDIAS wasn't defined
*                        - change DIAS Master timeout from 15 to 5
*		1.0 => 1.1	/	23.01.2008
*			- [ DB713 ]: insert fucntion to get pointers (specially for CRIF)
*
************************************************************************************)

	
#define VM_DIAS_CONTROL_ACCESS	16#8000
#define VM_DIAS_WORD_ACCESS		16#4000
#define VM_DIAS_MASTER_REGS		16#C000
#define VM_DM_RETRYCOUNTER    16#C040
#define VM_KENNUNG_OFFSET		16#FF
#define VM_SINGLE_ID			16#8000_0000
#define VM_DIAS_MAX_CALLBACKS	128					//Achtung: Auch im Array ändern!
#define COMM_TIMEOUT_ERROR         199
FUNCTION F_LoadFunction1
VAR_INPUT
	ud_reason	: UDINT;
END_VAR;
#define LoadFunction1( a )  	p_Function $ F_LoadFunction1( a )


//[#ENGLISH]
//=================================================================================================
//Function to Init class
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Dias2DataMover::Init

	//do nothing (overload init of DiasMasterC)
//BLEERN001 start
  b_HWRtPostScan := 1;  
//BLEERN001 end

  //init pointers
  p_port           := #s_RetryCounter.RetryCounter[0].Place;
  p_State          := (#s_RetryCounter.RetryCounter[0].p_State)$^UDINT;
  p_RetryCounter   := (#s_RetryCounter.RetryCounter[0].p_RetryCounter)$^UDINT;
  p_OldRetryCounter:= #OldRetryCounters[0];


  Initcounter += 1;
  
  //get client values
  DIAS_BusAddress := DIAS_BusAddress.Read();
  DiasErrorOff    := DiasErrorOff.Read();
  
  if Initcounter = 1 then
    FirstUpdate := true; 
  elsif Initcounter = 11 then
    CheckforRequiredError();
  end_if;

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::Init
//[#ENGLISH]
//=================================================================================================
//Function to read ID of Dias module
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Dias2DataMover::GetKennung
VAR_INPUT
	Place		: UDINT;
END_VAR
VAR_OUTPUT
	Kennung		: UDINT;
END_VAR
VAR
	sd_retval	: DINT;
END_VAR

	//check if we are allowed for access
	if ( b_ReadKennungAllowed = FALSE ) then
		Kennung := 255;
		return;
	end_if;

	//get kennung
	Kennung := 0;
	sd_retval := To_DataMover.DirectAccessRead	( ud_address 	:= DIAS_BusAddress + VM_DIAS_CONTROL_ACCESS + ( Place * 16#100 ) + VM_KENNUNG_OFFSET
												, ud_length 	:= 1
												, p_data 		:= #Kennung 
												);

	//if error return 255
	if ( sd_retval <> VARANMANAGER_OK ) then
		Kennung := 255;
	end_if;

	//check for DIAS Alive signal (access to first module)
	if ( Kennung <> 255 & us_DIASAliveModule = 16#FF ) then
		us_DIASAliveModule := TO_USINT( Place );

		//call function
		To_DataMover.SetDiasAliveSignal	( ud_address	:=  DIAS_BusAddress + VM_DIAS_CONTROL_ACCESS + ( Place * 16#100 ) + VM_KENNUNG_OFFSET
										, us_mode		:= 0
										);
    
    SetAliveTime := ops.tAbsolute;
	end_if;

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::GetKennung
//[#ENGLISH]
//=================================================================================================
//Function does a 8 Bit write access
//=================================================================================================
//[Globals]		_RTOSVersion		: OS version
//				_lsl_pos			: OS interface structure
//[Members]
//[Locals]
//[>Adress]		Module address and offset
//[>Data]		Data to write
//[<State]
FUNCTION VIRTUAL GLOBAL Dias2DataMover::Wr8Bit
VAR_INPUT
	Adress		: UDINT;
	Data		: Usint;
END_VAR
VAR_OUTPUT
	State		: DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    State := _NotInitialized;
    return;
  END_IF;
#endif
  
	State := To_DataMover.DirectAccessWrite	( ud_address 	:= DIAS_BusAddress + Adress
											, ud_length 	:= 1
											, p_data 		:= #Data 
											);

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::Wr8Bit
//[#ENGLISH]
//=================================================================================================
//Function does a 8 Bit read access
//=================================================================================================
//[Globals]		_RTOSVersion			: OS version
//				_lsl_pos				: OS interface structure
//[Members]
//[Locals]		us_data			:R/W	:intermediate storage of data
//				di_ret			:R/W	:return value of OS function
//[>Adress]		Module address and offset
//[<Data]		Data read
FUNCTION VIRTUAL GLOBAL Dias2DataMover::Rd8Bit
VAR_INPUT
	Adress		: UDINT;
END_VAR
VAR_OUTPUT
	Data		: DINT;
END_VAR

	Data := 0;
  
#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    return;
  END_IF;  
#endif
  
	To_DataMover.DirectAccessRead	( ud_address 	:= DIAS_BusAddress + Adress
									, ud_length 	:= 1
									, p_data 		:= #Data 
									);

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::Rd8Bit
//[#ENGLISH]
//=================================================================================================
//Function does a 16 Bit write access
//=================================================================================================
//[Globals]		_RTOSVersion		: OS version
//				_lsl_pos			: OS interface structure
//[Members]
//[Locals]
//[>Adress]		Module address and offset
//[>Data]		Data to write
FUNCTION VIRTUAL GLOBAL Dias2DataMover::Wr16Bit
VAR_INPUT
	Adress		: UDINT;
	Data		: UINT;
END_VAR
VAR_OUTPUT
	State		: DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    State := _NotInitialized;
    return;
  END_IF;
#endif
  
	State := To_DataMover.DirectAccessWrite	( ud_address	:= DIAS_BusAddress + VM_DIAS_WORD_ACCESS + Adress
											, ud_length 	:= 2
											, p_data 		:= #Data 
											);

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::Wr16Bit
//[#ENGLISH]
//=================================================================================================
//Function does a 16 Bit read access
//=================================================================================================
//[Globals]		_RTOSVersion			: OS version
//				_lsl_pos				: OS interface structure
//[Members]
//[Locals]		ui_data			:R/W	:intermediate storeage of data
//				di_ret			:R/W	:returnvalue of OS
//[>Adress]		Module address and offset
//[<Data]		Data read
FUNCTION VIRTUAL GLOBAL Dias2DataMover::Rd16Bit
VAR_INPUT
	Adress		: UDINT;
END_VAR
VAR_OUTPUT
	Data		: DINT;
END_VAR

	Data := 0;

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    return;
  END_IF;
#endif

	To_DataMover.DirectAccessRead	( ud_address 	:= DIAS_BusAddress + VM_DIAS_WORD_ACCESS + Adress
									, ud_length 	:= 2
									, p_data 		:= #Data 
									);

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::Rd16Bit
//[#ENGLISH]
//=================================================================================================
//Function is writing into controlarea of a diasmodul
//=================================================================================================
//[Globals]		_RTOSVersion		: OS version
//				_lsl_pos			: OS interface structure
//[Members]
//[Locals]
//[>Adress]		High Byte Modulnumber, Low Byte offset in Controlarea
//[>Data]		Data to write
//[<state]		0..success
FUNCTION VIRTUAL GLOBAL Dias2DataMover::WrCntr
VAR_INPUT
	adress		: DINT;
	Data		: USINT;
END_VAR
VAR_OUTPUT
	state		: DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    return;
  END_IF;
#endif

	state := To_DataMover.DirectAccessWrite	( ud_address 	:= DIAS_BusAddress + VM_DIAS_Control_ACCESS + adress$UDINT
											, ud_length 	:= 1
											, p_data 		:= #Data 
											);

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::WrCntr
//[#ENGLISH]
//=================================================================================================
//Function to read a direct access data object
//=================================================================================================
//[>ud_address]address to read
//[>ud_length]length of data should read
//[>p_ud_data]variable to get pointer to readed data
FUNCTION VIRTUAL GLOBAL Dias2DataMover::RdDO
VAR_INPUT
	ud_address		: UDINT;
	ud_length		: UDINT;
	p_ud_data		: pvoid;
	ud_type			: UDINT;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR
VAR
	ud_off			: UDINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    sd_retval := _NotInitialized;
    return;
  END_IF;
#endif

	//check if we can do it with word access (even address and even length)
	ud_off := 0;

	if ( ( ud_address mod 2 ) = 0 & ( ud_length mod 2 ) = 0 ) then
		ud_off := VM_DIAS_WORD_ACCESS;
	end_if;

	sd_retval := To_DataMover.DirectAccessRead	( ud_address	:= DIAS_BusAddress + ud_off + ud_address
												, ud_length 	:= ud_length
												, p_data 		:= p_ud_data
												);

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::RdDO
//[#ENGLISH]
//=================================================================================================
//Function to write a direct access data object
//=================================================================================================
//[>ud_address]address to write
//[>ud_length]length of data should be written
//[>p_ud_data]pointer to data should be written
FUNCTION VIRTUAL GLOBAL Dias2DataMover::WrDO
VAR_INPUT
	ud_address		: UDINT;
	ud_length		: UDINT;
	p_ud_data		: pVoid;
	ud_type			: UDINT;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR
VAR
	ud_off			: UDINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    sd_retval := _NotInitialized;
    return;
  END_IF;
#endif

	//check if we can do it with word access (even address and even length)
	ud_off := 0;

	if ( ( ud_address mod 2 ) = 0 & ( ud_length mod 2 ) = 0 ) then
		ud_off := VM_DIAS_WORD_ACCESS;
	end_if;

	sd_retval := To_DataMover.DirectAccessWrite	( ud_address	:= DIAS_BusAddress + ud_off + ud_address
												, ud_length 	:= ud_length
												, p_data 		:= p_ud_data
												);

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::WrDO
#pragma warning (disable: 73)
#pragma warning (disable: 76)

// ***************************************
//   put programm into the buffer
// ***************************************
//  this is a 8 bit read
//  the thispointer we need to call the update method
//
FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddRd8Bit
	VAR_INPUT
		Adress 	: HINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR
END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::AddRd8Bit

FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddWr8Bit
	VAR_INPUT
		adress 	: HINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		Data 	: USINT;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR
END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::AddWr8Bit
// ***************************************
//   put programm into the buffer
// ***************************************
//  this is a 16 bit read
//  the thispointer we need to call the update method
//
FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddRd16Bit
	VAR_INPUT
		Adress 	: HINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR
END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::AddRd16Bit
// ***************************************
//   put programm into the buffer
// ***************************************
//  this is a 16 bit read
//  the thispointer we need to call the update method
//
FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddWR16Bit
	VAR_INPUT
		adress 	: HINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		data 	: UINT;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		handle 	: DINT;
	END_VAR
END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::AddWR16Bit
// ***************************************
//   put programm into the buffer
// ***************************************
//  this is a 16 bit read
//  the thispointer we need to call the update method
//
FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddRd32Bit
	VAR_INPUT
		Adress 	: HINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR
END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::AddRd32Bit
// ***************************************
//     add a call to the main Programm
// ***************************************
//
// RTCY = 0 cyclic programm
// RTCY = constant realtime  --> realtime programm
//
// MODE Bit 0 = continue
// 		Bit 1 = single
//		Bit 4 = block execution   !!!  (important for Analogcards 3 opcodes must be together)
//
//
FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddCall2Main
	VAR_INPUT
		Mode 	: UINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR
END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::AddCall2Main

FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddRet
VAR_INPUT
	RTCY		: DINT;
END_VAR
END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::AddRet
//[#ENGLISH]
//=================================================================================================
//Function add a delay to list
//=================================================================================================
//[>Time_uSec]Time in uSec (valid from 0-255)
FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddWait
VAR_INPUT
	RTCY		: DINT;
	Time_uSec	: DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    return;
  END_IF;
#endif

	To_DataMover.AddDelay	( ud_task 	:= RTCY$UDINT
							, ud_time 	:= Time_uSec$UDINT 
							);

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::AddWait
//[#ENGLISH]
//=================================================================================================
//Function to add dias sync
//=================================================================================================
// *************************************************
//   RTB is fixed reserved for one MODUL
// *************************************************
//
//  if FirstRTB <> 0 then this modul is the first with RTB
//  and has to do perhaps something special
//  if FirstRTB = 0 then it already exists a modul with RTBSYNC
//
FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddRTBSync
VAR_INPUT
	Adress		: HINT;
END_VAR
VAR_OUTPUT
	FirstRTB	: DINT;
END_VAR
VAR
	sd_retval	: DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    FirstRTB := 0;
    return;
  END_IF;
#endif

	FirstRTB := 0;

	//check if sync is already installed
	if ( us_SyncModule = 16#FF ) then

		sd_retval := To_DataMover.AddFirstWrISO	( ud_add		:= DIAS_BusAddress + VM_DIAS_CONTROL_ACCESS + 16#100 * 63 + 2
												, ud_length		:= 1
												, p_data		:= #StartOfRt
												);

		//look for an error
		if ( sd_retval <> VARANMANAGER_OK ) then
			Control := -1;
			return;
		end_if;
		
		FirstRTB := 1;

		//set place of sync module
		us_SyncModule := TO_USINT( Adress shr 8 );
	end_if;

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::AddRTBSync
//[#ENGLISH]
//=================================================================================================
//Function call function of VaranMaster to add a read data object to varan master and install a varan task
//=================================================================================================
//[>ud_dol_type] pointer to variable to set right handle
//[>p_ud_handle]pointer to variable to set right handle
//[>ud_address] Address of data object
//[>ud_length] Length of data object
//[>p_ud_data] pointer to variable to get pointer to data
//[>ud_type]0=control area, 1=memory area
//[<sd_retval] 0=OK, negative=error (look lsl_st_varan.h)
FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddRdDO
	VAR_INPUT
		ud_dol_type 	: UDINT;
		p_ud_handle 	: ^UDINT;
		ud_address 	: UDINT;
		ud_length 	: UDINT;
		p_ud_data 	: ^UDINT;
		ud_type 	: UDINT;
		p_ud_DataAddr 	: ^HDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
VAR
	ud_off			: UDINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    sd_retval := _NotInitialized;
    return;
  END_IF;
#endif

	//check if we can do it with word access (even address and even length)
	ud_off := 0;
	
	if ( ( ud_address mod 2 ) = 0 & ( ud_length mod 2 ) = 0 ) then
		ud_off := VM_DIAS_WORD_ACCESS;
	end_if;

	if ( ud_dol_type = VARAN_DOL_ISO ) then

		//check if we have a single
		if ( ud_type and VM_SINGLE_ID ) then
			
			sd_retval := To_DataMover.AddRdISOEnable( ud_add		:= DIAS_BusAddress + ud_off + ud_address
													, ud_length		:= ud_length
													, p_data		:= p_ud_data
													, p_enable		:= p_ud_handle$^USINT
													);
		
		else
			
			sd_retval := To_DataMover.AddRdISO	( ud_add 	:= DIAS_BusAddress + ud_off + ud_address
												, ud_length := ud_length
												, p_data 	:= p_ud_data 
												);

			p_ud_handle^ := ( #s_DummyHeader )$UDINT;
		end_if;

	else

		//check if we have a single
		if ( ud_type and VM_SINGLE_ID ) then

			sd_retval := To_DataMover.AddRdASYEnable( ud_add		:= DIAS_BusAddress + ud_off + ud_address
													, ud_length		:= ud_length
													, p_data		:= p_ud_data
													, p_enable		:= p_ud_handle$^USINT
													);

		else
			
			sd_retval := To_DataMover.AddRdASY	( ud_add 	:= DIAS_BusAddress + ud_address + ud_off
												, ud_length := ud_length
												, p_data 	:= p_ud_data 
												);

			p_ud_handle^ := ( #s_DummyHeader )$UDINT;
		end_if;
	end_if;

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::AddRdDO
//[#ENGLISH]
//=================================================================================================
//Function call function of VaranMaster to add a write data object to varan master and install a varan task
//=================================================================================================
//[>ud_dol_type] pointer to variable to set right handle
//[>p_ud_handle]pointer to variable to set right handle
//[>ud_address] Address of data object
//[>ud_length] Length of data object
//[>p_ud_data] pointer to variable to get pointer to data
//[>ud_type]0=control area, 1=memory area
//[<sd_retval] 0=OK, negative=error (look lsl_st_varan.h)
FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddWrDO
	VAR_INPUT
		ud_dol_type 	: UDINT;
		p_ud_handle 	: ^UDINT;
		ud_address 	: UDINT;
		ud_length 	: UDINT;
		p_ud_data 	: ^UDINT;
		ud_type 	: UDINT;
		p_ud_DataAddr 	: ^HDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
VAR
	ud_off			: UDINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    sd_retval := _NotInitialized;
    return;
  END_IF;
#endif

	//check type (special for crif)
	if ( ud_type = 16#FFFF_FFFF ) then

		sd_retval := To_DataMover.AddVaranWrDO	( ud_dol_type	:= ud_dol_type
												, p_ud_handle	:= p_ud_handle
												, ud_address	:= ud_address
												, ud_length		:= ud_length
												, p_ud_data		:= p_ud_data
												, ud_type		:= ud_type
												);

	else
	
		//check if we can do it with word access (even address and even length)
		ud_off := 0;
	
		if ( ( ud_address mod 2 ) = 0 & ( ud_length mod 2 ) = 0 ) then
			ud_off := VM_DIAS_WORD_ACCESS;
		end_if;

		if ( ud_dol_type = VARAN_DOL_ISO ) then

			//check if we have a single
			if ( ud_type and VM_SINGLE_ID ) then
			
				sd_retval := To_DataMover.AddWrISOEnable( ud_add		:= DIAS_BusAddress + ud_off + ud_address
														, ud_length		:= ud_length
														, p_data		:= p_ud_data
														, p_enable		:= p_ud_handle$^USINT
														);
		
			else

				sd_retval := To_DataMover.AddWrISO	( ud_add 	:= DIAS_BusAddress + ud_off + ud_address
													, ud_length := ud_length
													, p_data 	:= p_ud_data 
													);

				p_ud_handle^ := ( #s_DummyHeader )$UDINT;
			end_if;

		else

			//check if we have a single
			if ( ud_type and VM_SINGLE_ID ) then
			
				sd_retval := To_DataMover.AddWrASYEnable( ud_add		:= DIAS_BusAddress + ud_off + ud_address
														, ud_length		:= ud_length
														, p_data		:= p_ud_data
														, p_enable		:= p_ud_handle$^USINT
														);
		
			else
		
				sd_retval := To_DataMover.AddWrASY	( ud_add 	:= DIAS_BusAddress + ud_off + ud_address
													, ud_length := ud_length
													, p_data 	:= p_ud_data 
													);

				p_ud_handle^ := ( #s_DummyHeader )$UDINT;
			end_if;
		end_if;
	end_if;

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::AddWrDO
//[#ENGLISH]
//=================================================================================================
//Function to add a read/write data object
//=================================================================================================
//[>ud_dol_type] type of DOL list( 1=direct access, 2=IRQ, 3=realtime, 4=cyclic )
//[>p_ud_handle] pointer to variable to set right handle
//[>ud_address_read] Address of read data object
//[>ud_length_read] Length of read data object
//[>p_ud_data_read] pointer to variable to get pointer to data
//[>ud_address_write] Address of write data object
//[>ud_length_write] Length of write data object
//[>p_ud_data_write] pointer to variable to get pointer to data
//[<sd_retval] 0=OK, negative=error (look lsl_st_varan.h)
FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddRdWrDO
	VAR_INPUT
		ud_dol_type 	: UDINT;
		p_ud_handle 	: ^UDINT;
		ud_address_read 	: UDINT;
		ud_length_read 	: UDINT;
		p_ud_data_read 	: ^UDINT;
		ud_address_write 	: UDINT;
		ud_length_write 	: UDINT;
		p_ud_data_write 	: ^UDINT;
		ud_type 	: UDINT;
		p_ud_DataAddr_read 	: ^HDINT;
		p_ud_DataAddr_write 	: ^HDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
VAR
	ud_off_rd			: UDINT;
	ud_off_wr			: UDINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    sd_retval := _NotInitialized;
    return;
  END_IF;
#endif

	//check if we can do it with word access (even address and even length)
	ud_off_rd := 0;
	ud_off_wr := 0;
	
	if ( ( ud_address_read mod 2 ) = 0 & ( ud_length_read mod 2 ) = 0 ) then
		ud_off_rd := VM_DIAS_WORD_ACCESS;
	end_if;

	if ( ( ud_address_write mod 2 ) = 0 & ( ud_length_write mod 2 ) = 0 ) then
		ud_off_wr := VM_DIAS_WORD_ACCESS;
	end_if;

	if ( ud_dol_type = VARAN_DOL_ISO ) then

		sd_retval := To_DataMover.AddRdISO	( ud_add 	:= DIAS_BusAddress + ud_off_rd + ud_address_read
											, ud_length := ud_length_read
											, p_data 	:= p_ud_data_read 
											);

		if ( sd_retval = VARANMANAGER_OK ) then
			sd_retval := To_DataMover.AddWrISO	( ud_add 	:= DIAS_BusAddress + ud_off_wr + ud_address_write
												, ud_length := ud_length_write
												, p_data 	:= p_ud_data_write 
												);
		end_if;
		p_ud_handle^ := ( #s_DummyHeader )$UDINT;

	else
		sd_retval := To_DataMover.AddRdASY	( ud_add 	:= DIAS_BusAddress + ud_off_rd + ud_address_read
											, ud_length := ud_length_read
											, p_data 	:= p_ud_data_read 
											);

		if ( sd_retval = VARANMANAGER_OK ) then
			sd_retval := To_DataMover.AddWrASY	( ud_add 	:= DIAS_BusAddress + ud_off_wr + ud_address_write
												, ud_length := ud_length_write
												, p_data 	:= p_ud_data_write 
												);
		end_if;
		p_ud_handle^ := ( #s_DummyHeader )$UDINT;
	end_if;

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::AddRdWrDO
#pragma warning (default: 73)
#pragma warning (default: 76)


FUNCTION VIRTUAL GLOBAL Dias2DataMover::GetMasterType
VAR_OUTPUT
	MasterType		: UDINT;
END_VAR

	MasterType := 2;

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::GetMasterType
//[#ENGLISH]
//=================================================================================================
//Function to find out if varan is available
//=================================================================================================
//[<sd_varan]0=varan not available, 1=varan available, 2=CIV with DataMover available
FUNCTION VIRTUAL GLOBAL Dias2DataMover::IsVaranAvailable
VAR_OUTPUT
	sd_varan		: DINT;
END_VAR
	
	sd_varan := 2;
	
END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::IsVaranAvailable
#pragma warning (disable:73 )

//[#ENGLISH]
//=================================================================================================
//Function to install a callback function
//=================================================================================================
//[>us_place]place of cdias module
//[>ud_action_ptr]pointer to position info( first byte is length)
//[>ud_thisp]thispointer of object
FUNCTION VIRTUAL GLOBAL Dias2DataMover::SetObjectCallback
VAR_INPUT
	us_place		: USINT;
	ud_action_ptr	: UDINT;
	ud_thisp		: UDINT;
END_VAR
VAR
	i		: UINT;
END_VAR
  
  //valid place number (0 - 63 for Dias modules and 0 - 7 for CDIAS modules behind a cic)
  if us_place <= 63 | ((us_place AND NOT(16#80)) < 8) then
    //max 64 Dias modules plus 8 cic
    if ( ui_DiasCounter < VM_DIAS_MAX_CALLBACKS ) then
      //install callback pointer for dias modules
      
      //first check if we have a callback for that thispointer
      if ( ui_DiasCounter ) then
        for i := 0 to ui_DiasCounter - 1 do
          if ( a_DiasCallBacks[ i ].ud_Thisp = ud_thisp ) then
            //overwrite
            a_DiasCallBacks[ i ].ud_CallbackFunction	:= ud_action_ptr;
            return;
          end_if;
        end_for;
      end_if;

      a_DiasCallBacks[ ui_DiasCounter ].ud_CallbackFunction	:= ud_action_ptr;
      a_DiasCallBacks[ ui_DiasCounter ].ud_Thisp				:= ud_thisp;
      
      ui_DiasCounter += 1;
    end_if;
    
    // save Dias module pointers in array
    if us_place <= 63 then
      s_ModuleInfo[us_place].p_This := ud_thisp$pVoid;
    end_if;

  end_if;
  
END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::SetObjectCallback
#pragma warning (default:73 )

//[#ENGLISH]
//=================================================================================================
//Function to install a varan task
//=================================================================================================
//[>ud_dol_type] type of DOL list( Realtime = 3, cyclic = 4 )
//[>p_this] Thispointer of connected varan class
FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddVaranTask
	VAR_INPUT
		ud_dol_type 	: UDINT;
		p_this 	: ^void;
		callOptions 	: USINT;
	END_VAR
VAR
	i		: UINT;
END_VAR

	//search for thispointer (is set in SetObject callback)
	for i := 0 to VM_DIAS_MAX_CALLBACKS - 1 do 
		
		//look if we have thispointer
		if ( a_DiasCallBacks[ i ].ud_Thisp = p_this$UDINT ) then
			
			//save flags in array
			if ( ud_dol_type = VARAN_DOL_ISO ) then
        IF callOptions AND CALL_OPTION_RT_PRESCAN THEN
          a_DiasCallBacks[ i ].ud_Flags.1 := 1;
        END_IF;
        IF callOptions AND CALL_OPTION_RT_POSTSCAN THEN
          a_DiasCallBacks[ i ].ud_Flags.10 := 1;
        END_IF;
			else
				a_DiasCallBacks[ i ].ud_Flags.2 := 1;
			end_if;
			exit;
		end_if;
	end_for;

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::AddVaranTask
//[#ENGLISH]
//=================================================================================================
//This Function is Called by PostScan from DiasMasterPostScan
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Dias2DataMover::CyWork
VAR_INPUT
	EAX		: UDINT;
END_VAR
VAR_OUTPUT
	state	: UDINT;
END_VAR
VAR
	p_dias			    : pHwBase; //BLEERN001
	i				        : UINT;
	p_diascallback	: ^t_DiasCallback;
END_VAR

	//only update if we are called from CIV or DIV
	if ( EAX = 1 ) then
  
		//check retry counter
		if ( p_DiasRegs <> NIL ) then
			if ( oldErrorCounter <> p_DiasRegs^.us_RetryCounter ) then
				DiasRetryCounter += TO_USINT( ( p_DiasRegs^.us_RetryCounter - oldErrorCounter$USINT ) );
				oldErrorCounter := p_DiasRegs^.us_RetryCounter;
        
        //update moduls retry counter if needed and possible
        if ModuleRetryCntEnable then
          UpdateDIASRetryCounter();
        end_if;
      
      //initialze in first time
      elsif ( FirstUpdate = true ) then
        UpdateDIASRetryCounter();
      end_if;

			//check for DiasError
			if ( DiasErrorOff = 0 ) then
				if ( p_DiasRegs^.us_ErrorReg and 1) then
					Control := -1;
					DiasErrorPlace := p_DiasRegs^.us_ErrorSourceReg and 2#111111;
					VaranIn.SetDOsOff();
					VaranIn.SetState( _DiasError );
          state := ERROR;
          return;
				end_if;
			end_if;
		end_if;
	
		//if class is ok
		if ( Control = 0 & ui_DiasCounter <> 0 ) then

			//first check if we have a new class to call
			for i := 0 to ui_DiasCounter - 1 do
			
				p_diascallback := #a_DiasCallBacks[ i ];
				if ( p_diascallback^.ud_Flags.2 = 1 ) then
					p_dias := p_diascallback^.ud_Thisp$pHwBase; //BLEERN001

					//call class
					p_dias^.UpdateCy( 0 );
				end_if;
			end_for;
		end_if;
	end_if;

	state:= READY;

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::CyWork
//[#ENGLISH]
//=================================================================================================
//Rt Function
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Dias2DataMover::RtWork
VAR_INPUT
	EAX		: UDINT;
END_VAR
VAR_OUTPUT
	state	: UDINT;
END_VAR
VAR
	p_dias			: pHwBase; //BLEERN001
	i				: UINT;
	p_diascallback	: ^t_DiasCallback;
END_VAR

	//if class is ok
	if ( Control = 0 & ui_DiasCounter <> 0 ) then
    
		//first check if we have a new class to call
		for i := 0 to ui_DiasCounter - 1 do
			
			p_diascallback := #a_DiasCallBacks[ i ];
			if ( p_diascallback^.ud_Flags.1 = 1 ) then
				p_dias := p_diascallback^.ud_Thisp$pHwBase; //BLEERN001

				//call class
				p_dias^.UpdateRt( 0 );
			end_if;
		end_for;

	end_if;

	state:= READY;

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::RtWork
//[#ENGLISH]
//=================================================================================================
//This Function returns Pll Time
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Dias2DataMover::GetPllTime
VAR_OUTPUT
	PllTime		: DINT;
END_VAR

	PllTime := ( VaranIn.GetVaranTime() / 1000000 )$DINT;

	//below 1 ms not possible
	if ( PllTime = 0 ) then
		TRACE( "Varan Time below 1ms not possible with DIAS - Moduls!!" );
		VaranIn.SetState( _DiasTimeError );
	end_if;

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::GetPllTime
//[#ENGLISH]
//=================================================================================================
//Callback - Function of Dias classes
//=================================================================================================
//[>ud_reason]reason of callback
//[>ud_data]data of callback
FUNCTION GLOBAL Dias2DataMover::Dias_Callback
	VAR_INPUT
		ud_reason 	              : UDINT;
		ud_data 	                : UDINT;
		b_RetryCounterAvailable 	: BOOL;
	END_VAR
VAR
	i			: UINT;
	j			: DINT;
	p_this		: UDINT;
	sd_retval	: DINT;
	a_data		: ARRAY[0..7] OF USINT;
  timex     : udint;
	p_Function	: pVoid;
  MinDIASPlace : UDINT;
  MaxDIASPlace : UDINT;
END_VAR

	case ( ud_reason ) of

		VARANMANAGER_CB_CONNECT:

			Control := 0;
      
      //reset server
      DiasErrorPlace := 0;
      
      //@bs
      //call function
      To_DataMover.SetDiasAliveSignal	( ud_address	:=  DIAS_BusAddress + VM_DIAS_CONTROL_ACCESS + 0 + VM_KENNUNG_OFFSET
										, us_mode		:= 0
										);
      timex := ops.tAbsolute;              
      while ops.tAbsolute - timex < 200ms do
        
      end_while;

      
			b_ReadKennungAllowed := TRUE;
      
			//look if class is ok
			if ( ui_DiasCounter <> 0 ) then
		
				//read DiasMaster Data
				sd_retval := To_DataMover.DirectAccessRead	( ud_address	:= DIAS_BusAddress + VM_DIAS_MASTER_REGS + 8
															, ud_length		:= 8
															, p_data		:= #a_data
															);
		
				//look for an error
				if ( sd_retval <> VARANMANAGER_OK ) then
					Control := -1;
					return; 
				end_if;

				oldErrorCounter := a_data[ 0 ];
				Release := a_data[ 5 ];
        
        //control if DIAS retrycounter is available
        ModuleRetryCntEnable := b_RetryCounterAvailable;        

				//check dias error
				if ( a_data[ 3 ] and 1 ) then

					a_data[ 0 ] := 0;
					//clear dias error
					sd_retval := To_DataMover.DirectAccessWrite	( ud_address	:= DIAS_BusAddress + VM_DIAS_MASTER_REGS + 16#B
																, ud_length		:= 1
																, p_data		:= #a_data
																);
		
					//look for an error
					if ( sd_retval <> VARANMANAGER_OK ) then
						Control := -1;
						return; 
					end_if;
				end_if;

				//write Dias Timeout DiasMaster Data
				a_data[ 0 ] := 5;

				sd_retval := To_DataMover.DirectAccessWrite	( ud_address	:= DIAS_BusAddress + VM_DIAS_MASTER_REGS + 16#14
															, ud_length		:= 1
															, p_data		:= #a_data[ 0 ]
															);
		
				//look for an error
				if ( sd_retval <> VARANMANAGER_OK ) then
					Control := -1;
					return; 
				end_if;

				//install move of Dias Master Register
				sd_retval := To_DataMover.AddRdASY	( ud_add		:= DIAS_BusAddress + VM_DIAS_MASTER_REGS
													, ud_length		:= sizeof( t_DiasMasterRegs )
													, p_data		:= #p_DiasRegs
													);
				//look for an error
				if ( sd_retval <> VARANMANAGER_OK ) then
					Control := -1;
					return; 
				end_if;
        
        
        //check DIAS retry counter area if possible
        if (ModuleRetryCntEnable = true) & (s_RetryCounter.Quantity > 0) then
        
          //init variables
          MinDIASPlace := 255; MaxDIASPlace := 0;
          
          //look for least and highest DIAS adress 
          for j := 0 to (s_RetryCounter.Quantity -1) do 
            
            if s_RetryCounter.RetryCounter[j].Place < MinDIASPlace then
              MinDIASPlace := s_RetryCounter.RetryCounter[j].Place;
            end_if;
            if s_RetryCounter.RetryCounter[j].Place > MaxDIASPlace then
              MaxDIASPlace := s_RetryCounter.RetryCounter[j].Place;
            end_if;
             
          end_for;


          //install DO for moduls retrycounter
          sd_retval := To_DataMover.AddRdASY(ud_add:= DIAS_BusAddress + VM_DM_RETRYCOUNTER + MinDIASPlace
                          , ud_length   := (MaxDIASPlace - MinDIASPlace) + 1//sizeof( ModuleRetryCnt )
                          , p_data      := #p_ModuleRetryCnt
                          );

          //look for an error
          if ( sd_retval <> VARANMANAGER_OK ) then
            Control := -1;
            return; 
          end_if; 
          
          //manipulate data pointer to right retrycounterplace
          p_ModuleRetryCnt -= MinDIASPlace;
                    
        end_if;  
        
				//no sync is installed
				us_SyncModule := 16#FF;
				us_DIASAliveModule := 16#FF;
			end_if;
  
  //unconnect evemt
  else  
  
    //mark as reinitialzed required
    FirstUpdate := true;

	end_case;	

	//call connected classes
	if ( ui_DiasCounter ) then
  
    // wait 50ms before trying  to access dias modules
    while (ops.tabsolute - SetAliveTime) < 50 do
    end_while;
    
		//call cdias callback functions
		for i := 0 to ui_DiasCounter - 1 do

			//if we have a callback function
			if ( a_DiasCallBacks[ i ].ud_CallBackFunction <> NIL ) then
			
				p_Function$UDINT := a_DiasCallBacks[ i ].ud_CallBackFunction;
				p_this := this$UDINT;
				this$UDINT := a_DiasCallBacks[ i ].ud_Thisp;
				LoadFunction1( ud_reason );
				this$UDINT := p_this;

			end_if;
		end_for;
	end_if;

END_FUNCTION //GLOBAL Dias2DataMover::Dias_Callback
//[#ENGLISH]
//=================================================================================================
//Function to get pointer to node string
//=================================================================================================
//[<p_us_node]pointer to node string
FUNCTION VIRTUAL GLOBAL Dias2DataMover::GetPointer2NodeString
VAR_OUTPUT
	p_us_node		: ^USINT;
END_VAR

	p_us_node := VaranIn.GetPointer2NodeString();

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::GetPointer2NodeString
//[#ENGLISH]
//=================================================================================================
//Function to get addresses (specially for CRIF)
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Dias2DataMover::GetActualAddressPointer
VAR_INPUT
	ud_dol_type		: UDINT;
END_VAR
VAR_OUTPUT
	ud_add		: UDINT;
END_VAR

	if ( ( ud_dol_type and 16#0FFF_FFFF )= VARAN_DOL_ISO ) then
		ud_dol_type := ud_dol_type and 16#F000_0000;
		ud_add := To_DataMover.GetActualAddressPointerISO( ud_type := ud_dol_type );

	else
		ud_dol_type := ud_dol_type and 16#F000_0000;
		ud_add := To_DataMover.GetActualAddressPointerASY( ud_type := ud_dol_type );
	end_if;

END_FUNCTION //VIRTUAL GLOBAL Dias2DataMover::GetActualAddressPointer


//BLEERN001 start
FUNCTION VIRTUAL GLOBAL Dias2DataMover::UpdateRtPostScan
VAR
	p_dias			: pHwBase;
	i				: UINT;
	p_diascallback	: ^t_DiasCallback;
END_VAR

	//if class is ok
	if ( Control = 0 & ui_DiasCounter <> 0 ) then
    
		//first check if we have a new class to call
		for i := 0 to ui_DiasCounter - 1 do
			
			p_diascallback := #a_DiasCallBacks[ i ];
			if ( p_diascallback^.ud_Flags.10 = 1 ) then
				p_dias := p_diascallback^.ud_Thisp$pHwBase;

				//call class
				p_dias^.UpdateRtPostScan();
			end_if;
		end_for;

	end_if;

END_FUNCTION
//BLEERN001 end

#pragma warning(disable:137 )
FUNCTION VIRTUAL Dias2DataMover::CheckforRequiredError
  VAR
    i : UINT;
    thisp : ^virtualbase;
    sz_name	: array[ 0..255 ] of char;
    MyPara    : CmdStruct;
    MyResult  : results;
    UserActionRet    : DINT;
  END_VAR

  if RequiredObjectCounter > 0 then
    //--- init the newInst command
    MyPara.uiCmd := DM_CHECK_REQUIRED_ERROR;
    for i := 0 to (RequiredObjectCounter -1) do 
      thisp := (p_RequiredObjects + (i * sizeof(^void)))^$^virtualbase;
      //--- init result for next call
      MyResult.aData[0] := 16#FF;
      MyResult.aData[1] := 16#FF;
      if (thisp^.NewInst(#MyPara, #MyResult) = ERROR) then
          //Required Error!
        if MyResult.aData[1] = DIAS_MODULE then
          UserActionRet := VaranIn.UserAction.Write(input:= VARANMANAGER_CB_DIAS_ERROR);
        else
          UserActionRet := 1;
        end_if;
        
        if UserActionRet <> 0 then
          _GetObjName( thisp, #sz_name[ 0 ] );
          if RequiredErrors = 0 then
            Trace ("Required Error triggerd by object(s):");
          end_if;
          Trace (#sz_name[ 0 ] );
          
          RequiredErrors +=1;
          
          //--- show error-place on the server
          if MyResult.aData[0] <> 16#FF then
            DiasErrorPlace := MyResult.aData[0];
          end_if;  
        end_if;     
      end_if;
      
    end_for;
    
    if RequiredErrors > 0 then
      VaranIn.SetState(_DIASRequiredError);
    end_if;  
    
    To_StdLib.Free(p_RequiredObjects);
  end_if;

  // end changes _____________________________________________________________________________________________


END_FUNCTION
#pragma warning(Default:137 )

FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddRequiredObject
	VAR_INPUT
		thisp 	: ^void;
	END_VAR
  
  if b_NotfirstCall = false then
  
    p_RequiredObjects := To_StdLib.Malloc(size:=(500*sizeof(^void)));    
    //VaranIn.VaranIn.AllowRequiredError();
    VaranIn.AllowRequiredError();
    
    VaranIn.Required := 1;
  
  end_if;
  
  b_NotfirstCall := true;
  
  if RequiredObjectCounter < 500 then
    (p_RequiredObjects + (RequiredObjectCounter * sizeof(^void)))^$^void := thisp;
    RequiredObjectCounter += 1;
      
  else
		TRACE( "DiasMaster: Too many required object classes added");
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL Dias2DataMover::UpdateDIASRetryCounter
VAR
  i                          : DINT;
  OldRetryCounter            : USINT;
  NewRetryCounter            : USINT;
  p_actualRetryCounterServer : ^DINT;
  p_actualStateServer        : ^IO_State;
END_VAR

  //get info how much DIAS moduls are connected
  i := s_RetryCounter.Quantity - 1 ;
  
  while i > - 1  do
  
    //load pointer to state server from counterstruct
    p_actualStateServer := (p_State + (i * sizeof(a_RetryStruct)))^$^IO_State;
    
    //check if pointer is valid
    if p_actualStateServer <> NIL then
    
      //check online state
      if MasterON then
    
        //compare if hw class state is ok 
        if (((p_actualStateServer^$UINT) and 2#1100000000000011) = 0 ) | ( FirstUpdate = true ) then
            
          //load pointer to retrycounter server from counterstruct
          p_actualRetryCounterServer := (p_RetryCounter + (i * sizeof(a_RetryStruct)))^$^DINT;
        
          //check if pointer is valid
          if p_actualRetryCounterServer <> NIL then
            
            //not in first run - we must init OldRetryCounter first!
            if ( FirstUpdate = false ) then
            //load retrycounter value from hardware
              NewRetryCounter := (p_ModuleRetryCnt$^USINT + (p_port + (i * sizeof(a_RetryStruct)))^ )^;
            
              //get old value from counter
              OldRetryCounter := (p_OldRetryCounter + i)^;
              
              //check for differences
              if ( NewRetryCounter <> OldRetryCounter ) then
              
                //if new counter greater, no overflow ->
                if ( NewRetryCounter > OldRetryCounter ) then
                  p_actualRetryCounterServer^ += (NewRetryCounter - OldRetryCounter);
                else
                  //for overflow correction add 256
                  p_actualRetryCounterServer^ += (NewRetryCounter + 256 - OldRetryCounter);
                end_if;
                //set old counter to the value from new counter
                (p_OldRetryCounter + i)^ := NewRetryCounter;
              end_if;
            
            //check if retry counter is enabled
            elsif ( ModuleRetryCntEnable = true ) then
              //mark the actual value as init value in OldRetryCounter (with direct access)
              NewRetryCounter$DINT := Rd8Bit(Adress:= VM_DM_RETRYCOUNTER + (p_port + (i * sizeof(a_RetryStruct)))^);
              (p_OldRetryCounter + i)^ := NewRetryCounter;
              //check if it was disabled on last callback event and reset it
              if p_actualRetryCounterServer^ = -1 then
                p_actualRetryCounterServer^ := 0;
              end_if;
            else
              //mark retrycounter server as not active
              p_actualRetryCounterServer^ := -1;
            end_if;
            
          end_if;
                      
        else
          //class state not ok, so set state pointer to nil - no more checks needed
          (p_State + (i * sizeof(a_RetryStruct)))^ := NIL;          
        end_if;
        
      else
        //online state is 0, so signal error on class state server
        p_actualStateServer^$UINT := 16#FFFF;
      end_if;
      
    end_if;
    
    //decrement struct counter
    i -= 1;
  
  end_while;

  //mark as initialized
  FirstUpdate := false;

END_FUNCTION

#pragma warning(disable:73 )
FUNCTION VIRTUAL GLOBAL Dias2DataMover::AddDiasIRQ
	VAR_INPUT
		Place 	: USINT;
		ActionPtr 	: pVoid;
		thisptr 	: pVoid;
	END_VAR
	VAR_OUTPUT
		ok 	: USINT;
	END_VAR

  Trace("Interupts on DiasBus over VARAN are not supported !!! Object:");
  ok := 0;

END_FUNCTION
#pragma warning(default:73 )


FUNCTION VIRTUAL GLOBAL Dias2DataMover::GetModuleInfo
	VAR_INPUT
		us_place 	: USINT;
	END_VAR
	VAR_OUTPUT
		p_ModuleInfo 	: ^t_s_ModulInfo;
	END_VAR

  p_ModuleInfo := NIL;
  
  if us_place <= 63 then
    p_ModuleInfo := #s_ModuleInfo[us_place];
    // check if module is placed
    if p_ModuleInfo^.p_This = NIL then
      p_ModuleInfo := NIL;
      return;
    end_if;
    p_ModuleInfo^.Kennung := GetKennung(us_place)$UINT;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL Dias2DataMover::Control::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
  
  // Passes on the NewInst command, Goal is the VM.
  //LanSte 19.06.2013 13:11 Currently only needed so that the CRIF081 can check for Payload support
  ret_code := VaranIn.NewInst(pPara, pResult);	

END_FUNCTION
