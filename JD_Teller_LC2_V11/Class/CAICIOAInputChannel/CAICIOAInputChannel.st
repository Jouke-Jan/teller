//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "CAICIOAInputChannel"
	Revision           = "2.20"
	GUID               = "{EB178FC3-621A-4AB7-835E-3C53150C876E}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="stewer"/>
		<Dokumentation Revision="2.20" Date="05.12.2013" Author="LanSte&#13;&#10;FucHer" Company="Sigmatek" Description="Added payload support&#13;&#10;Changed AWL code to Structured Text."/>
		<Dokumentation Revision="2.8" Date="04.03.2010" Author="BleErn" Company="Sigmatek" Description="Changes in BaseClass (UpdateRtPostScan), Negative Values did not work on CIO012"/>
		<Dokumentation Revision="2.7" Date="17.05.2010" Author="RamAnd" Company="Sigmatek" Description="&quot;,&quot; was incorrectly used in code"/>
		<Dokumentation Revision="2.6" Date="29.01.2010" Author="wocpet" Company="Sigmatek" Description="Added method Bin2Phy for direct access of CIO016"/>
	</RevDoku>
	<Network Name="CAICIOAInputChannel">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{6FF283CE-2A0E-4D1B-896E-16C5275DFFB7}"
				Class      = "CAIInputChannel"
				Position   = "(270,150)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Server Name="State"/>
					<Client Name="BitResolution" Value="12"/>
					<Client Name="CBias"/>
					<Client Name="channel" Value="0"/>
					<Client Name="CInvert"/>
					<Client Name="connectc"/>
					<Client Name="CScale" Value="10000"/>
					<Client Name="CyRt" Value="1"/>
					<Client Name="EEOffset" Value="16#48"/>
					<Client Name="Neg" Value="0"/>
					<Client Name="TypeofChannel"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Data" Destination="_base.Data" Vertices="(742,210),(570,240),"/>
			<Connection Source="_base.connectc" Destination="this.connectc" Vertices="(270,660),(38,570),"/>
			<Connection Source="_base.TypeofChannel" Destination="this.TypeofChannel" Vertices="(270,300),(38,270),"/>
			<Connection Source="_base.CyRt" Destination="this.CyRt" Vertices="(270,360),(38,330),"/>
			<Connection Source="_base.CScale" Destination="this.CScale" Vertices="(270,420),(38,390),"/>
			<Connection Source="_base.CBias" Destination="this.CBias" Vertices="(270,480),(38,450),"/>
			<Connection Source="_base.CInvert" Destination="this.CInvert" Vertices="(270,540),(38,510),"/>
			<Connection Source="this.State" Destination="_base.State" Vertices="(742,270),(570,300),"/>
			<Connection Source="_base.channel" Destination="this.channel" Vertices="(270,240),(38,210),"/>
			<Connection Source="_base.Neg" Destination="this.Neg" Vertices="(270,720),(38,630),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using CAIInputChannel

CAICIOAInputChannel : CLASS
: CAIInputChannel
  //Servers:
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL UpdateCy
		VAR_INPUT
			Handle 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateRt
		VAR_INPUT
			Handle 	: UDINT;
		END_VAR;
				//! <Function Comment="-- overwite this function if there are other offsets ---------------------------&#13;&#10;" Name="GetEEOffset"/>
	FUNCTION VIRTUAL GLOBAL GetEEOffset
		VAR_OUTPUT
			Offset 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL Bin2Phy
		VAR_INPUT
			BinValue 	: DINT;
		END_VAR
		VAR_OUTPUT
			PhyValue 	: DINT;
		END_VAR;
	
	FUNCTION AWL VIRTUAL GLOBAL UpdateRt_AWL_II
		VAR_INPUT
			Handle 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB CAICIOAInputChannel::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_CAICIOAINPUTCHANNEL
2$UINT, 20$UINT, (SIZEOF(::CAICIOAInputChannel))$UINT, 
0$UINT, 0$UINT, 0$UINT, 
TO_UDINT(3907636883), "CAICIOAInputChannel", //Class
TO_UDINT(2472734913), "CAIInputChannel", 2$UINT, 20$UINT, //Baseclass
//Servers:
//Clients:
END_FUNCTION


#define USER_CNT_CAICIOAInputChannel 6

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_CAICIOAInputChannel] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION CAICIOAInputChannel::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= CAIInputChannel::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= DAIInputChnl::Data.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, DAIInputChnl::Data.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_CAICIOAInputChannel;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #GetEEOffset();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #UpdateRt_AWL_II();

#pragma warning (default : 74)
	DAIInputChnl::Data.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DAIInputChnl::Data.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


//*********************Inserted from .\CAICIOAInputChannel\CAICIOAInputChannel_00_00.st*********************



 



(****************************************************************************************
*
*	Created : Sigmatek
*	Changes :
*		1.2 => 2.5	/	08.03.2007	/	no Mark
*			- [DB 421]: now class is ready for plug & play over CIV
*		1.1 => 1.2	/	08.08.2006	/	Mark:	//#SR001
*			+/- 10V calculation was not correct
*		1.0 => 1.1	/	01.07.2005	/	Mark:	//#SR000
*			Changes in calculation of Offset for EEProm Data if type of channel is volt
*		0.0 => 1.0 / 23.12.2004 / no Mark / ws
*			compatibility with Lasal Class 2
*			removed visible flags from internal servers
*
*****************************************************************************************)

//-- overwite this function if there are other offsets ---------------------------

FUNCTION VIRTUAL GLOBAL CAICIOAInputChannel::GetEEOffset
VAR_OUTPUT
	Offset		: UINT;
END_VAR

	IF TypeofChannel = 0 THEN
		Offset := EEOffset$UINT + Channel$UINT*6;
	ELSE
		Offset := EEOffset$UINT + Channel$UINT*6 + 16#40;	//#SR000 (old was 16#88)
	END_IF;

END_FUNCTION //VIRTUAL GLOBAL CAICIOAInputChannel::GetEEOffset

FUNCTION VIRTUAL GLOBAL CAICIOAInputChannel::UpdateRt		//#SR001
VAR_INPUT
	Handle		: UDINT;
END_VAR
VAR
	NewData     : UINT;
  sgnNewData  : DINT;
END_VAR

  NewData := (_IOsegment$^UINT+HandleRDValue)^;

  if NewData <> udBinaryData$UINT then
    udBinaryData$UINT := NewData;

    if NewData >= udMaxBin$UINT then
      State.uiIO_Flags.PhysicHiLimit := 1;
    else
      State.uiIO_Flags.PhysicHiLimit := 0;
    end_if;

    sgnNewData := NewData$INT + udOffAct$DINT;
    if Neg = 0 then
      if sgnNewData < 0 then
        sgnNewData := 0;
      end_if;
    end_if;

    sgnNewData := sgnNewData * udMulAct$DINT / udDivAct$DINT;

    // check for signal invert
    if CInvert then
      sgnNewData := -sgnNewData;
      sgnNewData += CScale;
    end_if;

    Data := sgnNewData;
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CAICIOAInputChannel::UpdateRt

FUNCTION AWL VIRTUAL GLOBAL CAICIOAInputChannel::UpdateRt_AWL_II		//#SR001
VAR_INPUT
	Handle		: UDINT;
END_VAR
#ifdef _LSL_TARGETARCH_X86
		l.edi		_IOsegment
		l.ebx		HandleRDValue
		l.ax		(ebx+edi)  // value
		

		CMP.AX		udBinaryData+0
		JE			UPD_AI_NUD

		S.AX		udBinaryData+0

		CMP.AX		udMaxBin+0
		JB			UDF1
		BS.W		State.uiIO_Flags,IO_FLAG.PhysicHiLimit
		JMP			UDF2
UDF1	BR.W		State.uiIO_Flags,IO_FLAG.PhysicHiLimit
UDF2
		CWDE
		
		cmp.d		Neg,1
		je			LABEL_Neg
	
		ADD.EAX		udOffAct
		jns			UDF3
		clr			eax
		jmp			UDF3

LABEL_Neg
		add.eax		udOffAct

UDF3
		IMUL.D		udMulAct
		IDIV.D		udDivAct

// check for signal invert

		CMP.W		CInvert+0, 0
		JE			UPD_A_I2
		NEG			EAX
		ADD.EAX		cScale

UPD_A_I2	
		S.EAX		Data

UPD_AI_NUD
#endif
END_FUNCTION //VIRTUAL GLOBAL CAICIOAInputChannel::UpdateRt

FUNCTION VIRTUAL GLOBAL CAICIOAInputChannel::UpdateCy		//#SR001
VAR_INPUT
	Handle		: UDINT;
END_VAR

	UpdateRt(Handle);

END_FUNCTION //VIRTUAL GLOBAL CAICIOAInputChannel::UpdateCy


FUNCTION GLOBAL CAICIOAInputChannel::Bin2Phy
	VAR_INPUT
		BinValue 	: DINT;
	END_VAR
	VAR_OUTPUT
		PhyValue 	: DINT;
	END_VAR
  
  if BinValue = udBinaryData$DINT then
    PhyValue := Data;
  else
    if BinValue < udMaxBin$DINT then
      State.uiIO_Flags.PhysicHiLimit := 0;
    else
      State.uiIO_Flags.PhysicHiLimit := 1;
    end_if;

    PhyValue := (BinValue + udOffAct$DINT) * udMulAct$DINT / udDivAct$DINT;
    
    if CInvert then
      PhyValue := CScale - PhyValue;
    end_if;

  end_if;  

END_FUNCTION
