//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "DAIInputChnl"
	Revision           = "2.10"
	GUID               = "{8D453593-5B76-11D6-B05D-0010609208CF}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="Data" GUID="{8D453594-5B76-11D6-B05D-0010609208CF}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Value "/>
		<Server Name="State" GUID="{8D453595-5B76-11D6-B05D-0010609208CF}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="BitResolution" Required="true" Internal="false" Comment="12 or 14 bit converter "/>
		<Client Name="CBias" Required="false" Internal="false"/>
		<Client Name="channel" Required="true" Internal="false" Comment="channelnumber"/>
		<Client Name="CInvert" Required="false" Internal="false"/>
		<Client Name="connect" Required="false" Internal="false"/>
		<Client Name="CScale" Required="false" Internal="false"/>
		<Client Name="CyRt" Required="false" Internal="false" DefValue="1" Comment="0 = Cyclic |  1 = Realtime (as initvalue)"/>
		<Client Name="TypeofChannel" Required="false" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="stewer"/>
		<Dokumentation Revision="2.10" Date="09.12.2013" Author="FucHer" Company="Sigmatek" Description="Changed AWL code to Structured Text.  Default value of client RtCy = 1."/>
		<Dokumentation Revision="2.1" Date="04.03.2010" Author="BleErn" Company="Sigmatek" Description="Added Methods for UpdateRtPostScan"/>
	</RevDoku>
	<Network Name="DAIInputChnl">
		<!-- List of Components in this network -->
		<Components>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
DAIInputChnl : CLASS
	TYPE
	  _CompilerType : TransTypes;
	  s_Factory : STRUCT
	    dOffEE : DINT;
	    dMulEE : DINT;
	    dDivEE : DINT;
	  END_STRUCT;
	END_TYPE
  //Servers:
	Data 	: SvrChCmd_DINT;
	State 	: SvrCh_IO_State;
  //Clients:
	channel 	: CltCh_DINT;
	connect 	: CltChCmd_HwBase;
	TypeofChannel 	: CltCh_DINT;
	CyRt 	: CltCh_DINT;
	CScale 	: CltCh_DINT;
	CBias 	: CltCh_DINT;
	CInvert 	: CltCh_DINT;
	BitResolution 	: CltCh_DINT;
  //Variables:
		Factory 	: s_Factory;
		udMaxBin 	: UDINT;
		udOffAct 	: UDINT;
		udMulAct 	: UDINT;
		udDivAct 	: UDINT;
		udBiasBin 	: UDINT;
		HandleRDValue 	: DINT;
		udBinaryData 	: UDINT;
		Firstscan 	: UINT;
		b_Bipolar 	: BOOL;
		b_VaranAvailable 	: BOOL;
  //Functions:
				//! <Function Comment=" *******************************************************&#13;&#10; this is the init method of one input channel&#13;&#10; *******************************************************&#13;&#10;" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL UpdateCy
		VAR_INPUT
			Handle 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateRt
		VAR_INPUT
			Handle 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan
		VAR_INPUT
			Handle 	: DINT;
		END_VAR;
	
	FUNCTION CalFactory;
	
	FUNCTION GLOBAL ReCallFactory;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd HwBase


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DAIInputChnl::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_DAIINPUTCHNL
2$UINT, 10$UINT, (SIZEOF(::DAIInputChnl))$UINT, 
2$UINT, 8$UINT, 0$UINT, 
TO_UDINT(658675781), "DAIInputChnl", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::DAIInputChnl.Data.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2607161047), "Data", 
(::DAIInputChnl.State.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1422331979), "State", 
//Clients:
(::DAIInputChnl.channel.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2646372445), "channel", 
(::DAIInputChnl.connect.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1267336965), "connect", TO_UDINT(262141616), "HwBase", 2$UINT, 30$UINT, 
(::DAIInputChnl.TypeofChannel.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2310128295), "TypeofChannel", 
(::DAIInputChnl.CyRt.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(788764619), "CyRt", 
(::DAIInputChnl.CScale.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3846097224), "CScale", 
(::DAIInputChnl.CBias.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2351402359), "CBias", 
(::DAIInputChnl.CInvert.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1537718392), "CInvert", 
(::DAIInputChnl.BitResolution.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2731424614), "BitResolution", 
END_FUNCTION


#define USER_CNT_DAIInputChnl 3

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DAIInputChnl] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DAIInputChnl::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_DAIInputChnl, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
	Data.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Data.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma usingLtd DiasMasterC


(****************************************************************************************
*
*	Class for one analog outputchannel
*	Created : Sigmatek / 2003
*	Changes :
*		1.3 => 2.0	/	28.01.2008	/	Mark:	//#UL001
*			- [DB 713]: make compatible to CIV/DIV DataMover
*		1.2 => 1.3	/	04.10.2007	/	Mark:	//#SR001
*			- [DB 701]: class did not work with offset smaller zero
*		1.1 => 1.2	/	28.09.2006	/	Mark:	//#SR000
*			insert feature to change voltage range of analog inputs
*		0.1 => 1.1 / 23.12.2004 / no Mark / ws
*			compatibility with Lasal Class 2
*			removed visible flags from internal servers
*
*****************************************************************************************)

// *******************************************************
// this is the init method of one input channel
// *******************************************************

FUNCTION VIRTUAL GLOBAL DAIInputChnl::Init

	connect 	  := connect.Read();
	channel       := channel.read();
	TypeofChannel := TypeofChannel.read();
	CyRt          := CyRt.read();
	CScale        := CScale.read();
	CBias         := CBias.read(); 
	CInvert 	  := CInvert.read();
	BitResolution := BitResolution.read();

	if BitResolution = 14 then
		udMaxBin := 16000;
	else			  	
		udMaxBin := 4095; 
	end_if;	
	//#UL001 start
	//-----------------------------------------------------------------------------------------
	//look for varan bus
	if firstscan = 0 then
		b_VaranAvailable := connect.MasterConnect.IsVaranAvailable() <> 0;
	end_if;

	if ( b_VaranAvailable ) then
	 	
		if firstscan = 0 then
		  	firstscan:=1; 
		end_if;

	else
	//#UL001 end
	//-----------------------------------------------------------------------------------------

		if connect.GetEEState() then
		  // no data on the EEPROM channel or wrong
		  factory.dOffEE := 0;
	  	  factory.dMulEE := 4000;
	  	  factory.dDivEE := 4050;
		  CalFactory();
		else
		 if firstscan = 0 then
		  firstscan:=1; 

			//#SR000 start
			case ( TypeOfChannel$TransTypes ) of
				// 0-10 V
				POTI_10V_UNI:	HandleRDValue := connect.AddOneChannel	( thisp		:= this
																		, RTCY		:= cyrt
																		, channel	:= channel or ( 2#01010000 SHL 16 )
																		);
				// +/- 10 V
				POTI_10V_BI:	HandleRDValue := connect.AddOneChannel	( thisp		:= this
																		, RTCY		:= cyrt
																		, channel	:= channel or ( 2#01011000 SHL 16 )
																		);
								b_Bipolar := TRUE;

				// 0-5 V
				POTI_5V_UNI:	HandleRDValue := connect.AddOneChannel	( thisp		:= this
																		, RTCY		:= cyrt
																		, channel	:= channel or ( 2#01000000 SHL 16 )
																		);
				// +/- 5 V
				POTI_5V_BI:		HandleRDValue := connect.AddOneChannel	( thisp		:= this
																		, RTCY		:= cyrt
																		, channel	:= channel or ( 2#01001000 SHL 16 )
																		);
								b_Bipolar := TRUE;
				
				else
					HandleRDValue := connect.AddOneChannel ( thisp := this, RTCY := cyrt, channel := channel );

			end_case;
			//#SR000 end

		  connect.GetEEData(channel,(*//#SR000TypeofChannel*)POTI,#factory$DINT);
		  CalFactory();
		  
		 end_if;
		end_if;
	end_if;

END_FUNCTION //VIRTUAL GLOBAL DAIInputChnl::Init
FUNCTION VIRTUAL GLOBAL DAIInputChnl::UpdateCy
VAR_INPUT
	Handle		: UDINT;
END_VAR
	UpdateRt(Handle);
END_FUNCTION //VIRTUAL GLOBAL DAIInputChnl::UpdateCy

FUNCTION VIRTUAL GLOBAL DAIInputChnl::UpdateRt
	VAR_INPUT
	Handle		: UDINT;
	END_VAR
VAR
	NewData     : UINT;
  sgnNewData  : DINT;
END_VAR


  NewData := (_IOsegment$^UINT + HandleRDValue)^;

  if NewData <> udBinaryData$UINT then
    udBinaryData$UINT := NewData;
    
    if b_Bipolar = FALSE then
      //b_Bipolar = FALSE ==> unsigned data
      if NewData >= udMaxBin$UINT then
        State.uiIO_Flags.PhysicHiLimit := 1;
      else
        State.uiIO_Flags.PhysicHiLimit := 0;
      end_if;

      sgnNewData := NewData$INT + udOffAct$DINT;
      if sgnNewData < 0 then
        sgnNewData := 0;
      end_if;

      sgnNewData := sgnNewData * udMulAct$DINT / udDivAct$DINT;
      
      // check for signal invert
      if CInvert then
        sgnNewData := -sgnNewData;
        sgnNewData += CScale;
      end_if;
    else
#ifdef HWK_SHOW_PRAGMA_MESSAGES       
#pragma message(" FucHer am 04.07.2013 20:24 Tests mit pos. und neg. Werten erforderlich ")
#pragma message(" FucHer am 04.07.2013 20:24 Siehe auch CAICIOAInputChannel::UpdateRt")
#endif

      //b_Bipolar = TRUE ==> signed data
      if NewData$INT >= udMaxBin$INT then
        State.uiIO_Flags.PhysicHiLimit := 1;
      else
        State.uiIO_Flags.PhysicHiLimit := 0;
      end_if;

      sgnNewData := (NewData$INT + udOffAct$DINT) * udMulAct$DINT / udDivAct$DINT;

      // check for signal invert
      if CInvert then
        sgnNewData := -sgnNewData;
        sgnNewData += CScale;
      end_if;
    end_if;

    Data := sgnNewData;
  end_if;

END_FUNCTION //VIRTUAL GLOBAL DAIInputChnl::UpdateRt


 //VIRTUAL GLOBAL DAIInputChnl::UpdateRt
FUNCTION DAIInputChnl::CalFactory

// -- calculate binary offset
  udBiasBin$DINT := udMaxBin$DINT  * cBias / -1000;
  udOffAct$DINT  := udBiasBin$DINT * factory.dDivEE / factory.dMulEE + factory.dOffEE;

// dMulAct
  if b_Bipolar then
    udMulAct$DINT := CScale SHL 1;    // *2 cause +/-	10 Volt
  else
    udMulAct$DINT := CScale;
  end_if;

// dDivAct
  udDivAct$DINT := (udMaxBin + udBiasBin)$DINT * factory.dDivEE / factory.dMulEE;

END_FUNCTION // DAIInputChnl::CalFactory

 // DAIInputChnl::CalFactory

FUNCTION GLOBAL DAIInputChnl::ReCallFactory			//#UL001 start
	case ( TypeOfChannel$TransTypes ) of
		// 0-10 V
		POTI_10V_UNI:	HandleRDValue := connect.AddOneChannel	( thisp		:= this
																, RTCY		:= cyrt
																, channel	:= channel or ( 2#01010000 SHL 16 )
																);
		// +/- 10 V
		POTI_10V_BI:	HandleRDValue := connect.AddOneChannel	( thisp		:= this
																, RTCY		:= cyrt
																, channel	:= channel or ( 2#01011000 SHL 16 )
																);
						b_Bipolar := TRUE;
		
		// 0-5 V
		POTI_5V_UNI:	HandleRDValue := connect.AddOneChannel	( thisp		:= this
																, RTCY		:= cyrt
																, channel	:= channel or ( 2#01000000 SHL 16 )
																);
		// +/- 5 V
		POTI_5V_BI:		HandleRDValue := connect.AddOneChannel	( thisp		:= this
																, RTCY		:= cyrt
																, channel	:= channel or ( 2#01001000 SHL 16 )
																);
						b_Bipolar := TRUE;
				
	else
		HandleRDValue := connect.AddOneChannel ( thisp := this, RTCY := cyrt, channel := channel );

	end_case;

	connect.GetEEData(channel,POTI,#factory$DINT);
	CalFactory();

END_FUNCTION //GLOBAL DAIInputChnl::ReCallFactory	//#UL001 end

#pragma warning(disable: 73 )
FUNCTION VIRTUAL GLOBAL DAIInputChnl::UpDateRTPostScan
VAR_INPUT
	Handle		: DINT;
END_VAR

  
END_FUNCTION
#pragma warning(default:73 )