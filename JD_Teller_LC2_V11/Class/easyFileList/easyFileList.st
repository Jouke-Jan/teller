//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "easyFileList"
	Revision           = "0.0"
	GUID               = "{FCDE2B49-6BF4-4E58-9102-1448EBCFFA74}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="DirectoryBack" GUID="{E669DE26-76C4-46FC-9206-DD67D13145AD}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Entries" GUID="{CF8F4615-AE76-4C6B-B992-B7CE01192A87}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="RefreshFiles" GUID="{46F5EE8E-B454-4108-AE17-5F9A2897A0F6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="cToolCatLoadInfo" Required="true" Internal="false"/>
		<Client Name="ExtensionFilter" Required="true" Internal="false"/>
		<Client Name="FileIO" Required="false" Internal="false"/>
		<Client Name="FileString" Required="true" Internal="false"/>
		<Client Name="PathString" Required="true" Internal="false"/>
		<Client Name="toOpenFileString" Required="true" Internal="false"/>
	</Channels>
	<Network Name="easyFileList">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{503C8100-1901-4B7D-B5A7-0BAB7F119994}"
				Class      = "_ScrollArea"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="ActPos"/>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Client Name="ExtendedScrollBar"/>
					<Client Name="LineHighness"/>
					<Client Name="LineWidth"/>
					<Client Name="Lse"/>
					<Client Name="VerticalLevel"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(690,210),(518,210),"/>
			<Connection Source="this.Refresh" Destination="_base.Refresh" Vertices="(690,270),(518,270),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.LineWidth" Destination="this.LineWidth" Vertices="(218,330),(38,330),"/>
			<Connection Source="_base.VerticalLevel" Destination="this.VerticalLevel" Vertices="(218,270),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _ScrollArea

easyFileList : CLASS
: _ScrollArea
	TYPE
#pragma pack(push, 1)
	  _FILE_INFO : STRUCT
	    Filename : ARRAY [0..50] OF CHAR;
	    Extension : ARRAY [0..4] OF CHAR;
	    Attributes : USINT;
	    FileSize : UDINT;
	    DateTime : _DDE_DATIM;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _PIC_INFO : STRUCT
	    File : ^_BMP;
	    Dir : ^_BMP;
	    Drive : ^_BMP;
	    ScrollImage : ^_BMP;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _WIDTH : STRUCT
	    FileName : DINT;
	    FileTyp : DINT;
	    FileSize : DINT;
	    FileDateTime : DINT;
	    LineHeight : DINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	Entries 	: SvrCh_DINT;
	DirectoryBack 	: SvrCh_DINT;
	RefreshFiles 	: SvrCh_DINT;
  //Clients:
	FileIO 	: CltChCmd__FileSys;
	PathString 	: CltChCmd_String;
	FileString 	: CltChCmd_String;
	ExtensionFilter 	: CltChCmd_String;
	toOpenFileString 	: CltChCmd_String;
	cToolCatLoadInfo 	: CltCh_DINT;
  //Variables:
		aPath : ARRAY [0..255] OF CHAR;

		PathLen 	: UDINT;
		dMemNo 	: DINT;
		pFileInfo 	: ^_FILE_INFO;
		MyRefresh 	: BOOL;
		StringCRC 	: UDINT;
		aDrives : ARRAY [0..26] OF CHAR;

		PicInfo 	: _PIC_INFO;
		Width 	: _WIDTH;
		biOutInfo : BSINT
		[
		  1 OutTyp,
		  2 OutSize,
		  3 OutDate,
		  4 OutVerticalLines,
		  5 OutHorizontalLines,
		  6 OutFolders,
		  7 OutFiles,
		];

		DateTimeString : ARRAY [0..20] OF _ASCII;

		ScrollPosition 	: DINT;
		JpgMerker 	: DINT;
		InitDrives 	: DINT;
		LineColor 	: _COLOR;
		StartPathLen 	: UDINT;
		AltDirAct 	: DINT;
		StartPath : ARRAY [0..255] OF CHAR;

		lFileName 	: UDINT;
		lFilter 	: UDINT;
		udTest 	: UDINT;
  //Functions:
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when the input is active and a event occured&#13;&#10;&#13;&#10;ped ....... pointer to _EDITOR information&#13;&#10;pe ........ pointer to _EVENT information&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetEvent
		VAR_INPUT
			ped 	: ^_EDITOR;
			pe 	: ^_EVENT;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when system wants to redraw the io&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;pr ........ pointer to result information&#13;&#10;pv ........ pointer to io variableinformation&#13;&#10;input ..... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;&#13;&#10;if you want to draw the io let&apos;s return _IDIDIT&#13;&#10;" Name="Draw"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Draw
		VAR_INPUT
			pio 	: ^_IO;
			pr 	: ^_RESULT;
			pv 	: ^_VARIABLE;
			input 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;
			firsttime 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called cyclic during object is on screen&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Run"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Run
		VAR_INPUT
			pio 	: ^_IO;
			input 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called right away before the object will be destroyed.&#13;&#10;for example close picture or window&#13;&#10;" Name="IF_End"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_End;
	
	FUNCTION __CDECL VIRTUAL GLOBAL InitScroll
		VAR_INPUT
			pio 	: ^_IO;
			vno 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called every time when redraw of a single line is necessary.&#13;&#10;ps ..... --&gt; to structure _SCROLL&#13;&#10;pr ..... --&gt; to place where line should be drawn&#13;&#10;line ... number of line which should be drawn&#13;&#10;state .. line is selected (TRUE) or passive (FALSE)&#13;&#10;" Name="Line"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Line
		VAR_INPUT
			ps 	: ^_SCROLL;
			pr 	: ^_ROOM;
			line 	: UINT;
			state 	: BOOL;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL Out
		VAR_INPUT
			pio 	: ^_IO;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ReadFiles;
	
	FUNCTION GLOBAL GetUDCParam
		VAR_INPUT
			pio 	: ^_IO;
		END_VAR;
	
	FUNCTION DateTime
		VAR_INPUT
			DateTime 	: _DDE_DATIM;
		END_VAR;
	
	FUNCTION GLOBAL ResetPosition;
	
	FUNCTION GLOBAL OpenFile;
	
	FUNCTION GLOBAL UserDefinedAction;
	
	FUNCTION GLOBAL DirBack;
	
	FUNCTION VIRTUAL GLOBAL RefreshFiles::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd String


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB easyFileList::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_EASYFILELIST
0$UINT, 0$UINT, (SIZEOF(::easyFileList))$UINT, 
3$UINT, 6$UINT, 0$UINT, 
TO_UDINT(3455067800), "easyFileList", //Class
TO_UDINT(3043040051), "_ScrollArea", 0$UINT, 13$UINT, //Baseclass
//Servers:
(::easyFileList.Entries.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(314396127), "Entries", 
(::easyFileList.DirectoryBack.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(228698216), "DirectoryBack", 
(::easyFileList.RefreshFiles.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1686268688), "RefreshFiles", 
//Clients:
(::easyFileList.FileIO.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1567322633), "FileIO", TO_UDINT(545279513), "_FileSys", 1$UINT, 14$UINT, 
(::easyFileList.PathString.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3933989844), "PathString", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::easyFileList.FileString.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3046830909), "FileString", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::easyFileList.ExtensionFilter.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(626381598), "ExtensionFilter", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::easyFileList.toOpenFileString.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(183069282), "toOpenFileString", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::easyFileList.cToolCatLoadInfo.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1063485539), "cToolCatLoadInfo", 
END_FUNCTION


#define USER_CNT_easyFileList 24

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_easyFileList] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION easyFileList::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _ScrollArea::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_easyFileList;
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #IF_End();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #InitScroll();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #Line();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #Out();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #ReadFiles();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Entries.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Entries.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DirectoryBack.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF DirectoryBack.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RefreshFiles.pMeth			:= StoreMethod( #M_RD_DIRECT(), #RefreshFiles::Write() );
	IF RefreshFiles.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION



FUNCTION __CDECL VIRTUAL GLOBAL easyFileList::Line
	VAR_INPUT
		ps 	: ^_SCROLL;
		pr 	: ^_ROOM;
		line 	: UINT;
		state 	: BOOL;
	END_VAR
  
  
  VAR
    color      : _COLOR; 
    color1      : _COLOR; 
    att        : _ATTRIB; 
    hpFileInfo  : ^_FILE_INFO;
    TextRoom   : _ROOM;
    uisize     : UDINT;
    szSize 	   : ARRAY [0..10] of _ASCII;  
    iNameWidth : INT;
    iTypWidth  : INT;
    iSizeWidth : INT;
    iDateWidth : INT;
  END_VAR
  
  
    	
  if(state = _TRUE) then
    color := Graphic.MakeColor(INVISIBLE, ps^.color_activ);
    color1 := Graphic.MakeColor(INVISIBLE,GetBackColor(ps^.color_activ));
  else
    color := Graphic.MakeColor(INVISIBLE, ps^.color_inactiv); 
    color1 := Graphic.MakeColor(INVISIBLE,GetBackColor(ps^.color_inactiv));
  end_if; 
  
  
  att := T_LEFTBOUND or T_MIDBOUND or T_COPY or T_SOLID or T_PROP; 
  
  	iNameWidth := (to_INT(Width.FileName));
	
	
		if biOutInfo.OutTyp = True then //PvO 20080107
			iTypWidth := (to_INT(Width.FileTyp));
    else
      iTypWidth := 0; //PvO 20080107
		end_if;

		if biOutInfo.OutSize = True then //PvO 20080107
			iSizeWidth := (to_INT(Width.FileSize));
    else
      iSizeWidth := 0; //PvO 20080107
		end_if;

		if biOutInfo.OutDate = True then //PvO 20080107
			iDateWidth := (to_INT(Width.FileDateTime));
    else
      iDateWidth := 0; //PvO 20080107
		end_if;


  
  Graphic.Beam(x1 := pr^.xy1.x, y1 := pr^.xy1.y, x2 := pr^.xy2.x, y2 := pr^.xy2.y, attrib := att, color := color1);
  
  if biOutInfo.OutHorizontalLines = True then
    Graphic.Line(x1:= pr^.xy1.x, y1:= pr^.xy2.y, x2:= pr^.xy2.x, y2:= pr^.xy2.y, attrib:=att, color:= LineColor);
  end_if;
  
  (*
      Graphic.Line(x1:= TextRoom.xy1.x-5, y1:= TextRoom.xy1.y, x2:= TextRoom.xy1.x-5, y2:= TextRoom.xy2.y, attrib:=att, color:=WHITE);
      Graphic.Line(x1:= TextRoom.xy1.x-5, y1:= TextRoom.xy1.y, x2:= TextRoom.xy1.x-5, y2:= TextRoom.xy2.y, attrib:=att, color:=WHITE);
      Graphic.Line(x1:= TextRoom.xy1.x-5, y1:= TextRoom.xy1.y, x2:= TextRoom.xy1.x-5, y2:= TextRoom.xy2.y, attrib:=att, color:=WHITE);
  *)    
  
  TextRoom := pr^;
  
  if biOutInfo.OutVerticalLines = True then
    if iNameWidth > 0 then      //PvO 20080107
      TextRoom.xy1.x += iNameWidth;
      Graphic.Line(x1:= TextRoom.xy1.x, y1:= TextRoom.xy1.y, x2:= TextRoom.xy1.x, y2:= TextRoom.xy2.y, attrib:=att, color:= LineColor);
    end_if;
    if iTypWidth > 0 then //PvO 20080107
      TextRoom.xy1.x += iTypWidth;
      Graphic.Line(x1:= TextRoom.xy1.x-5, y1:= TextRoom.xy1.y, x2:= TextRoom.xy1.x-5, y2:= TextRoom.xy2.y, attrib:=att, color:= LineColor);
    end_if;
    if iSizeWidth > 0 then //PvO 20080107
      TextRoom.xy1.x += iSizeWidth;
      Graphic.Line(x1:= TextRoom.xy1.x-5, y1:= TextRoom.xy1.y, x2:= TextRoom.xy1.x-5, y2:= TextRoom.xy2.y, attrib:=att, color:= LineColor);
    end_if;
  end_if;
  
  
  if Entries > Line & pFileInfo <> NIL then
 	
	 	hpFileInfo := sizeof(_FILE_INFO) * Line + pFileInfo;

    
    if hpFileInfo^.Attributes shr 4 and 2#00000001 = 1 then 
			if PicInfo.Dir > NIL then
				Graphic.BitMap(pr^.xy1.x+5,pr^.xy1.y+TO_INT(Width.LineHeight/2-PicInfo.Dir^.height/2),PicInfo.Dir,T_SOLID or T_COPY,0);    //Draw Direction-Picture
			end_if;
		elsif hpFileInfo^.Attributes >= 99 & hpFileInfo^.Attributes <= 110 then
			if PicInfo.Drive > NIL then
				Graphic.BitMap(pr^.xy1.x+5,pr^.xy1.y+TO_INT(Width.LineHeight/2-PicInfo.Drive^.height/2),PicInfo.Drive,T_SOLID or T_COPY,0);  //Draw Drive-Picture
			end_if;
		elsif hpFileInfo^.Attributes < 16 | hpFileInfo^.Attributes >= 32 then
			if PicInfo.File > NIL then
				Graphic.BitMap(pr^.xy1.x+5,pr^.xy1.y+TO_INT(Width.LineHeight/2-PicInfo.File^.height/2),PicInfo.File,T_SOLID or T_COPY,0);   //Draw File-Picture
			end_if;
		end_if;
    
    
    
    TextRoom := pr^;
    // write the name of the object   
    
    TextRoom.xy2.x := TextRoom.xy1.x + iNameWidth;
    TextRoom.xy1.x := TextRoom.xy1.x + TO_INT(Width.LineHeight);
    OutTextAlign(#hpFileInfo^.FileName[0],0,#TextRoom , ps^.font, att,_DEFFRAME,color,INVISIBLE,INVISIBLE, sizeof(_ASCII));
  
    // write the typ,size and attributes of the object
    if biOutInfo.OutTyp = True then
      TextRoom.xy1.x := TextRoom.xy2.x + 5;
      TextRoom.xy2.x := TextRoom.xy1.x + iTypWidth;
      
      
      if hpFileInfo^.Attributes shr 4 and 2#00000001 = 1 then 
          OutTextAlign("Directory",0,#TextRoom , ps^.font, att,_DEFFRAME,color,INVISIBLE,INVISIBLE, sizeof(_ASCII));		
  
      //Attributes = 99 Stand for Disk
      elsif hpFileInfo^.Attributes = 99 then
        if hpFileInfo^.Extension[1] = 1 then
          OutTextAlign("Floppy",0,#TextRoom , ps^.font, att,_DEFFRAME,color,INVISIBLE,INVISIBLE, sizeof(_ASCII));		
        elsif hpFileInfo^.Extension[1] = 7 then
          OutTextAlign("Hard Disk",0,#TextRoom , ps^.font, att,_DEFFRAME,color,INVISIBLE,INVISIBLE, sizeof(_ASCII));
        elsif hpFileInfo^.Extension[1] = 11 then
          OutTextAlign("USB Drive",0,#TextRoom , ps^.font, att,_DEFFRAME,color,INVISIBLE,INVISIBLE, sizeof(_ASCII));	
        elsif hpFileInfo^.Extension[1] = 15 then
          OutTextAlign("Flash-Card",0,#TextRoom , ps^.font, att,_DEFFRAME,color,INVISIBLE,INVISIBLE, sizeof(_ASCII));	        
        elsif hpFileInfo^.Extension[1] = 19 then
          OutTextAlign("Smartmedia",0,#TextRoom , ps^.font, att,_DEFFRAME,color,INVISIBLE,INVISIBLE, sizeof(_ASCII));	
        elsif hpFileInfo^.Extension[1] = 23 then
          OutTextAlign("RAM-Disk",0,#TextRoom , ps^.font, att,_DEFFRAME,color,INVISIBLE,INVISIBLE, sizeof(_ASCII));	
        end_if;
      elsif hpFileInfo^.Attributes < 16 | hpFileInfo^.Attributes >= 32 then
        OutTextAlign(#hpFileInfo^.Extension[0],0,#TextRoom , ps^.font, att,_DEFFRAME,color,INVISIBLE,INVISIBLE, sizeof(_ASCII));
        
      end_if;
    
    end_if;
  
    //Output the Size of the File
    if biOutInfo.OutSize = True then
      TextRoom.xy1.x := TextRoom.xy2.x;
      TextRoom.xy2.x := TextRoom.xy1.x + iSizeWidth;
            
      if (hpFileInfo^.Attributes < 16) | (hpFileInfo^.Attributes >= 32) & (hpFileInfo^.Attributes < 99) then 
        
        uiSize := 	hpFileInfo^.FileSize / 1024;
        DToA(#szSize[0], to_DINT(uiSize), 0x0800, sizeof(_ASCII));
        
        StrCat(#szSize[0],sizeof(_ASCII)," kb   ",sizeof(_ASCII));
        att := T_RIGHTBOUND or T_MIDBOUND or T_COPY or T_SOLID or T_PROP; 
        OutTextAlign(#szSize[0],0,#TextRoom , ps^.font, att,_DEFFRAME,color,INVISIBLE,INVISIBLE, sizeof(_ASCII)); 
       end_if;
       
    end_if;
    
    
    att := T_RIGHTBOUND or T_MIDBOUND or T_COPY or T_SOLID or T_PROP;//DH 
    
    //Output the Date
    if biOutInfo.OutDate = True then
      TextRoom.xy1.x := TextRoom.xy2.x;
      TextRoom.xy2.x := TextRoom.xy1.x + iDateWidth;
      
      
      if (hpFileInfo^.Attributes < 99) then	
        
        DateTime(hpFileInfo^.DateTime);
        OutTextAlign(#DateTimeString[0],0,#TextRoom , ps^.font, att,_DEFFRAME,color,INVISIBLE,INVISIBLE, sizeof(_ASCII)); 
      end_if;
    end_if;	

  end_if;
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL easyFileList::IF_End

  //Realloc Space
  Graphic.Memory(#pFileInfo, 0);
  FileString.Clear();
  toOpenFileString.clear();
  
  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL easyFileList::IF_Start
	VAR_INPUT
		pio 	: ^_IO;
		firsttime 	: BOOL;
	END_VAR
  
  
  _ScrollArea::IF_START(pio,firsttime);
  
  //Allcoate Space for Displaying Files
  pFileInfo := NIL;
  dMemNo:= 50;
	Graphic.Memory(#pFileInfo,sizeof(_FILE_INFO)*to_UDINT(dMemNo)); //Hier wordt het pfileinfo gezet
  
  initdrives :=0; //HvZ check for changed drives
  if pFileInfo <> NIL then
    ReadFiles();
  end_if;
  
  
  GetUDCParam(pio);



END_FUNCTION



FUNCTION VIRTUAL GLOBAL easyFileList::ReadFiles

   VAR
    hpFileInfo  : ^_FILE_INFO;
    aFilename   : ARRAY[0..255] of _ASCII;  
    aFilenameTmp   : ARRAY[0..255] of _ASCII;  
    FileAttrib  : USINT;
    aHelpPath   : ARRAY[0..200] of _ASCII;
    dFile       : DINT;
    dFileVorh   : DINT;
    finfo       : _DDE_INFO;
    StringLen   : UDINT;
    hStringLen  : UDINT;
    aFilter     : ARRAY[0..15] of _ASCII;
    ExtensionLen  : UDINT;
    i           : USINT;
    DriveName   : ARRAY[0..4] of _ASCII;
  END_VAR
    
  
  ExtensionLen := ExtensionFilter.GetLength();
  
//  StrCpy(#aFilter[0],sizeof(_ASCII),"     ",sizeof(_ASCII));  
  _memset(dest:=#aFilter[0], usByte:=0, cntr:=sizeof(aFilter));
  
  ExtensionFilter.ReadDataOff(0, #aFilter[0], ExtensionLen);  
  _strupr(#aFilter[0]);   //The Filter is written with a capital  
//  aFilter[4] := 0;
    
  PathLen := PathString.GetLength();  
  PathString.ReadDataOff(0, #aPath[0], PathLen);  
  aPath[PathLen] := 0;
  
  StringCRC := PathString.GetCRC();

  FileAttrib := 0x08;
  
  StrCpy(#aHelpPath[0],sizeof(_ASCII),#aPath[0],sizeof(_ASCII));
  StrCat(#aHelpPath[0],sizeof(_ASCII),"*.*",sizeof(_ASCII));
  
  
  dFileVorh := 0;
  Entries := 0;	

if PathLen > 0 then

  if biOutInfo.OutFolders = TRUE then //Hier worden de directories ingelezen

    dFile := FileIO.FindFirstEX(#aHelpPath[0],0,FileAttrib, #finfo,#aFileName[0],255); 
  
    while dFileVorh >= 0 & dFile >= 0 do  
     
      udTest := Graphic.Memory(#pFileInfo,sizeof(_FILE_INFO)*to_UDINT(dMemNo));
      // if more entries then memory allocked then reallock 
      if Entries + 1 >= dMemNo then
        dMemNo += 10;
        if Graphic.Memory(#pFileInfo,sizeof(_FILE_INFO)*to_UDINT(dMemNo)) = 0 then
          Trace("No Space for Displaying Files available");
          Exit;
        end_if;
      end_if;
      
        //Check if Entry is a Folder
        if finfo.FileName[0] <> 46 & finfo.Attributes shr 4 and 2#00000001 = 1 then	  //directory    
          hpFileInfo := sizeof(_FILE_INFO)* Entries + pFileInfo;
          StrCpy(#hpFileInfo^.FileName[0],sizeof(_ASCII),#aFileName[0],sizeof(_ASCII));        
          StrCpy(#hpFileInfo^.Extension[0],sizeof(_ASCII),#finfo.Extension[0],sizeof(_ASCII));
          hpFileInfo^.Attributes := finfo.Attributes;
          hpFileInfo^.FileSize := finfo.FileSize;
          hpFileInfo^.DateTime := finfo.DateTime;
          Entries += 1;
        end_if;
       
     
      dFileVorh := FileIO.FindNextEX(dFile,#finfo,#aFileName[0],255);
    end_while;
    FileIO.FindClose(dfile);
  
  end_if;
  
  if biOutInfo.OutFiles = TRUE then //hier de files
  
    dFile := FileIO.FindFirstEX(#aHelpPath[0],0,FileAttrib, #finfo,#aFileName[0],255);
    dFileVorh := 0;     
    
    lFilter := strlen(#aFilter[0],sizeof(_ASCII));    
    aFilter[lFilter] :=0;
    
    while dFileVorh >= 0 & dFile >= 0 do
      // if more entries then memory allocked then reallock 
      if Entries + 1 >= dMemNo then
        dMemNo += 10;
        Graphic.Memory(#pFileInfo,sizeof(_FILE_INFO)*to_UDINT(dMemNo));
      end_if;    
        
        //Check if Entry is a File
        if (finfo.Attributes = 32) then   
          lFileName := strlen(#aFileName[0],sizeof(_ASCII));
 
          
          _strcpy(dest:=#aFileNameTmp[0], src:=#aFileName[0]);
          aFileNameTmp[lFilter] := 0;
          _strupr(#aFileNameTmp[0]);   //The File name to Capital 
          
 //         if (StrCmp(#finfo.Extension[0], sizeof(_ASCII), #aFilter[0], sizeof(_ASCII)) = 0) | ExtensionLen = 0 then        
          if (StrCmp(#aFileNameTmp[0], sizeof(_ASCII), #aFilter[0], sizeof(_ASCII)) = 0) | ExtensionLen = 0 then 
          
            hpFileInfo := sizeof(_FILE_INFO)* Entries + pFileInfo;
            StrCpy(#hpFileInfo^.FileName[0],sizeof(_ASCII),#aFileName[0],sizeof(_ASCII));
            StringLen := strlen(#aFileName[0],sizeof(_ASCII));
            hStringLen := StrChr(#hpFileInfo^.FileName[0],'.',sizeof(_ASCII));
  //hvz        if hStringLen < StringLen then
  //Hier werd gezocht naar een punt in de filename, zo niet -> niet in de lijst.
  //Jammer voor files zonder extensie!
  //            if hStringLen > 0 then  //als er wel een punt in zat, verwijderen
  //                    verbetering Support, hstringlen geeft soms 65535 terug
              if (hStringLen > 0) & (hStringLen <  sizeof(hpFileInfo^.FileName)) then  
                hpFileInfo^.FileName[hStringLen] := 0;
              end_if;
              StrCpy(#hpFileInfo^.Extension[0],sizeof(_ASCII),#finfo.Extension[0],sizeof(_ASCII));
              hpFileInfo^.Extension[3] :=0;
              hpFileInfo^.Attributes := finfo.Attributes;
              hpFileInfo^.FileSize := finfo.FileSize;
              hpFileInfo^.DateTime := finfo.DateTime;
              Entries += 1;
   //hvz         end_if;
          end_if;
        end_if;
    
        
      dFileVorh := FileIO.FindNextEX(dFile,#finfo,#aFileName[0],255);
    end_while;
    
    
    FileIO.FindClose(dfile);
  end_if;
 
 
 
////******************** HvZ
//  if (AltDirAct = 0) & (StartPathLen > 0) & (PathLen = StartPathLen) then
//    for i := 3 to 26 do
// //(*     alleen USB
//      if aDrives[i] <> 0 then             //Check if a Drive was found     
//        hpFileInfo := sizeof(_FILE_INFO)* Entries + pFileInfo;
//        
//        DriveName[0] := 65+i;             //Write Drive Letter
//        DriveName[1] := 0;      
//        StrCat(#Drivename[1],sizeof(_ASCII),":",sizeof(_ASCII));      
//        DriveName[2] := 0;      
//        
//        StrCpy(#hpFileInfo^.FileName[0],sizeof(_ASCII),#DriveName[0],sizeof(_ASCII));          
//        hpFileInfo^.Attributes := 99;             //Write Attributes= 99 for Identification
//        hpFileInfo^.Extension[1] := aDrives[i];   //Write Information about the Drive-Type 
//              
//        Entries += 1;
//        
//      end_if;
// // *)    
//    end_for;    
//  end_if;
////********************

else

  for i := 0 to 26 do
    
    if aDrives[i] <> 0 then             //Check if a Drive was found     
      hpFileInfo := sizeof(_FILE_INFO)* Entries + pFileInfo;
      
      DriveName[0] := 65+i;             //Write Drive Letter
      DriveName[1] := 0;      
      StrCat(#Drivename[1],sizeof(_ASCII),":",sizeof(_ASCII));      
      DriveName[2] := 0;      
      
      StrCpy(#hpFileInfo^.FileName[0],sizeof(_ASCII),#DriveName[0],sizeof(_ASCII));          
      hpFileInfo^.Attributes := 99;             //Write Attributes= 99 for Identification
      hpFileInfo^.Extension[1] := aDrives[i];   //Write Information about the Drive-Type 
            
      Entries += 1;
      
    end_if;
  end_for;    

end_if;
  
  Refresh := TRUE;
  LetsDraw := TRUE;

//  DrawBeam := TRUE;

END_FUNCTION



FUNCTION __CDECL VIRTUAL GLOBAL easyFileList::GetEvent
	VAR_INPUT
		ped 	: ^_EDITOR;
		pe 	: ^_EVENT;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  
VAR
  doit : BOOL; 
	eat : BOOL;
END_VAR

  retcode := _IDLE; 

  if(Focus = TRUE) then
    eat := false; 
    if(pe^.ftype = _EVENT_KEYPRESS) then
	  doit := FALSE; 
      case pe^.scancode of
		_UP   : if(Scroll.position.pos > 0) then
		          doit := TRUE; 
                end_if; 
		_DOWN : if(Scroll.position.pos < (Scroll.position.no - 1)) then
				  doit := TRUE; 
                end_if; 
        _RIGHT: if(Scroll.hlevel.active = TRUE) then
		          if(Scroll.hposition.pos < (Scroll.hposition.no - 1)) then
//				    Scroll.hposition.pos += (Scroll.out_room.xy2.x - Scroll.out_room.xy1.x) / 4; 
                    pe^.scancode := _PGRIGHT; 
                    doit := TRUE; 
                  end_if; 
                end_if; 
        _LEFT : if(Scroll.hlevel.active = TRUE) then
		          if(Scroll.hposition.pos > 0) then
//                    Scroll.hposition.pos -= (Scroll.out_room.xy2.x - Scroll.out_room.xy1.x) / 4; 
                    pe^.scancode := _PGLEFT; 
                    doit := TRUE; 
                  end_if; 
		        end_if; 
        _PGLEFT, 
        _PGRIGHT, 
        _PGUP, 
		_PGDOWN : doit := TRUE; 
    
    _ENTER:
          OpenFile();
    
    
      end_case; 
    elsif(pe^.ftype = _EVENT_SHUTTLEDEC) then
      if(Scroll.position.pos > 0) then
        doit := TRUE; 
        eat  := TRUE;
      end_if; 
    elsif(pe^.ftype = _EVENT_SHUTTLEINC) then
      if(Scroll.position.pos < (Scroll.position.no - 1)) then
        doit := TRUE; 
        eat  := TRUE;
      end_if; 
	else
	  doit := TRUE; 
      if((pe^.ftype = _EVENT_HIDMOVE)&(FocusJustGiven = TRUE)) then
        if((pe^.dot.x >= Scroll.out_room.xy1.x)&(pe^.dot.x <= Scroll.out_room.xy2.x)&
           (pe^.dot.y >= Scroll.out_room.xy1.y)&(pe^.dot.y <= Scroll.out_room.xy2.y)) then
 	      pe^.ftype := _EVENT_HIDPRESS; 
		  eat       := TRUE; 
        end_if; 
	  end_if;   
	end_if; 

    FocusJustGiven := FALSE; 

    if(doit = TRUE) then
      Run_SCROLL(#Scroll, pe);

      case(pe^.ftype) of
        _EVENT_KEYPRESS   : eat := TRUE; 
        
  //        if ScrollPosition = scroll.position.pos & (pe^.scancode <> _UP) & (pe^.scancode <> _DOWN) & (pe^.scancode <> _LEFT) & (pe^.scancode <> _RIGHT) then
          if (pe^.scancode <> _UP) & (pe^.scancode <> _DOWN) 
            & (pe^.scancode <> _LEFT) & (pe^.scancode <> _RIGHT) 
             & (pe^.scancode <> _PGDOWN) & (pe^.scancode <> _PGUP) 
              then
  //          ScrollPosition := -1;
            ScrollPosition := scroll.position.pos;
            OpenFile();
          else
            ScrollPosition := scroll.position.pos;
          end_if;          
  //        end_if;
  
        _EVENT_HIDPRESS, 
        _EVENT_HIDMOVE, 
        _EVENT_HIDRELEASE : if((pe^.dot.x >= Scroll.out_room.xy1.x)&(pe^.dot.x <= Scroll.out_room.xy2.x)&
                                   (pe^.dot.y >= Scroll.out_room.xy1.y)&(pe^.dot.y <= Scroll.out_room.xy2.y)) then
                                  eat := TRUE; 
                                end_if;  

      end_case; 
  


	  if(eat = TRUE) then
        init_EVENT(pe);     // eat event
	    retcode := _IDIDIT;
      end_if; 
    end_if; 
  end_if;
  
  //Looking for Drives
  if (pe^.ftype = _EVENT_LASALOS) then
    _memset(#aDrives[0], 16#00, sizeof(aDrives));
    FileIO.GetDriveListShort(#aDrives[0]);
    PathString.WriteDataOff(StartPAthLen, 0, #StartPath[0]);
    AltDirAct :=0;
 //   PathString.WriteDataOff(0,0,"");
    ReadFiles();
  end_if;
  
  
  
END_FUNCTION





FUNCTION __CDECL VIRTUAL GLOBAL easyFileList::Out
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
  
  Scroll.position.no := Entries;
  ResetPosition();  
  
  _ScrollArea::Out(pio);

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL easyFileList::IF_Run
	VAR_INPUT
		pio 	: ^_IO;
		input 	: BOOL;
	END_VAR

  
  if(Focus = TRUE) then
    if(DrawBeam = TRUE) then
      ActBeam_SCROLL(#Scroll, TRUE);  
	  DrawBeam := FALSE; 
    end_if;

    Run_SCROLL(#Scroll, NIL);
  end_if;
  
  if InitDrives = 0 then
    FileIO.GetDriveListShort(#aDrives[0]);
    ReadFiles();
    InitDrives := 1;
  end_if;
  
  if DirectoryBack = 1 then
    DirectoryBack := 0;
    DirBack();      //Get back to the former Path
  end_if;  

  
  //If PathString is changed: ReadFiles
  if StringCRC <> PathString.GetCRC() then
    ReadFiles();
  end_if;
  



END_FUNCTION



FUNCTION GLOBAL easyFileList::GetUDCParam
	VAR_INPUT
		pio 	: ^_IO;
	END_VAR
    
  VAR
    pVar : ^_VARLABEL;
    pBool : ^BOOL;
    pColor : ^_COLOR;
  END_VAR;
  
  
  
  // Get Imagedata from UDC
  if pio^.theurge^.memanything.no >= 0 then
    PicInfo.Drive$^void := get_ANYTHING(pio^.theurge^.memanything.ptr,NIL);
  end_if;
  if pio^.theurge^.memanything.no >= 1 then
    PicInfo.Dir$^void := get_ANYTHING(pio^.theurge^.memanything.ptr + (sizeof(_ANYTHING)*1),NIL);
  end_if;
  if pio^.theurge^.memanything.no >= 2 then
    PicInfo.File$^void := get_ANYTHING(pio^.theurge^.memanything.ptr + (sizeof(_ANYTHING)*2),NIL);
  end_if;
  if pio^.theurge^.memanything.no >= 3 then
    PicInfo.ScrollImage$^void := get_ANYTHING(pio^.theurge^.memanything.ptr + (sizeof(_ANYTHING)*3),NIL);
  end_if;
 
  
  // Get variable data from UDC
  if pio^.theurge^.memvarlabel.no >= 0 then
    pVar := pio^.theurge^.memvarlabel.ptr + (sizeof(_VARLABEL)*0);
    if pVar^.info[0].state = 2 then
      Width.FileName := pVar^.info[0].value;
    elsif pVar^.info[0].state = 1 then
      Lse.VarLst_GetValueByNo(to_UDINT(pVar^.info[0].value),#Width.FileName,1);
    end_if;
  end_if;
  if pio^.theurge^.memvarlabel.no >= 1 then
    pVar := pio^.theurge^.memvarlabel.ptr + (sizeof(_VARLABEL)*1);
    if pVar^.info[0].state = 2 then
      Width.FileTyp := pVar^.info[0].value;
    elsif pVar^.info[0].state = 1 then
      Lse.VarLst_GetValueByNo(to_UDINT(pVar^.info[0].value),#Width.FileTyp,1);
    end_if;
  end_if;
  if pio^.theurge^.memvarlabel.no >= 2 then
    pVar := pio^.theurge^.memvarlabel.ptr + (sizeof(_VARLABEL)*2);
    if pVar^.info[0].state = 2 then
      Width.FileSize := pVar^.info[0].value;
    elsif pVar^.info[0].state = 1 then
      Lse.VarLst_GetValueByNo(to_UDINT(pVar^.info[0].value),#Width.FileSize,1);
    end_if;
  end_if;
  if pio^.theurge^.memvarlabel.no >= 3 then
    pVar := pio^.theurge^.memvarlabel.ptr + (sizeof(_VARLABEL)*3);
    if pVar^.info[0].state = 2 then
      Width.FileDateTime := pVar^.info[0].value;
    elsif pVar^.info[0].state = 1 then
      Lse.VarLst_GetValueByNo(to_UDINT(pVar^.info[0].value),#Width.FileDateTime,1);
    end_if;
  end_if;
  if pio^.theurge^.memvarlabel.no >= 4 then
    pVar := pio^.theurge^.memvarlabel.ptr + (sizeof(_VARLABEL)*4);
    if pVar^.info[0].state = 2 then
      Width.LineHeight := pVar^.info[0].value;
    elsif pVar^.info[0].state = 1 then
      Lse.VarLst_GetValueByNo(to_USINT(pVar^.info[0].value),#Width.LineHeight,1);
    end_if;
  end_if;
  
  LineWidth := Width.FileName + Width.FileTyp + Width.FileSize + Width.FileDateTime;
  
  // Out Filetype
  if pio^.theurge^.membool.no >= 0 then
    pBool := pio^.theurge^.membool.ptr + 0;
    biOutInfo.OutTyp := pBool^;
  end_if;
  // Out filesize
  if pio^.theurge^.membool.no >= 1 then
    pBool := pio^.theurge^.membool.ptr + 1;
    biOutInfo.OutSize := pBool^;
  end_if;
  // Out filedate
  if pio^.theurge^.membool.no >= 2 then
    pBool := pio^.theurge^.membool.ptr + 2;
    biOutInfo.OutDate := pBool^;
  end_if;
  
    //Out Vertical Lines
  if pio^.theurge^.membool.no >= 3 then
    pBool := pio^.theurge^.membool.ptr + 3;
    biOutInfo.OutVerticalLines := pBool^;
  end_if;
  //Out Horizontal Lines
  if pio^.theurge^.membool.no >= 4 then
    pBool := pio^.theurge^.membool.ptr + 4;
    biOutInfo.OutHorizontalLines := pBool^;
  end_if;
  
  //Out Folders
  if pio^.theurge^.membool.no >= 5 then
    pBool := pio^.theurge^.membool.ptr + 5;
    biOutInfo.OutFolders := pBool^;
  end_if; 
  //Out Files
  if pio^.theurge^.membool.no >= 6 then
    pBool := pio^.theurge^.membool.ptr + 6;
    biOutInfo.OutFiles := pBool^;
  end_if;
  
  //LineColor
  if pio^.theurge^.memcolor.no >= 0 then
    pColor := pio^.theurge^.memcolor.ptr;
    LineColor := pColor^;
  end_if;

END_FUNCTION






FUNCTION easyFileList::DateTime
	VAR_INPUT
		DateTime 	: _DDE_DATIM;
	END_VAR

VAR
	minutes : UDINT;	
	hour : UDINT;
	day : UDINT;
	Month : UDINT;
	Year : UDINT;
	
END_VAR;


	// read date time data
	Year    := (DateTime.DateTime AND 2#11111110000000000000000000000000) shr 25;
	Year += 1980;
	Month   := (DateTime.DateTime AND 2#00000001111000000000000000000000) shr 21;
	Day  	:=   (DateTime.DateTime AND 2#00000000000111110000000000000000) shr 16;
	Hour    := (DateTime.DateTime AND 2#00000000000000001111100000000000) shr 11;
	Minutes := (DateTime.DateTime AND 2#00000000000000000000011111100000) shr 5;
	
	//write date time data in a string
	if Day < 10 then	
		DtoA(#DateTimeString[1],to_DINT(Day), 0x0800,sizeof(_ASCII));
		DateTimeString[0] := '0';
	else	
		DtoA(#DateTimeString[0],to_DINT(Day), 0x0800,sizeof(_ASCII));
	end_if;
	DateTimeString[2] := '.';

	if Month < 10 then	
		DtoA(#DateTimeString[4],to_DINT(Month), 0x0800,sizeof(_ASCII));
		DateTimeString[3] := '0';
	else	
		DtoA(#DateTimeString[3],to_DINT(Month), 0x0800,sizeof(_ASCII));
	end_if;
	DateTimeString[5] := '.';

	DtoA(#DateTimeString[6],to_DINT(Year), 0x0800,sizeof(_ASCII));
	DateTimeString[10] := 32;
	DateTimeString[11] := 32;
	
	if Hour < 10 then	
		DtoA(#DateTimeString[13],to_DINT(Hour), 0x0800,sizeof(_ASCII));
		DateTimeString[12] := '0';
	else	
		DtoA(#DateTimeString[12],to_DINT(Hour), 0x0800,sizeof(_ASCII));
	end_if;
	DateTimeString[14] := ':';
	
	if Minutes < 10 then	
		DtoA(#DateTimeString[16],to_DINT(Minutes), 0x0800,sizeof(_ASCII));
		DateTimeString[15] := '0';
	else	
		DtoA(#DateTimeString[15],to_DINT(Minutes), 0x0800,sizeof(_ASCII));
	end_if;

	DateTimeString[17] := 0;

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL easyFileList::InitScroll
	VAR_INPUT
		pio 	: ^_IO;
		vno 	: UINT;
	END_VAR
  
  _ScrollArea::InitScroll(pio, vno);
  
  if PicInfo.ScrollImage <> NIL then
    Scroll.Image := PicInfo.ScrollImage;
  end_if;
  
  Scroll.NoClrscr := TRUE;
  
  Scroll.line_height := TO_UINT(Width.LineHeight);
  Scroll.Position.Height := TO_UINT((scroll.scroll_room.xy2.y - scroll.scroll_room.xy1.y) / scroll.line_height);
  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL easyFileList::Draw
	VAR_INPUT
		pio 	: ^_IO;
		pr 	: ^_RESULT;
		pv 	: ^_VARIABLE;
		input 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  
  //Draw a Background-Beam
  Graphic.Beam(x1 := pio^.room.xy1.x, y1 := pio^.room.xy1.y, x2 := pio^.room.xy2.x, y2 := pio^.room.xy2.y, T_LEFTBOUND or T_MIDBOUND or T_COPY or T_SOLID or T_PROP, pio^.colback);

  if((LetsDraw = TRUE)|(IsDrawBackGround() = TRUE)) then 
    LetsDraw := FALSE; 
    Out(pio); 
    InsertCmd(x0:=CMD_OUTSOFTKEY, x1:=0, x2:=0);  //HvZ, dus niet meer softkey levels gebruiken.
  end_if; 
  retcode := _IDIDIT; 
  
END_FUNCTION


FUNCTION GLOBAL easyFileList::ResetPosition

  Scroll.position.begin := 0;
  Scroll.position.pos := 0;
  Scroll.position.oldpos := 0;

END_FUNCTION


FUNCTION GLOBAL easyFileList::OpenFile

VAR
	hpFileInfo : ^_FILE_INFO;
  NameLen :UDINT;
END_VAR


  hpFileInfo := sizeof(_FILE_INFO) * scroll.position.pos + pFileInfo;
           
  for NameLen:= 0 to 255 do
    if  hpFileInfo^.FileName[NameLen]= 0 then
      Exit;
    end_if;
  end_for;
  
  if Namelen + pathlen < 255 then  
    FileString.WriteDataOff(NameLen,0,#hpFileInfo^.FileName[0]);
  
  
    if hpFileInfo^.Attributes = 32 then
      FileString.WriteDataOff(1,NameLen,".");
      FileString.WriteDataOff(3,NameLen+1,#hpFileInfo^.Extension[0]);
      drawbeam := true;//hvz
    end_if;
  
  
    if StartPathLen > 0 & hpFileInfo^.Attributes = 99 then  //hvz
      PathString.WriteDataOff(2, 0, #hpFileInfo^.FileName[0]);
      PathString.WriteDataOff(1,2,"\");
      AltDirAct :=1;    //We zitten op een andere drive
    else  //hvz
      if ((hpFileInfo^.Attributes shr 4 and 2#00000001 = 1)| (hpFileInfo^.Attributes =99)) & (Entries > 0) then                
        PathString.WriteDataOff(NameLen, PathLen, #hpFileInfo^.FileName[0]);
        PathString.WriteDataOff(1,NameLen+Pathlen,"\");
      end_if;
      if hpFileInfo^.Attributes = 32 then
        toOpenFileString.WriteDataOff(PathLen, 0, #aPath[0]);
        toOpenFileString.WriteDataOff(NameLen,Pathlen,#hpFileInfo^.FileName[0]);
    //HvZ aangepast voor files zonder extensie    
        if hpFileInfo^.Extension[0] <> 32 then
          toOpenFileString.WriteDataOff(1,NameLen+Pathlen,".");
          toOpenFileString.WriteDataOff(3,NameLen+1+Pathlen,#hpFileInfo^.Extension[0]);
        end_if;
        UserDefinedAction();
      end_if;
    end_if; //hvz
  end_if;

END_FUNCTION



FUNCTION GLOBAL easyFileList::DirBack

VAR
  i   : UDINT;
  aFilePath : ARRAY [0..255] of _ASCII;
  PathLen : UDINT;
END_VAR


PathLen := PathString.GetLength();
PathString.ReadDataOff(0,#aFilePath[0], PathLen);

if Pathlen = 3 & AltDirAct then
  AltDirAct :=0;
  PathString.WriteDataOff(StartPAthLen, 0, #StartPath[0]);
  ReadFiles();
else



if (Pathlen > StartPathLen) | AltDirAct then  //HvZ
  for i := 2 to PathLen + 1 do
    if aFilePath[PathLen-i] = 92 then
      aFilePath[PathLen-(i-1)] := 0;    
      PathString.WriteDataOff(PathLen-(i-1), 0, #aFilePath[0]);
      Exit;  
    elsif i > PathLen then
      aFilePath[0] := 0;
      PathString.WriteDataOff(0, 0, #aFilePath[0]);
      ReadFiles();
    end_if;
  end_for;
end_if;
end_if;

END_FUNCTION


FUNCTION GLOBAL easyFileList::UserDefinedAction

  cToolCatLoadInfo :=1;
  cToolCatLoadInfo.write(cToolCatLoadInfo);
  
END_FUNCTION




FUNCTION VIRTUAL GLOBAL easyFileList::RefreshFiles::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	RefreshFiles := input;
  readfiles();
 	result := RefreshFiles;
  //functie toetsen
//  InsertCmd(x0:=CMD_OUTSOFTKEY, x1:=0, x2:=0);

END_FUNCTION
