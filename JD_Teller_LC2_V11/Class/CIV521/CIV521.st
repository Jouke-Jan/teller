//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "CIV521"
	Revision           = "1.61"
	GUID               = "{67820AB9-7BB7-4BE0-90BA-F5F5286EC6DB}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\C-DIAS_16x16.ico"
	SharedCommandTable = "true"
	Objectsize         = "(590,120)"
	Comment            = "class for CIV521 hardwaremodule (C-DIAS Power Supply and connection interface to VARAN) &#13;&#10;with possibility of using the Data Mover (intelligent management of connected CDIAS modules, &#13;&#10;which reduces busload significantly but slightly increases reaction time)&#13;&#10;&#13;&#10;Inferfaces:&#13;&#10;C-DIAS, DIAS, CAN Bus, RS232, RS422/485 and TTY interface">
	<Channels>
		<Server Name="Can_Enabled" GUID="{28B557CF-C82F-4EF9-9D09-8B8432461A01}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="With this server, the CAN controller can be enabled or disabled over the ISO CAN interface. 0: Disable CAN controller, 1: Enable CAN controller"/>
		<Server Name="CanError" GUID="{8FC5E8DC-3BE5-41F7-9F6B-534034F36E6A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server increments when a Can handler error occurs"/>
		<Server Name="CanInterfaceOS" GUID="{9B7F62BD-430D-4F98-83D5-B6D7428F67E9}" Class="_CanLib" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Connect a object client"/>
		<Server Name="CanIsoError" GUID="{600D34D8-EA85-40FA-A049-3EB666C4F94C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This error counter increments when the isochronous CAN Tx objects could not be sent in the defined time"/>
		<Server Name="CanStdInterfaceISO" GUID="{ECE05FB2-AD7D-41E5-A1A5-C02C32F63DA5}" Class="_CanLib" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Connect a object client"/>
		<Server Name="CDIAS" GUID="{C550B6C1-DA41-4DE6-AE26-299B569A82E5}" Class="DiasMaster" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="All C-DIAS hardware classes used must be connected to this server."/>
		<Server Name="Com1" GUID="{8BEF8B67-1F18-4A07-882A-CCC77B6AB01E}" Class="_SerLib" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="RS485/422 interface"/>
		<Server Name="Com2" GUID="{3B8993DD-8753-48A9-8515-E038948D8EA0}" Class="_SerLib" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="RS232 interface"/>
		<Server Name="Com3" GUID="{6E07554F-0E9F-4F8A-B7C6-4FE355857FD8}" Class="_SerLib" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="TTY interface"/>
		<Server Name="DIAS" GUID="{0F562D81-375F-40BD-A684-A41CB95A092A}" Class="DiasMasterC" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="All DIAS hardware classes used must be connected to this server."/>
		<Server Name="DiasErrorPlace" GUID="{1A706394-EE70-483F-8E5C-04922460CA4C}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the place of the modul, where the DiasError occured"/>
		<Server Name="DIASRetryCounter" GUID="{263300D6-CE3B-4398-A73A-BABC57930ECD}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the number of retrys on the diasbus"/>
		<Server
			Name           = "RetryCounter"
			Initialize     = "false"
			Visualized     = "true"
			WriteProtected = "true"
			Comment        = "retry counter of varan module">
		</Server>
		<Server Name="VaranOut_1" GUID="{2311A358-CC1E-4DA3-A620-4DDC03FCA3E4}" Class="Hub_Base" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="The VARAN hardware classes are connected to this server over the “VaranIn” client. Each port can only have one client connected."/>
		<Client Name="_VaranCanLib" Required="true" Internal="true"/>
		<Client Name="_VaranCanLibOS" Required="true" Internal="true"/>
		<Client Name="_VaranSerLibOS0" Required="true" Internal="true"/>
		<Client Name="_VaranSerLibOS1" Required="true" Internal="true"/>
		<Client Name="_VaranSerLibOS2" Required="true" Internal="true"/>
		<Client Name="CallUserRt" Required="false" Internal="false" Comment="connected server is called bevore Tx Data is write to varan"/>
		<Client Name="CDias2DataMover" Required="true" Internal="true"/>
		<Client Name="Dias2DataMover" Required="true" Internal="true"/>
		<Client Name="Hub_Base0" Required="true" Internal="true"/>
		<Client Name="ISOCanOn" Required="false" Internal="false" Comment="0=ISO Can off (no varan DOs are needed), 1=ISO Can on"/>
		<Client Name="MoverActive" Required="true" Internal="false" DefValue="1" Comment="set init-value to deactivate/activate mover usage&#13;&#10;&#13;&#10;0..Communication without mover (more busload but faster reaction of single modules)&#13;&#10;1..Communication with mover (less busload but slower reaction of single modules, because civ manages communication of connected modules)"/>
		<Client Name="Pll_Prescaler" Required="false" Internal="false" Comment="prescaler of varan time for ISO Tx Can Objects (0,1=sending objects in varan time, 2=sending in varan time multiplied by 2, 3=sending in varan time multplied by 3,...)"/>
		<Client Name="Varan_Can" Required="true" Internal="true"/>
		<Client Name="Varan_DataMover" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="renste"/>
		<Dokumentation Revision="1.61" Date="07.05.2014" Author="LanSte" Company="Sigmatek" Description="Improved Transparent property description in HW-Tree and activated greying out of the object in the HW-Tree.&#13;&#10;Minimized the interface request via CILGET by useing private pointers to reduce time in init."/>
		<Dokumentation Revision="1.60" Date="12.02.2014" Author="PieSte" Company="Sigmatek" Description="Add read Client MoverActive in Init to set value with connected server."/>
		<Dokumentation Revision="1.50" Date="04.12.2013" Author="ZoePat&#13;&#10;LanSte" Company="Sigmatek" Description="Moved DirectAccess to start the ISO-List from first RT-run to Varan_Callback, to prevent a TimeSliceError at startup.&#13;&#10;Added payload support"/>
		<Dokumentation Revision="1.40" Date="05.11.2012" Author="RamAnd" Company="Sigmatek" Description="Corrected FlexHub Plug&apos;n&apos;Play functionality for modules with CDIAS Interface"/>
		<Dokumentation Revision="1.30" Date="18.07.2012" Author="ObeChr" Company="Sigmatek" Description="Implemented time measurement for internal tests in methods UpdateRt, UpdateRtPostScan and UpdateCy"/>
		<Dokumentation Revision="1.29" Date="16.01.2012" Author="ZoePat" Company="Sigmatek" Description="Added Server DiasErrorPlace from embedded object Dias2DataMover&#13;&#10;Call Client UserAction at Dias-Error (VARANMANAGER_CB_DIAS_ERROR)"/>
		<Dokumentation Revision="1.28" Date="01.06.2011" Author="RamAnd" Company="Sigmatek" Description="If CDIAS-Mover is disabled, the CDIAS modules now get the CDIAS Sync with the VARAN-Sync and no longer with the Rt-Sync of the PLC.&#13;&#10;FPGA version must be 2.4 or greater to get the correct behavior as described."/>
		<Dokumentation Revision="1.27" Date="12.05.2011" Author="RamAnd" Company="Sigmatek" Description="Don&apos;t wait for the mover to be finished with asychron code, if there is no code. Otherwise no cyclic update methods of connected objects are called."/>
		<Dokumentation Revision="1.26" Date="10.05.2011" Author="RamAnd" Company="Sigmatek" Description="Retrycounter of DIAS is now also available on plattforms with no intelligent master."/>
		<Dokumentation Revision="1.25" Date="04.01.2011" Author="BleErn" Company="Sigmatek" Description="Added Client Transparent that allows to disable a VARAN-HW-Class"/>
		<Dokumentation Revision="1.24" Date="10.12.2010" Author="RamAnd" Company="Sigmatek" Description="Corrected RetryCounter handling and removed it for the internal move command."/>
		<Dokumentation Revision="1.23" Date="17.11.2010" Author="WocPet" Company="Sigmatek" Description="Initialisation has been adapted for CDIAS and DIAS modules, which can now cause a required error."/>
		<Dokumentation Revision="1.22" Date="17.11.2010" Author="WocPet" Company="Sigmatek" Description="Functionality for DIAS-modul retrycounter implemented"/>
		<Dokumentation Revision="1.21" Date="04.11.2010" Author="RamAnd" Company="Sigmatek" Description="If the module has been disconnected from VARAN, it was still possible to start a direct access on it, which lead to a problem when the module was connected again."/>
		<Dokumentation Revision="1.20" Date="15.10.2010" Author="RamAnd" Company="Sigmatek" Description="Added method AddMovDO for the move command in the VM."/>
		<Dokumentation Revision="1.19" Date="22.07.2010" Author="WocPet" Company="Sigmatek" Description="Functionality for DIAS/CDIASRequiredError handling added"/>
		<Dokumentation Revision="1.18" Date="28.07.2010" Author="WocPet" Company="Sigmatek" Description="Init handling changed, because under special circumstances it was possible a required error was not triggered"/>
		<Dokumentation Revision="1.17" Date="08.07.2010" Author="WocPet" Company="Sigmatek" Description="Changes in VaranDataMover Class: A pointer was casted to a wrong type - so an access exception was possible"/>
		<Dokumentation Revision="1.16" Date="10.03.2010" Author="RamAnd" Company="Sigmatek" Description="Added serial number validation"/>
		<Dokumentation Revision="1.15" Date="08.02.2010" Author="BleErn / WocPet" Company="Sigmatek" Description="Derivation of method UpdateRtPostScan&#13;&#10;reorganisation of DO creation over Varan_DataMover"/>
		<Dokumentation Revision="1.14" Date="06.04.2010" Author="BleErn" Company="Sigmatek" Description="Analog modules might have shown wrong values(Cyclic update method of connected CDIAS modules was called without checking if data from mover were valid)"/>
		<Dokumentation Revision="1.13" Date="28.01.2010" Author="RamAnd" Company="Sigmatek" Description="Crash fixed in Varan_DataMover"/>
		<Dokumentation Revision="1.12" Date="18.12.2009" Author="RamAnd" Company="Sigmatek" Description="Added functionality to use Safety modules with activated Mover"/>
		<Dokumentation Revision="1.11" Date="17.12.2009" Author="RamAnd" Company="Sigmatek" Description="Prevented DIAS Error, if no module has been connected physically."/>
		<Dokumentation Revision="1.10" Date="02.11.2009" Author="RamAnd" Company="Sigmatek" Description="Changes in embedded Class Dias2DataMover (1.5 =&gt; 1.6)"/>
		<Dokumentation Revision="1.9" Date="21.08.2009" Author="ObeChr" Company="Sigmatek" Description="In HW-Disconnect, DO of DataMover weren&apos;t deactivated, when the DataMover was deactivated"/>
		<Dokumentation Revision="1.8" Date="13.07.2009" Author="armluk" Company="Sigmatek" Description="Added and improved Server/Client comments"/>
		<Dokumentation Revision="1.7" Date="18.05.2009" Author="wocpet" Company="Sigmatek" Description="new variable was added to set CDIAS Offset (1.2 =&gt; 1.3)&#13;&#10;(Offset for CIV521 : 16#1000)&#13;&#10;Changes in embedded Class Dias2DataMover (1.4 =&gt; 1.5)"/>
		<Dokumentation Revision="1.6" Date="12.02.2009" Author="RamAnd" Company="Sigmatek" Description="New Client added to disable DataMover functionality.&#13;&#10;Changes in class CDias2DataMover (1.1 =&gt; 1.2)"/>
		<Dokumentation Revision="1.5" Date="19.01.2009" Author="RamAnd" Company="Sigmatek" Description="Changes in embedded Class Dias2DataMover (1.3 =&gt; 1.4)"/>
	</RevDoku>
	<Network Name="CIV521">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{E4EE0345-2931-4D53-AB97-C57370AE0CAA}"
				Class      = "Varan_Base"
				Position   = "(270,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ConnectCounter"/>
					<Server Name="DeviceAddress"/>
					<Server Name="DeviceID"/>
					<Server Name="DiagControl"/>
					<Server Name="FaultCounter"/>
					<Server Name="Online"/>
					<Server Name="Release"/>
					<Server Name="RetryCounter"/>
					<Server Name="RXLost"/>
					<Server Name="SerialNo"/>
					<Server Name="State"/>
					<Server Name="TXLost"/>
					<Server Name="ValidateSerNo"/>
					<Server Name="VendorID"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SerNoValidation"/>
					<Client Name="TimeBase" Value="0"/>
					<Client Name="TimeBaseOffset" Value="0"/>
					<Client Name="To_MultiTask"/>
					<Client Name="To_StdLib"/>
					<Client Name="Transparent"/>
					<Client Name="UserAction"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "_VaranCanLib"
				GUID       = "{19440910-CA50-460C-A6BA-26537C3019B7}"
				Class      = "_VaranCanLib"
				Position   = "(270,3150)"
				Visualized = "true">
				<Channels>
					<Server Name="CanBus"/>
					<Server Name="Command"/>
					<Client Name="To_Varan_Can"/>
				</Channels>
			</Object>
			<Object
				Name       = "_VaranCanLibOS"
				GUID       = "{AF2EAAB2-2455-4E53-8B8A-F9BD72CD97A1}"
				Class      = "_VaranCanLibOS"
				Position   = "(270,3360)"
				Visualized = "true">
				<Channels>
					<Server Name="CanBus"/>
					<Server Name="Command"/>
					<Client Name="Index" Value="0"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "_VaranSerLibOS0"
				GUID       = "{B892996B-3506-4D00-BB2F-D20EA66876F1}"
				Class      = "_VaranSerLibOS"
				Position   = "(270,3570)"
				Visualized = "true">
				<Channels>
					<Server Name="Com"/>
					<Server Name="Command"/>
					<Client Name="Index" Value="0"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "_VaranSerLibOS1"
				GUID       = "{A4DB045D-3C26-49D6-9057-E8C937949492}"
				Class      = "_VaranSerLibOS"
				Position   = "(270,3780)"
				Visualized = "true">
				<Channels>
					<Server Name="Com"/>
					<Server Name="Command"/>
					<Client Name="Index" Value="1"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "_VaranSerLibOS2"
				GUID       = "{F9BF01D7-347F-4779-B51D-E14C9531B595}"
				Class      = "_VaranSerLibOS"
				Position   = "(270,3990)"
				Visualized = "true">
				<Channels>
					<Server Name="Com"/>
					<Server Name="Command"/>
					<Client Name="Index" Value="2"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "CDias2DataMover"
				GUID       = "{CEF25B21-4FDF-4C26-A209-10090CB27D0D}"
				Class      = "CDias2DataMover"
				Position   = "(270,1860)"
				Visualized = "true">
				<Channels>
					<Server Name="Control"/>
					<Client Name="CDIAS_BusAddress" Value="0"/>
					<Client Name="MoverActive" Value="1"/>
					<Client Name="To_DataMover"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "Dias2DataMover"
				GUID       = "{0A0610BA-37E3-4BCE-9AF3-F40AEC7C2763}"
				Class      = "Dias2DataMover"
				Position   = "(270,2190)"
				Visualized = "true">
				<Channels>
					<Server Name="Control"/>
					<Server Name="DiasErrorPlace"/>
					<Server Name="DIASRetryCounter"/>
					<Server Name="Release"/>
					<Client Name="DIAS_BusAddress" Value="16#10000"/>
					<Client Name="DiasErrorOff"/>
					<Client Name="To_DataMover"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "Hub_Base0"
				GUID       = "{DF222B55-58E9-4F9A-BE38-5727426A3E7E}"
				Class      = "Hub_Base"
				Position   = "(1410,1740)"
				Visualized = "true">
				<Channels>
					<Server Name="Control"/>
					<Client Name="Splitter_Place" Value="0"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "Varan_Can"
				GUID       = "{DB718CD1-C5EA-4377-A8A5-E470EA8F5978}"
				Class      = "Varan_Can"
				Position   = "(270,2580)"
				Visualized = "true">
				<Channels>
					<Server Name="CanBusNr"/>
					<Server Name="CanError"/>
					<Server Name="CanIsoError"/>
					<Server Name="Enabled"/>
					<Server Name="State"/>
					<Client Name="CallUserRt"/>
					<Client Name="Can_AddressOffset" Value="16#4000"/>
					<Client Name="Index" Value="0"/>
					<Client Name="ISOCanOn"/>
					<Client Name="Pll_Prescaler"/>
					<Client Name="To_Can"/>
					<Client Name="To_StdLib"/>
					<Client Name="To_Varan_Base"/>
				</Channels>
			</Object>
			<Object
				Name       = "Varan_DataMover"
				GUID       = "{AA1E52A6-3277-4E03-B99C-C2AD38FE5C94}"
				Class      = "Varan_DataMover"
				Position   = "(270,1140)"
				Visualized = "true">
				<Channels>
					<Server Name="ISO_Time"/>
					<Server Name="OpcodeError"/>
					<Server Name="State"/>
					<Server Name="Timeout"/>
					<Server Name="TimeSliceError"/>
					<Server Name="WishboneError"/>
					<Client Name="AddDIASTime"/>
					<Client Name="CodeSize" Value="4096"/>
					<Client Name="CodeStartAddress" Value="16#8000"/>
					<Client Name="DPRAM_Size" Value="4096"/>
					<Client Name="DPRAM_StartAddress" Value="16#2000"/>
					<Client Name="DPRAM_StartAddress_SUBBus" Value="16#2000"/>
					<Client Name="TimeSliceErrorOn" Value="1"/>
					<Client Name="To_Multitask"/>
					<Client Name="To_StdLib"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.State" Destination="_base.State" Vertices="(2008,210),(754,210),"/>
			<Connection Source="this.Online" Destination="_base.Online" Vertices="(2008,270),(754,270),"/>
			<Connection Source="this.Release" Destination="_base.Release" Vertices="(2008,330),(754,330),"/>
			<Connection Source="this.DeviceAddress" Destination="_base.DeviceAddress" Vertices="(2008,390),(754,390),"/>
			<Connection Source="this.VendorID" Destination="_base.VendorID" Vertices="(2008,450),(754,450),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(2008,510),(754,510),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(2008,630),(754,630),"/>
			<Connection Source="_base.VaranIn" Destination="this.VaranIn" Vertices="(270,210),(38,210),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(270,270),(38,270),"/>
			<Connection Source="_base.UserAction" Destination="this.UserAction" Vertices="(270,330),(38,330),"/>
			<Connection Source="this.CDIAS" Destination="CDias2DataMover.Control" Vertices="(2008,750),(1320,750),(1320,1950),(870,1950),(878,1950),"/>
			<Connection Source="this.DIAS" Destination="Dias2DataMover.Control" Vertices="(2008,810),(1320,809),(1320,2280),(976,2280),"/>
			<Connection Source="this.DIASRetryCounter" Destination="Dias2DataMover.DIASRetryCounter" Vertices="(2008,870),(1320,870),(1320,2400),(976,2400),"/>
			<Connection Source="this.VaranOut_1" Destination="Hub_Base0.Control" Vertices="(2008,1470),(1920,1470),(1920,1830),(1836,1830),"/>
			<Connection Source="Varan_Can.Pll_Prescaler" Destination="this.Pll_Prescaler" Vertices="(270,2850),(210,2849),(210,750),(38,750),"/>
			<Connection Source="Varan_Can.CallUserRt" Destination="this.CallUserRt" Vertices="(270,2910),(210,2909),(210,810),(38,810),"/>
			<Connection Source="this.CanStdInterfaceISO" Destination="_VaranCanLib.Command" Vertices="(2008,1170),(1320,1170),(1320,3239),(736,3240),"/>
			<Connection Source="this.Can_Enabled" Destination="Varan_Can.Enabled" Vertices="(2008,990),(1320,990),(1320,2729),(864,2730),"/>
			<Connection Source="this.CanError" Destination="Varan_Can.CanError" Vertices="(2008,1050),(1320,1050),(1320,2789),(864,2790),"/>
			<Connection Source="this.CanIsoError" Destination="Varan_Can.CanIsoError" Vertices="(2008,1110),(1320,1110),(1320,2849),(864,2850),"/>
			<Connection Source="this.CanInterfaceOS" Destination="_VaranCanLibOS.Command" Vertices="(2008,1230),(1320,1230),(1320,3449),(640,3450),"/>
			<Connection Source="Varan_Can.ISOCanOn" Destination="this.ISOCanOn" Vertices="(270,3030),(210,3029),(210,870),(38,870),"/>
			<Connection Source="Varan_DataMover.VaranIn" Destination="_base.State" Vertices="(270,1230),(210,1230),(210,1110),(1320,1110),(1320,210),(754,210),"/>
			<Connection Source="CDias2DataMover.VaranIn" Destination="_base.State" Vertices="(270,1950),(210,1950),(210,1110),(1320,1110),(1320,210),(754,210),"/>
			<Connection Source="CDias2DataMover.To_DataMover" Destination="Varan_DataMover.State" Vertices="(270,2010),(210,2010),(210,1830),(1320,1830),(1320,1230),(1214,1230),"/>
			<Connection Source="Dias2DataMover.VaranIn" Destination="_base.State" Vertices="(270,2280),(210,2279),(210,1110),(1320,1110),(1320,210),(754,210),"/>
			<Connection Source="Dias2DataMover.To_DataMover" Destination="Varan_DataMover.State" Vertices="(270,2340),(210,2339),(210,1830),(1320,1830),(1320,1230),(1214,1230),"/>
			<Connection Source="Hub_Base0.VaranIn" Destination="_base.State" Vertices="(1410,1830),(1320,1830),(1320,210),(754,210),"/>
			<Connection Source="Varan_Can.To_Varan_Base" Destination="_base.State" Vertices="(270,2670),(210,2669),(210,1110),(1320,1110),(1320,210),(754,210),"/>
			<Connection Source="_VaranCanLib.To_Varan_Can" Destination="Varan_Can.State" Vertices="(270,3240),(210,3239),(210,2189),(1320,2189),(1320,2670),(870,2669),(864,2670),"/>
			<Connection Source="_VaranCanLibOS.VaranIn" Destination="_base.State" Vertices="(270,3450),(210,3449),(210,1110),(1320,1110),(1320,210),(754,210),"/>
			<Connection Source="this.Com1" Destination="_VaranSerLibOS0.Command" Vertices="(2008,1290),(1320,1290),(1320,3659),(632,3660),"/>
			<Connection Source="this.Com2" Destination="_VaranSerLibOS1.Command" Vertices="(2008,1350),(1320,1350),(1320,3869),(632,3870),"/>
			<Connection Source="this.Com3" Destination="_VaranSerLibOS2.Command" Vertices="(2008,1410),(1320,1410),(1320,4079),(632,4080),"/>
			<Connection Source="_VaranSerLibOS0.VaranIn" Destination="_base.State" Vertices="(270,3660),(210,3659),(210,1110),(1320,1110),(1320,210),(754,210),"/>
			<Connection Source="_VaranSerLibOS1.VaranIn" Destination="_base.State" Vertices="(270,3870),(210,3869),(210,1110),(1320,1110),(1320,210),(754,210),"/>
			<Connection Source="_VaranSerLibOS2.VaranIn" Destination="_base.State" Vertices="(270,4080),(210,4079),(210,1110),(1320,1110),(1320,210),(754,210),"/>
			<Connection Source="this.Varan_DataMover" Destination="Varan_DataMover.State"/>
			<Connection Source="this.CDias2DataMover" Destination="CDias2DataMover.Control"/>
			<Connection Source="this.Dias2DataMover" Destination="Dias2DataMover.Control"/>
			<Connection Source="this.Hub_Base0" Destination="Hub_Base0.Control"/>
			<Connection Source="this.Varan_Can" Destination="Varan_Can.State"/>
			<Connection Source="this._VaranCanLib" Destination="_VaranCanLib.Command"/>
			<Connection Source="this._VaranCanLibOS" Destination="_VaranCanLibOS.Command"/>
			<Connection Source="this._VaranSerLibOS0" Destination="_VaranSerLibOS0.Command"/>
			<Connection Source="this._VaranSerLibOS1" Destination="_VaranSerLibOS1.Command"/>
			<Connection Source="this._VaranSerLibOS2" Destination="_VaranSerLibOS2.Command"/>
			<Connection Source="CDias2DataMover.MoverActive" Destination="this.MoverActive" Vertices="(270,2130),(210,2130),(210,930),(38,930),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(2008,570),(754,570),"/>
			<Connection Source="_base.SerNoValidation" Destination="this.SerNoValidation" Vertices="(270,390),(38,390),"/>
			<Connection Source="this.ValidateSerNo" Destination="_base.ValidateSerNo" Vertices="(2008,690),(754,690),"/>
			<Connection Source="_base.Transparent" Destination="this.Transparent" Vertices="(270,450),(38,450),"/>
			<Connection Source="this.DiasErrorPlace" Destination="Dias2DataMover.DiasErrorPlace" Vertices="(2008,930),(1320,930),(1320,2460),(976,2460),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using Varan_Base

CIV521 : CLASS
: Varan_Base
  //Servers:
	CDIAS 	: SvrChCmd_DINT;
	DIAS 	: SvrChCmd_DINT;
	DIASRetryCounter 	: SvrCh_DINT;
	DiasErrorPlace 	: SvrCh_DINT;
	Can_Enabled 	: SvrCh_DINT;
	CanError 	: SvrCh_DINT;
	CanIsoError 	: SvrCh_DINT;
	CanStdInterfaceISO 	: SvrChCmd_DINT;
	CanInterfaceOS 	: SvrChCmd_DINT;
	Com1 	: SvrChCmd_DINT;
	Com2 	: SvrChCmd_DINT;
	Com3 	: SvrChCmd_DINT;
	VaranOut_1 	: SvrChCmd_DINT;
  //Clients:
	Varan_DataMover 	: CltChCmd_Varan_DataMover;
	CDias2DataMover 	: CltChCmd_CDias2DataMover;
	Dias2DataMover 	: CltChCmd_Dias2DataMover;
	Hub_Base0 	: CltChCmd_Hub_Base;
	Varan_Can 	: CltChCmd_Varan_Can;
	Pll_Prescaler 	: CltCh_DINT;
	CallUserRt 	: CltCh_DINT;
	_VaranCanLib 	: CltChCmd__VaranCanLib;
	_VaranCanLibOS 	: CltChCmd__VaranCanLibOS;
	ISOCanOn 	: CltCh_DINT;
	_VaranSerLibOS0 	: CltChCmd__VaranSerLibOS;
	_VaranSerLibOS1 	: CltChCmd__VaranSerLibOS;
	_VaranSerLibOS2 	: CltChCmd__VaranSerLibOS;
	MoverActive 	: CltCh_DINT;
  //Variables:
		us_Firstscan 	: USINT;
		b_CallDataMover 	: BOOL;
		us_RtWait 	: USINT;
		us_TxMultiplier 	: USINT;
		us_SyncCounter 	: USINT;
		ud_VaranTime 	: UDINT;
		ud_IsoStartPoint 	: UDINT;
		sd_SyncOffset 	: DINT;
		b_MoverConfigured 	: BOOL;
		b_Initialized 	: BOOL;
		oldNodeInfo : ARRAY [0..255] OF USINT;

  //Functions:
				//! <Function Comment="-------------------------------------------------------------------------------------------------&#13;&#10;[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Init for Varan Client&#13;&#10;=================================================================================================&#13;&#10;[server] State    :W  :state of class&#13;&#10;[client] Required   :R  :is class required for varan or not&#13;&#10;[members] p_VaranPosition  :R/W :node string of varan module&#13;&#10;   ud_VaranManagerNr :W  :number of varan manager&#13;&#10;   p_Varan    :W  :pointer to varan OS - Functions&#13;&#10;[locals] sd_retval   :W/R :return value of called functions&#13;&#10;" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Cy - Funktion of Varan class ( called bei VaranMaster )&#13;&#10;=================================================================================================&#13;&#10;" Name="UpdateCy"/>
	FUNCTION VIRTUAL GLOBAL UpdateCy;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Rt - Funktion of Varan class ( called bei VaranMaster )&#13;&#10;=================================================================================================&#13;&#10;" Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Function is called by VaranRtPostScan if used" Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function is called if a varan module is connected&#13;&#10;=================================================================================================&#13;&#10;[server] Online  :W  :set if class is ok and all data is valid&#13;&#10;   State  :W  :state of class&#13;&#10;" Name="Varan_HwConnect"/>
	FUNCTION VIRTUAL GLOBAL Varan_HwConnect
		VAR_INPUT
			ud_data 	: UDINT;			//! <Variable Comment="data of call back" Name="Varan_HwConnect.ud_data"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;			//! <Variable Comment="returnvalue of function" Name="Varan_HwConnect.sd_retval"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function is called if a varan interrupt occures&#13;&#10;=================================================================================================&#13;&#10;[server] Online     :W  :set if class is ok and all data is valid&#13;&#10;   State     :W  :state of class&#13;&#10;[members] s_CallBackSettings  :W  :structure for settings of callback function&#13;&#10;" Name="Varan_HwInterrupt"/>
	FUNCTION VIRTUAL GLOBAL Varan_HwInterrupt
		VAR_INPUT
			ud_reason 	: UDINT;			//! <Variable Comment="reason of interrupt" Name="Varan_HwInterrupt.ud_reason"/>
			ud_data 	: ^t_CallBackInterrupt;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function is called if a varan module is disconnected&#13;&#10;=================================================================================================&#13;&#10;[server] Online  :W  :set if class is ok and all data is valid&#13;&#10;   State  :W  :state of class&#13;&#10;" Name="Varan_HwDisconnect"/>
	FUNCTION VIRTUAL GLOBAL Varan_HwDisconnect
		VAR_INPUT
			ud_data 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to set state of class&#13;&#10;=================================================================================================&#13;&#10;" Name="SetState"/>
	FUNCTION VIRTUAL GLOBAL SetState
		VAR_INPUT
			sd_error 	: t_e_VaranErrors;			//! <Variable Comment="type of error" Name="SetState.sd_error"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to set all Data Objects off&#13;&#10;=================================================================================================&#13;&#10;" Name="SetDOsOff"/>
	FUNCTION VIRTUAL GLOBAL SetDOsOff;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to update module retry counter&#13;&#10;=================================================================================================&#13;&#10;" Name="UpdateRetryCounter"/>
	FUNCTION VIRTUAL GLOBAL UpdateRetryCounter;
				//! <Function Comment="Check if DeviceID is supported by class" Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			ID2Check 	: UDINT;			//! <Variable Comment="VARAN DeviceID, which should be checked" Name="CheckDeviceID.ID2Check"/>
		END_VAR
		VAR_OUTPUT
			IsOK 	: BOOL;			//! <Variable Comment="TRUE...DeviceID is ok with this class&#13;&#10;FALSE..DeviceID is not ok with this class" Name="CheckDeviceID.IsOK"/>
		END_VAR;
	
	FUNCTION CheckforRetrycounter
		VAR_OUTPUT
			b_available 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DIASRetryCounter::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DiasErrorPlace::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Can_Enabled::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _VaranCanLib
#pragma using _VaranCanLibOS
#pragma using _VaranSerLibOS
#pragma using CDias2DataMover
#pragma using Dias2DataMover
#pragma using Hub_Base
#pragma using Varan_Can
#pragma using Varan_DataMover


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB CIV521::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_CIV521
1$UINT, 61$UINT, (SIZEOF(::CIV521))$UINT, 
13$UINT, 14$UINT, 0$UINT, 
TO_UDINT(495304727), "CIV521", //Class
TO_UDINT(862125188), "Varan_Base", 2$UINT, 2$UINT, //Baseclass
//Servers:
(::CIV521.CDIAS.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2840384171), "CDIAS", 
(::CIV521.DIAS.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1366939699), "DIAS", 
(::CIV521.DIASRetryCounter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1894626063), "DIASRetryCounter", 
(::CIV521.DiasErrorPlace.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2088124791), "DiasErrorPlace", 
(::CIV521.Can_Enabled.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1037238659), "Can_Enabled", 
(::CIV521.CanError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2041939562), "CanError", 
(::CIV521.CanIsoError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4115620224), "CanIsoError", 
(::CIV521.CanStdInterfaceISO.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2106466773), "CanStdInterfaceISO", 
(::CIV521.CanInterfaceOS.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1144307917), "CanInterfaceOS", 
(::CIV521.Com1.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3341472576), "Com1", 
(::CIV521.Com2.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1579385594), "Com2", 
(::CIV521.Com3.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(690270828), "Com3", 
(::CIV521.VaranOut_1.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2138873746), "VaranOut_1", 
//Clients:
(::CIV521.Varan_DataMover.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3752737333), "Varan_DataMover", TO_UDINT(3752737333), "Varan_DataMover", 1$UINT, 50$UINT, 
(::CIV521.CDias2DataMover.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1046309609), "CDias2DataMover", TO_UDINT(1046309609), "CDias2DataMover", 1$UINT, 50$UINT, 
(::CIV521.Dias2DataMover.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3820159437), "Dias2DataMover", TO_UDINT(3820159437), "Dias2DataMover", 1$UINT, 50$UINT, 
(::CIV521.Hub_Base0.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1954527509), "Hub_Base0", TO_UDINT(3238133653), "Hub_Base", 1$UINT, 20$UINT, 
(::CIV521.Varan_Can.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(206510048), "Varan_Can", TO_UDINT(206510048), "Varan_Can", 1$UINT, 40$UINT, 
(::CIV521.Pll_Prescaler.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(330476248), "Pll_Prescaler", 
(::CIV521.CallUserRt.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(2801721227), "CallUserRt", 
(::CIV521._VaranCanLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(781409069), "_VaranCanLib", TO_UDINT(781409069), "_VaranCanLib", 1$UINT, 10$UINT, 
(::CIV521._VaranCanLibOS.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(415874427), "_VaranCanLibOS", TO_UDINT(415874427), "_VaranCanLibOS", 1$UINT, 10$UINT, 
(::CIV521.ISOCanOn.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(532270954), "ISOCanOn", 
(::CIV521._VaranSerLibOS0.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3152020505), "_VaranSerLibOS0", TO_UDINT(3827919523), "_VaranSerLibOS", 1$UINT, 20$UINT, 
(::CIV521._VaranSerLibOS1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3437704335), "_VaranSerLibOS1", TO_UDINT(3827919523), "_VaranSerLibOS", 1$UINT, 20$UINT, 
(::CIV521._VaranSerLibOS2.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1441686837), "_VaranSerLibOS2", TO_UDINT(3827919523), "_VaranSerLibOS", 1$UINT, 20$UINT, 
(::CIV521.MoverActive.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(3350278117), "MoverActive", 
END_FUNCTION


#define USER_CNT_CIV521 42

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_CIV521] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION CIV521::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= Varan_Base::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= Varan_Base::State.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, Varan_Base::State.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_CIV521;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #Varan_HwConnect();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #Varan_HwInterrupt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #Varan_HwDisconnect();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #SetState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #SetDOsOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #UpdateRetryCounter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #CheckDeviceID();

#pragma warning (default : 74)
	Varan_Base::State.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Varan_Base::State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, CDIAS.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	CDIAS.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CDIAS.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, DIAS.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	DIAS.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DIAS.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DIASRetryCounter.pMeth			:= StoreMethod( #DIASRetryCounter::Read(), #M_NO_F() );
	IF DIASRetryCounter.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DiasErrorPlace.pMeth			:= StoreMethod( #DiasErrorPlace::Read(), #M_NO_F() );
	IF DiasErrorPlace.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Can_Enabled.pMeth			:= StoreMethod( #Can_Enabled::Read(), #M_NO_F() );
	IF Can_Enabled.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, CanStdInterfaceISO.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	CanStdInterfaceISO.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CanStdInterfaceISO.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, CanInterfaceOS.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	CanInterfaceOS.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CanInterfaceOS.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, Com1.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	Com1.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Com1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, Com2.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	Com2.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Com2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, Com3.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	Com3.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Com3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, VaranOut_1.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	VaranOut_1.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF VaranOut_1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma using DiasMaster
#pragma using DiasMasterC
#pragma using _CanLib
#pragma using _SerLib


(************************************************************************************
*
*	Class for CIV521 hardwaremodule
*	Created : Sigmatek	/	SR	/	2007
*	Changes : 
*
*
*   FOR NEWER CHANGES SEE REVISION DOCUMENTATION OF CLASS
*
*
*		1.3 => 1.4	/ 14.05.2008
*			- [DB 859]: optimize Diasbus efficiency 
*       1.2 => 1.3  /	18.04.2008
*			- [DB 852]: calculate offset of syncout in dependence of iso startpoint
*		1.1 => 1.2  /   19.03.2008
*			- [DB 812]: record dias-bus ID in log-file if a diaserror occures
*		1.0 => 1.1	/	21.02.2008
*			a dias or timeslice error disables the whole device with all bus systems
* 
************************************************************************************)

//----------------------------------------class defines--------------------------------------------
#define CIV521_DEVICE_ID	1050
//-------------------------------------------------------------------------------------------------

//[#ENGLISH]
//=================================================================================================
//Init for Varan Client
//=================================================================================================
//[server]	State				:W		:state of class
//[client]	Required			:R		:is class required for varan or not
//[members]	p_VaranPosition		:R/W	:node string of varan module
//			ud_VaranManagerNr	:W		:number of varan manager
//			p_Varan				:W		:pointer to varan OS - Functions
//[locals]	sd_retval			:W/R	:return value of called functions
FUNCTION VIRTUAL GLOBAL CIV521::Init
VAR
	sd_retval	: DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF IsTransparent() THEN
    return;
  END_IF;
#endif

	us_Firstscan += 1;  
  
  //get client values
  MoverActive := MoverActive.Read();  

	//---------------------------------------------------------------------------------------------
	//in second init phase (because of required error settings in first phase from connected moduls)
	if ( us_Firstscan < 7 ) & ( us_Firstscan > 1 ) then

    if b_Initialized = false then

      //init the base class
      Varan_Base::Init();
      
      State := State;
      
      //if an error occurs in base class return
      if ( State <> _NotInitialized & State <> _ClassOk & State <> _NoHardware & State <> _WrongHardware ) then
        return;
      end_if;
      
      //install Varantask
      VaranIn.AddVaranTask( ud_dol_type	:= VARAN_DOL_ISO
                , p_this		:= this
                , callOptions := CALL_OPTION_RT_PRESCAN OR CALL_OPTION_RT_POSTSCAN
                );

      //install Varantask
      VaranIn.AddVaranTask( ud_dol_type	:= VARAN_DOL_ASY
                , p_this		:= this
                );

      b_Initialized := true;
    end_if;  
	
	//---------------------------------------------------------------------------------------------
	// in 7th run call connect methode
	elsif ( us_Firstscan = 7 ) then

		//call connect hardware function
		sd_retval := Varan_CallBack	( ud_reason	:= VARANMANAGER_CB_CONNECT
									, ud_data	:= 0
									);

		//produce Varan Error if module not ok
		if ( sd_retval <> VARANMANAGER_OK ) then
			VaranIn.SetVaranError( p_Node := p_VaranPosition );
			return;
		end_if;

	end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV521::Init
//[#ENGLISH]
//=================================================================================================
//Cy - Funktion of Varan class ( called by VaranMaster )
//=================================================================================================
FUNCTION VIRTUAL GLOBAL CIV521::UpdateCy

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
	StartTimeMeasurement(VARANTIME_CY);
#endif
//=================================================================================================

	//base class
	Varan_Base::UpDateCy();

	//check state
	if ( State = _ClassOK ) then
  
    if MoverActive & ( b_MoverConfigured <> TRUE ) then
      // tell the OS that we are ready for transmission of safety data
      CDias2DataMover.SafetyMoverConfigured();
      b_MoverConfigured := TRUE;
    end_if;
	
		//check if we can update CDIAS and DIAS
		if ( Varan_DataMover.CyWork( 0 ) = READY$UDINT ) then
			CDias2DataMover.CyWork( 0 );
      if (Dias2DataMover.CyWork( 1 ) = READY$UDINT ) then//because DiasMasterPostscan calls with 0
        Varan_DataMover.CyWork( 1 );
      end_if;
    elsif (MoverActive = 0) then
      CDias2DataMover.CyWork( 0 );
		end_if;
	end_if;

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
	StopTimeMeasurement(VARANTIME_CY);
#endif
//=================================================================================================

END_FUNCTION //VIRTUAL GLOBAL CIV521::UpdateCy
//[#ENGLISH]
//=================================================================================================
//Rt - Funktion of Varan class ( called by VaranMaster )
//=================================================================================================
FUNCTION VIRTUAL GLOBAL CIV521::UpdateRt
VAR
	sd_retval		: DINT;
END_VAR

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
	StartTimeMeasurement(VARANTIME_RT);
#endif
//=================================================================================================

	//base class
	Varan_Base::UpDateRt();
		
	//check state
	if ( State =_ClassOK ) then

		//------------------------------------------------------------------------------------------------
		//in first run enable Sync Out for can
		if ( b_CallDataMover = FALSE ) then

			//enable sync out
			Pll_Prescaler := Pll_Prescaler.read();
			if ( Pll_Prescaler > 1 ) then		
				us_TxMultiplier := Pll_Prescaler$USINT;
			else
				us_TxMultiplier := 0;
			end_if;

			//we enable sync after first data transfer
			us_SyncCounter := VaranIn.GetSyncFrameCounter() + 1;

			sd_retval := EnableSyncOut	( us_sync_nr				:= 1
//										, sd_offset					:= ( VaranIn.GetVaranTime() )$DINT / 20
										, sd_offset					:= sd_SyncOffset
										, us_period_multiplier		:= us_TxMultiplier
										, us_frame_count_treshold	:= us_SyncCounter
										, us_enable_frame_count		:= 1
										);

			//look for an error
			if ( sd_retval <> VARANMANAGER_OK ) then
				return;
			end_if;

			Varan_DataMover.RtWork( 0 );
			b_CallDataMover := TRUE;
		else

			//Call to update ISO Time
			Varan_DataMover.RtWork( 0 );
			
			//we must wait one cycle after start because Data is not valid in first run
			if ( us_RtWait = 0 ) then
				CDias2DataMover.RtWork( 0 );
				Dias2DataMover.RtWork( 0 );
			else
				if ( us_RtWait ) then
					us_RtWait -= 1;
				end_if;
			end_if;
		end_if;

		//------------------------------------------------------------------------------------------------
		//call varan can class
		Varan_Can.RtWork(0);

		//Class is online
		if ( State = _ClassOk ) then
			Online := 1;
		end_if;
	end_if;

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
	StopTimeMeasurement(VARANTIME_RT);
#endif
//=================================================================================================

END_FUNCTION //VIRTUAL GLOBAL CIV521::UpdateRt
//[#ENGLISH]
//=================================================================================================
//Function is called if a varan module is connected
//=================================================================================================
//[server]	Online		:W		:set if class is ok and all data is valid
//			State		:W		:state of class
//[>ud_data]data of call back
//[<sd_retval]returnvalue of function
FUNCTION VIRTUAL GLOBAL CIV521::Varan_HwConnect
VAR_INPUT
	ud_data		: UDINT;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR
VAR
	sz_name	: array[ 0..255 ] of char;
  Temp : USINT;
END_VAR

	//------------------------------------------------------------------------------------------------
	//get node information
	sd_retval := GetNodeInfo();

	//look for an error
	if ( sd_retval <> VARANMANAGER_OK ) then
		return;
	end_if;
  
  //look if we have an DIAS error before -> reset
  if State = _DiasError then
    State := _NotInitialized;
  end_if;
(*
	//look if it is right hardware
	if	( DeviceID <> CIV521_DEVICE_ID ) then
		State := _WrongHardware;
		return;
	end_if;
*)  

  // if the node info has changed => tell the civ_base to reinit (needed for flexhub flexibility)
  if oldNodeInfo[0] & (To_StdLib.MemCmp(dest:=#oldNodeInfo[0], source:=p_VaranPosition, size:=p_VaranPosition^ + 1)) then
    CDias2DataMover.CIV_ReInit();
  end_if;
  To_StdLib.MemCpy(dest:=#oldNodeInfo[0], source:=p_VaranPosition, size:=p_VaranPosition^ + 1);

  //----------------------------------------------------------------
  //check if mover is deactivated and FPGA version is ok with this
  if (MoverActive = 0) & (Release < 16#17) then
    // if fpga version is to low for this option => create error
    State := _ComponentNotExists;
    Trace( "CIV521 needs at least FPGA Version 0x17 to disable Mover! Object: " );
    _GetObjName( this, #sz_name[ 0 ] );
    TRACE( #sz_name[ 0 ] );
    return;
  end_if;

	//------------------------------------------------------------------------------------------------
	//we must wait because otherwise some cdias moduls not ready for new init
	To_MultiTask.TASKDELAY( timeout0 := 10ms );	
	
	//------------------------------------------------------------------------------------------------
	//set pll time
	sd_retval := SetPllData();

	//look for an error
	if ( sd_retval <> VARANMANAGER_OK ) then
		return;
	end_if;

	//get varan time and calculate offset for sync
	ud_VaranTime := VaranIn.GetVaranTime( #ud_IsoStartPoint );

	sd_SyncOffset := ( ud_VaranTime - ud_IsoStartPoint )$DINT / 10;

	//set DIAS Rt Time of VaranDataMover
	Varan_DataMover.AddDIASTime := ( ( ud_VaranTime / 10 ) - sd_SyncOffset$UDINT ) / 100;

	//set sync out counter
	sd_retval := EnableSyncOut	( us_sync_nr				:= 0
								, sd_offset					      := sd_SyncOffset
								, us_period_multiplier		:= 0
								, us_frame_count_treshold	:= 0
								, us_enable_frame_count		:= 0
								);

	//look for an error
	if ( sd_retval <> VARANMANAGER_OK ) then
		return;
	end_if;

  // check if the new sync is available (when cdias needs to run seperated from the dias => mover for cdias is disabled)
  if Release >= 16#24 then
    
    //set sync out counter
    sd_retval := EnableSyncOut	( us_sync_nr				:= 2
                  , sd_offset					      := 0
                  , us_period_multiplier		:= 0
                  , us_frame_count_treshold	:= 0
                  , us_enable_frame_count		:= 0
                  );

    //look for an error
    if ( sd_retval <> VARANMANAGER_OK ) then
      return;
    end_if;

    // if mover is active
    if MoverActive then
      Temp := 0; // use the same sync as dias
    else
      Temp := 1; // use the sync out 2
    end_if;
    
    if b_PayloadSupport then      
      sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                    , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                    , udOffset    := 16#810
                                                    , udLength    := sizeof(Temp)
                                                    , pusData     := #Temp
                                                    , pudErrorInfo:= NIL); 
      
    else
    // write on new register to select the sync for CDIAS (0..sync out 0 is used, 1..sync out 2 is used)
    sd_retval := VARAN_IWRITEMEMORYDA	( uiManager		:= ud_VaranManagerNr
                          , uiAddress		:= DeviceAddress + 16#810
                          , uiLen			:= sizeof(Temp)
                          , uiRetryTimeout:= GetRetryTimeout(sizeof(Temp))
                          , pvData		:= #Temp
                          , puiError		:= NIL
                          );
    end_if;    

    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;    
      return;
    end_if;
  end_if;
  
  if MoverActive then
    // tell the OS that we configure DAs now
    CDias2DataMover.SafetyMoverDisable();
  end_if;

	//------------------------------------------------------------------------------------------------
	//settings for direct access of Data mover
	sd_retval := Varan_DataMover.SetDASettings();

	//look for errors
	if ( sd_retval <> 0 ) then
		return;
	end_if;
  
  // this must be done earlier, because varan data mover is already used in dias callback for direct accesses which only work if State is _ClassOk
  Varan_DataMover.State := _ClassOk;
  
	if MoverActive then
    // tell the OS that we've configured DAs
    CDias2DataMover.SafetyMoverEnable();
  end_if;

	//callback of CDIAS classes
	CDias2DataMover.Cdias_CallBack( ud_reason := VARANMANAGER_CB_CONNECT, ud_data := ud_data );

	if  (State <> _NoHardware)
    & (State <> _ClassOk)
		& (State <> _NotInitialized)
		& (State <> _InvalidSerialNo) then
		return;
	end_if;

	//callback of DIAS classes
	Dias2DataMover.Dias_CallBack( ud_reason := VARANMANAGER_CB_CONNECT, ud_data := ud_data, CheckforRetrycounter() );

	if  (State <> _NoHardware)
    & (State <> _ClassOk)
		& (State <> _NotInitialized)
		& (State <> _InvalidSerialNo) then
		return;
	end_if;

  //#WP003 start
  //create DOs from mover after first callback
  Varan_DataMover.CreateDOs();

  if (MoverActive = true) then
    //2nd callback to CDIAS classes, for real DO creation
    CDias2DataMover.Cdias_CallBack( ud_reason := VARANMANAGER_CB_CONNECT, ud_data := ud_data );
      
	if  (State <> _NoHardware)
    & (State <> _ClassOk)
		& (State <> _NotInitialized)
		& (State <> _InvalidSerialNo) then
		return;
	end_if;
  end_if;
    
  //allways 2nd callback to dias classes, cause dias is allways with mover
  Dias2DataMover.Dias_CallBack( ud_reason := VARANMANAGER_CB_CONNECT, ud_data := ud_data, CheckforRetrycounter() );

	if  (State <> _NoHardware)
    & (State <> _ClassOk)
		& (State <> _NotInitialized)
		& (State <> _InvalidSerialNo) then
		return;
	end_if;
  //#WP003 end
    
	//call callback of DataMover
	sd_retval := Varan_DataMover.Varan_CallBack( ud_reason := VARANMANAGER_CB_CONNECT, ud_data := ud_data );

	//look for errors
	if ( sd_retval <> 0 ) then
		return;
	end_if;

	us_RtWait := 1;
	b_CallDataMover := FALSE;

	//------------------------------------------------------------------------------------------------
	//call can class
	sd_retval := Varan_Can.Varan_Connect( ud_data );

	if ( sd_retval <> VARANMANAGER_OK ) then
		State := Varan_Can.State$t_e_VaranErrors;
		return;
	end_if;

	//can interface
	_VaranCanLibOS.Connect();
	
	//serial interfaces
	_VaranSerLibOS0.Connect();
	_VaranSerLibOS1.Connect();
	_VaranSerLibOS2.Connect();

	//set class as valid
	State 	:= _ClassOk;

	sd_retval := VARANMANAGER_OK;

END_FUNCTION //VIRTUAL GLOBAL CIV521::Varan_HwConnect
//[#ENGLISH]
//=================================================================================================
//Function is called if a varan module is disconnected
//=================================================================================================
//[server]	Online		:W		:set if class is ok and all data is valid
//			State		:W		:state of class
//[>ud_data]data of call back
//[<sd_retval]returnvalue of function
FUNCTION VIRTUAL GLOBAL CIV521::Varan_HwDisconnect
VAR_INPUT
	ud_data		: UDINT;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR

	//callback of CDIAS classes
	CDias2DataMover.Cdias_CallBack( ud_reason := VARANMANAGER_CB_DISCONNECT, ud_data := ud_data );

	//callback of CDIAS classes
	Dias2DataMover.Dias_CallBack( ud_reason := VARANMANAGER_CB_DISCONNECT, ud_data := ud_data );

	//call callback of DataMover
	Varan_DataMover.Varan_CallBack( ud_reason := VARANMANAGER_CB_DISCONNECT, ud_data := ud_data );

	//Can class
	Varan_Can.Varan_Disconnect();
	_VaranCanLibOS.Disconnect();
	
	//serial interfaces
	_VaranSerLibOS0.Disconnect();
	_VaranSerLibOS1.Disconnect();
	_VaranSerLibOS2.Disconnect();
	
  
  if State = _DiasError & b_Initialized then
    b_Initialized := false;
  else  
    b_Initialized := true;
    State 	:= _NoHardware;		//set class as invalid
  end_if;  
    
	Online 	:= 0;

	sd_retval := VARANMANAGER_OK;

END_FUNCTION //VIRTUAL GLOBAL CIV521::Varan_HwDisconnect
//[#ENGLISH]
//=================================================================================================
//Function is called if a varan interrupt occures
//=================================================================================================
//[server]	Online					:W		:set if class is ok and all data is valid
//			State					:W		:state of class
//[members]	s_CallBackSettings		:W		:structure for settings of callback function
//[>ud_reason]reason of interrupt
//[>ud_data]data of call back
//[<sd_retval]returnvalue of function
FUNCTION VIRTUAL GLOBAL CIV521::Varan_HwInterrupt
VAR_INPUT
	ud_reason		: UDINT;
	ud_data		: ^t_CallBackInterrupt;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR

	//callback of CDIAS classes
	CDias2DataMover.Cdias_CallBack( ud_reason := ud_reason, ud_data := ud_data$UDINT );

	//callback of CDIAS classes
	Dias2DataMover.Dias_CallBack( ud_reason := ud_reason, ud_data := ud_data$UDINT );

	//call callback of DataMover
	Varan_DataMover.Varan_CallBack( ud_reason := ud_reason, ud_data := ud_data$UDINT );

	//look which type of interrupt
  if State <> _DiasError then
    case ( ud_reason ) of
      VARANMANAGER_CB_REQ_ERROR:		State	:= _HardwareRequiredIRQ;
      VARANMANAGER_CB_NOT_REQ_ERROR:	State	:= _HardwareNotRequiredIRQ;
                      b_DisableDevice := TRUE;
      VARANMANAGER_FATAL_ERROR:		State	:= _HardwareFatalErrorIRQ;
    end_case;
  else
    b_DisableDevice := TRUE;
  end_if;

	Online 	:= 0;

	s_CallBackSettings.p_InterruptHandleDO := ( ud_data^.ud_Handle )$^LSL_VARANFRAME;

	sd_retval := VARANMANAGER_OK;

END_FUNCTION //VIRTUAL GLOBAL CIV521::Varan_HwInterrupt
//[#ENGLISH]
//=================================================================================================
//Function to update module retry counter
//=================================================================================================
FUNCTION VIRTUAL GLOBAL CIV521::UpdateRetryCounter
	
	//check ISO RD DO's for retry
  if MoverActive then
    RetryCounter += Varan_DataMover.GetRetryCounter();
  else
    RetryCounter += CDias2DataMover.GetRetryCounter();
  end_if;

	//check can card
	RetryCounter += Varan_Can.GetRetryCounter();

END_FUNCTION //VIRTUAL GLOBAL CIV521::UpdateRetryCounter
//[#ENGLISH]
//=================================================================================================
//Function to set all Data Objects off
//=================================================================================================
FUNCTION VIRTUAL GLOBAL CIV521::SetDOsOff

	Varan_DataMover.SetDOsOff();

	//set Do's of Can off
	Varan_Can.SetDOsOff();

END_FUNCTION //VIRTUAL GLOBAL CIV521::SetDOsOff
//[#ENGLISH]
//=================================================================================================
//Function to set state of class
//=================================================================================================
//[>sd_error]type of error
FUNCTION VIRTUAL GLOBAL CIV521::SetState
VAR_INPUT
	sd_error		: t_e_VaranErrors;
END_VAR
VAR
	sd_retval   : DINT;
END_VAR

	//if Dias Error
	if ( sd_Error = _DiasError | sd_Error = _TimeSliceError ) then

		SetPllData();		//to disable Sync
		Online := 0;

		if ( sd_error = _DiasError ) then
			VaranIn.LogMessage( "DiasError on CIV521 (DeviceAddress: %x, DiasModulePlace: %d)", 2, DeviceAddress$DINT, Dias2DataMover.DiasErrorPlace, 0 );

#ifdef VARANMANAGER_CB_DIAS_ERROR
      sd_retval := Varan_CallBack(ud_reason:= VARANMANAGER_CB_DIAS_ERROR, ud_data:= 0);
#else
      sd_retval := VARANMANAGER_COMPONENT_NOT_EXISTS;
#endif      
      //if class is required, and user don't want to go on, set manager off
      if ( Required ) & (sd_retval <> VARANMANAGER_OK) then
        Online := 0;
        Varan_HwDisconnect(0);
        VaranIn.SetManagerOff( e_error := sd_error );
      else
        //if class is not required disable device with all bus systems
        DisableDevice();
      end_if;
		end_if;

		if ( sd_error = _TimesliceError ) then
			VaranIn.LogMessage( "TimeSlice Error on CIV521 (DeviceAddress: %x)", 1, DeviceAddress$DINT, 0, 0 );
		end_if;
	end_if;
  
  if (sd_error = _CDIASRequiredError) | (sd_error = _DIASRequiredError) then
    
    if sd_error = _CDIASRequiredError then
      VaranIn.LogMessage( "Required Error on CDIAS-Bus of CIV521 (DeviceAddress: %x)", 1, DeviceAddress$DINT, 0, 0 );
		else
      VaranIn.LogMessage( "Required Error on DIAS-Bus of CIV521 (DeviceAddress: %x)", 1, DeviceAddress$DINT, 0, 0 );
    end_if;
    Online := 0;
		Varan_HwDisconnect(0);
		VaranIn.SetManagerOff( e_error := sd_error );
  end_if;    

	State := sd_error;

END_FUNCTION //VIRTUAL GLOBAL CIV521::SetState

FUNCTION VIRTUAL GLOBAL CIV521::Can_Enabled::Read
VAR_OUTPUT
	output		: DINT;
END_VAR

	Can_Enabled := Varan_Can.Enabled.read();
	output := Can_Enabled;

END_FUNCTION //VIRTUAL GLOBAL CIV521::Can_Enabled::Read

//BLEERN001 start
FUNCTION VIRTUAL GLOBAL CIV521::UpdateRtPostScan

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
	StartTimeMeasurement(VARANTIME_RTPOSTSCAN);
#endif
//=================================================================================================

//  IF UseRtPostScan <> 0 THEN
    CDias2DataMover.UpdateRtPostScan();
    Dias2DataMover.UpdateRtPostScan();
    
    Varan_Can.RtWork(1);
//  END_IF;

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
	StopTimeMeasurement(VARANTIME_RTPOSTSCAN);
#endif
//=================================================================================================
  
END_FUNCTION
//BLEERN001 end

FUNCTION VIRTUAL GLOBAL CIV521::CheckDeviceID
	VAR_INPUT
		ID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		IsOK 	: BOOL;
	END_VAR

  if (ID2Check <> CIV521_DEVICE_ID) then
    IsOK := FALSE;
  else
    IsOK := TRUE;
  end_if;

END_FUNCTION


FUNCTION CIV521::CheckforRetrycounter
	VAR_OUTPUT
		b_available 	: BOOL;
	END_VAR

  if Release >= 16#23 then
    b_available := true;
  else
    b_available := false;
  end_if;

END_FUNCTION



FUNCTION VIRTUAL GLOBAL CIV521::DiasErrorPlace::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	DiasErrorPlace := Dias2DataMover.DiasErrorPlace.Read();
	output := DiasErrorPlace;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIV521::DIASRetryCounter::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	DIASRetryCounter := Dias2DataMover.DIASRetryCounter.Read();
	output := DIASRetryCounter;

END_FUNCTION
