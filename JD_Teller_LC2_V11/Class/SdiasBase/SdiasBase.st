//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\SdiasManager\SdiasManager.h"
#include <.\lsl_st_hardwaretree.h>
#include "..\..\Class\SdiasBase\SdiasBase.h"

(*!
<Class
	Name               = "SdiasBase"
	Revision           = "1.41"
	GUID               = "{A44D11C6-5133-4AE2-9A40-4704050522AE}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(398,120)"
	Comment            = "The Base hardware class for SDIAS Modules.">
	<Channels>
		<Server Name="ClassState" GUID="{070CD62D-F011-403B-A668-118E2A1842A7}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Server shows the current Status of the Hardware Class."/>
		<Server Name="DeviceID" GUID="{1F67076F-D511-400A-8CEF-0F0E0579EC0B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Server shows the DeviceID of the Hardware Module."/>
		<Server Name="FPGAVersion" GUID="{D5EF701A-412A-4C34-AA2E-FFC7D82C2F86}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Server shows the actual FPGA Version of the Module in the format x.y&#13;&#10;&#13;&#10;e.g. 16#10 means v1.0"/>
		<Server Name="LEDControl" GUID="{FA9DCFC5-B668-4B7B-8E80-E0410DEF9ED8}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="Sets a LED on Hardware, to detect Module.&#13;&#10;0 ... LED off&#13;&#10;1 ... LED on&#13;&#10;2 ... blinking slow&#13;&#10;3 ... blinking fast"/>
		<Server Name="RetryCounter" GUID="{833C80D1-4726-4DCB-B1AB-C268D7D72245}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Number of Retries on SDIAS-Bus."/>
		<Server Name="SDOState" GUID="{1C3F8C9A-F083-486D-A096-B459EA29A017}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of the actual SDO Transmission."/>
		<Server Name="SerialNo" GUID="{68FBC413-E3CB-4059-BC09-1D975B4D4819}" Class="String" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Serial number of the Hardware Module."/>
		<Client Name="Place" Required="false" Internal="false" DefValue="0" Comment="Place of SDIAS Modul [0..63]."/>
		<Client Name="Required" Required="true" Internal="false" DefValue="1" Comment="0 = module is not required&#13;&#10;1 = module is required (CPU will crash if module is missing)"/>
		<Client Name="SdiasIn" Required="true" Internal="false" Comment="This Clients must be connected to a SDIAS_Out_[x] Server."/>
		<Client Name="SerialNoStr" Required="true" Internal="true"/>
		<Client Name="ToStdLib" Required="false" Internal="false" Comment="This client gets automatically connected to class _StdLib."/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\SdiasManager\SdiasManager.h" Include="true"/>
			<File Path=".\lsl_st_hardwaretree.h" Include="true"/>
			<File Path=".\Class\SdiasBase\SdiasBase.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.41" Date="12.03.2014" Author="RamAnd" Company="Sigmatek" Description="Added possibility to use internal logging functions via NewInst."/>
		<Dokumentation Revision="1.40" Date="22.01.2014" Author="PieSte" Company="Sigmatek" Description="Read Client Required and Place in Init SdiasBase"/>
		<Dokumentation Revision="1.30" Date="05.12.2013" Author="RamAnd" Company="Sigmatek" Description="Changed login mechanism to sdias manager class to be independent of bus accesses.&#13;&#10;Added method AddAccesses to define special accesses which are not covered by the SDIAS info block."/>
		<Dokumentation Revision="1.20" Date="30.08.2013" Author="RamAnd" Company="Sigmatek" Description="Added UpdateCy for SDIAS modules."/>
		<Dokumentation Revision="1.10" Date="01.08.2013" Author="ObeChr&#13;&#10;ObeChr&#13;&#10;RamAnd&#13;&#10;RamAnd&#13;&#10;RamAnd" Company="Sigmatek" Description="Renamed Variables&#13;&#10;Added Comments to Clients / Server / Methods / Types&#13;&#10;Created hardware paths for SDIAS Clients (needed for safety).&#13;&#10;The class now also shows the FPGA Version on a new Server.&#13;&#10;In the first realtime cycles the classes showed _ClassOk, but there was no actual IO information. Now the ClassState of SDIAS Clients is stored temporary during init and shown at the server after init."/>
		<Dokumentation Revision="1.0" Date="18.07.2013" Author="RamAnd" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="SdiasBase">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "SerialNoStr"
				GUID       = "{016F794C-857F-482F-8C65-B5EE24158A3F}"
				Class      = "String"
				Position   = "(210,270)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.SerialNoStr" Destination="SerialNoStr.Data"/>
			<Connection Source="this.SerialNo" Destination="SerialNoStr.Data" Vertices="(698,390),(526,360),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
SdiasBase : CLASS
	TYPE
	  t_b_SdiasFWState : BINT  //! <Type Public="true" Comment="Statebits of FW" Name="t_b_SdiasFWState"/>
	  [
	    1 VoltageNotOk,  //! <Type Comment="Problem with Supply-Voltage of uC." Name="t_b_SdiasFWState.VoltageNotOk"/>
	    2 NoSync,  //! <Type Comment="No Sync from SDIAS Message." Name="t_b_SdiasFWState.NoSync"/>
	    3 FlashDataCRCError,  //! <Type Comment="CRC-Error in Flash." Name="t_b_SdiasFWState.FlashDataCRCError"/>
	    4 RAMDataCRCError,  //! <Type Comment="CRC-Error in RAM." Name="t_b_SdiasFWState.RAMDataCRCError"/>
	    5 FlashUnsafe,  //! <Type Comment="No valid EEProm / Flash - Version used." Name="t_b_SdiasFWState.FlashUnsafe"/>
	  ];
#pragma pack(push, 1)
	  t_s_ErrorInfo : STRUCT  //! <Type Comment="ErrorInformations for SDO-Communication." Name="t_s_ErrorInfo"/>
	    Offset : HINT;  //! <Type Comment="Address-Offset of SDO-Command." Name="t_s_ErrorInfo.Offset"/>
	    Length : USINT;  //! <Type Comment="Data-Length of SDO-Command." Name="t_s_ErrorInfo.Length"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_SdiasFWStateStandard : STRUCT  //! <Type Public="true" Comment="Statebits of FW." Name="t_s_SdiasFWStateStandard"/>
	    ErrorBits : t_b_SdiasFWState;  //! <Type Comment="Statebits of FW." Name="t_s_SdiasFWStateStandard.ErrorBits"/>
	    Reserved : UINT;  //! <Type Comment="Reserved for Future Use." Name="t_s_SdiasFWStateStandard.Reserved"/>
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassState 	: SvrChCmd_t_e_VaranErrors;
	DeviceID 	: SvrCh_UDINT;
	FPGAVersion 	: SvrCh_HDINT;
	SerialNo 	: SvrChCmd_UDINT;
	RetryCounter 	: SvrCh_UDINT;
	LEDControl 	: SvrCh_DINT;
	SDOState 	: SvrChCmd_iprStates;
  //Clients:
	SdiasIn 	: CltChCmd_DINT;
	Place 	: CltCh_UDINT;
	Required 	: CltCh_DINT;
	ToStdLib 	: CltChCmd__StdLib;
	SerialNoStr 	: CltChCmd_String;
  //Variables:
		eInitState 	: t_e_VaranErrors;			//! <Variable Comment="Actual State of Initialisation of Module." Name="eInitState"/>
		eLastErrorCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Variable stores in case of an Error the SDO-Command." Name="eLastErrorCommand"/>
		eLastErrorInfo 	: t_s_ErrorInfo;			//! <Variable Comment="Variable stores in case of an Error the Informations about the SDO." Name="eLastErrorInfo"/>
		p_KernelLog 	: ^DINT;			//! <Variable Comment="Pointer to OS to access the Logging-Functions." Name="p_KernelLog"/>
		pHardwareTree 	: ^LSL_HARDWARETREE;			//! <Variable Comment="Pointer to OS to access Hardwaretree-Functions." Name="pHardwareTree"/>
		pObjectPath 	: ^USINT;			//! <Variable Comment="Pointer to Objectpath of Module." Name="pObjectPath"/>
		udActiveSDOCnt 	: UDINT;			//! <Variable Comment="Number of active SDOs." Name="udActiveSDOCnt"/>
		udBusTime 	: UDINT;			//! <Variable Comment="Used Cycletime [ns]" Name="udBusTime"/>
		usInitCounter 	: USINT;			//! <Variable Comment="Variable indicated the actual Number of the Init-Run." Name="usInitCounter"/>
		DefaultAccesses 	: t_SDIAS_DefaultAccesses;
  //Functions:
				//! <Function Comment="Constructor of Class." Name="SdiasBase"/>
	FUNCTION SdiasBase
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Init-Methode of Class.&#13;&#10;&#13;&#10;This Methode needs to get called. In case the Methode gets overwritten, a call needs to bet installed." Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Methode to add a Read-Access to Module." Name="AddRdAccess"/>
	FUNCTION AddRdAccess
		VAR_INPUT
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="AddRdAccess.hOffset"/>
			uLength 	: UINT;			//! <Variable Comment="Length of Data." Name="AddRdAccess.uLength"/>
			ppData 	: pVoid;			//! <Variable Comment="Pointer to the Memory for the Read-Data." Name="AddRdAccess.ppData"/>
			ppStateByte 	: pVoid;			//! <Variable Comment="Pointer to the StateWord of the Read-Data." Name="AddRdAccess.ppStateByte"/>
			ppControlByte 	: pVoid;			//! <Variable Comment="Pointer to the ControlWord of the Read-Data." Name="AddRdAccess.ppControlByte"/>
			pAccessHandle 	: ^UDINT := NIL;
			WaitForAccessHandle 	: UDINT := 0;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode to add a Write-Access to Module." Name="AddWrAccess"/>
	FUNCTION AddWrAccess
		VAR_INPUT
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="AddWrAccess.hOffset"/>
			uLength 	: UINT;			//! <Variable Comment="Length of Data." Name="AddWrAccess.uLength"/>
			ppData 	: pVoid;			//! <Variable Comment="Pointer to the Memory of the Write-Data." Name="AddWrAccess.ppData"/>
			ppStateByte 	: pVoid;			//! <Variable Comment="Pointer to the StateWord of the Write-Data." Name="AddWrAccess.ppStateByte"/>
			ppControlByte 	: pVoid;			//! <Variable Comment="Pointer to the ControlWord of the Write-Data." Name="AddWrAccess.ppControlByte"/>
			pAccessHandle 	: ^UDINT := NIL;
			WaitForAccessHandle 	: UDINT := 0;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode to execute a Read-SDO to Module." Name="StartReadSDO"/>
	FUNCTION StartReadSDO
		VAR_INPUT
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="StartReadSDO.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="StartReadSDO.usLength"/>
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command." Name="StartReadSDO.eCommand"/>
		END_VAR
		VAR_OUTPUT
			eRetcode 	: iprStates;			//! <Variable Comment="Indicates if the call of the Methode was successful." Name="StartReadSDO.eRetcode"/>
		END_VAR;
				//! <Function Comment="Methode to execute a Write-SDO to Module." Name="StartWriteSDO"/>
	FUNCTION StartWriteSDO
		VAR_INPUT
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="StartWriteSDO.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="StartWriteSDO.usLength"/>
			pWriteBuffer 	: ^USINT;			//! <Variable Comment="Pointer of Data to Write." Name="StartWriteSDO.pWriteBuffer"/>
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command." Name="StartWriteSDO.eCommand"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: iprStates;			//! <Variable Comment="Indicates if the call of the Methode was successful." Name="StartWriteSDO.dRetcode"/>
		END_VAR;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="Cyclic Update Methode which runs in PostScan." Name="UpdateCy"/>
	FUNCTION VIRTUAL GLOBAL UpdateCy;
	
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode should be used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to execute a Read-DA to Module." Name="ReadDirect"/>
	FUNCTION ReadDirect
		VAR_INPUT
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReadDirect.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReadDirect.usLength"/>
			pData 	: pVoid;			//! <Variable Comment="Pointer to Memory for the Read-Data." Name="ReadDirect.pData"/>
		END_VAR;
				//! <Function Comment="Methode to execute a Write-DA to Module." Name="WriteDirect"/>
	FUNCTION WriteDirect
		VAR_INPUT
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="WriteDirect.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="WriteDirect.usLength"/>
			pData 	: pVoid;			//! <Variable Comment="Pointer of Data to Write." Name="WriteDirect.pData"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
				//! <Function Comment="Methode to set directly a Text as Log-Message." Name="LogError"/>
	FUNCTION VIRTUAL LogError
		VAR_INPUT
			pMsg 	: ^CHAR;			//! <Variable Comment="Pointer to Log-Message." Name="LogError.pMsg"/>
		END_VAR;
				//! <Function Comment="Methode to set a Text with Parameters as Log-Message." Name="LogValue"/>
	FUNCTION VIRTUAL LogValue
		VAR_INPUT
			pString 	: ^CHAR;			//! <Variable Comment="Pointer to Log-Message." Name="LogValue.pString"/>
			udValue 	: UDINT;			//! <Variable Comment="ParameterValue 1 which is added to Log-Message.&#13;&#10;&#13;&#10;16#FFFFFFFF =&gt; Value is not used." Name="LogValue.udValue"/>
			udValue2 	: UDINT := 16#FFFFFFFF;			//! <Variable Comment="ParameterValue 2 which is added to Log-Message.&#13;&#10;&#13;&#10;16#FFFFFFFF =&gt; Value is not used." Name="LogValue.udValue2"/>
			udValue3 	: UDINT := 16#FFFFFFFF;			//! <Variable Comment="ParameterValue 3 which is added to Log-Message.&#13;&#10;&#13;&#10;16#FFFFFFFF =&gt; Value is not used." Name="LogValue.udValue3"/>
		END_VAR;
				//! <Function Comment="Methode set Log-Message in OS." Name="MyTrace"/>
	FUNCTION VIRTUAL MyTrace
		VAR_INPUT
			pFormat 	: ^CHAR;
			pTxt0 	: ^CHAR;
			pTxt1 	: ^CHAR;
			pTxt2 	: ^CHAR;
		END_VAR;
				//! <Function Comment="Methode can be used for a CRC16 Calculation." Name="CheckSum_16"/>
	FUNCTION GLOBAL CheckSum_16
		VAR_INPUT
			pData 	: ^UINT;			//! <Variable Comment="Pointer to Data for the Calculation." Name="CheckSum_16.pData"/>
			uiDataLength 	: UINT;			//! <Variable Comment="Length of the Data for the Calculation." Name="CheckSum_16.uiDataLength"/>
			uiCRCStart 	: UINT;			//! <Variable Comment="Start-Polynom for the Calculation." Name="CheckSum_16.uiCRCStart"/>
		END_VAR
		VAR_OUTPUT
			uiCRCCalculation 	: UINT;			//! <Variable Comment="Result of the Calculation." Name="CheckSum_16.uiCRCCalculation"/>
		END_VAR;
				//! <Function Comment="Methode to get this-Pointer of Object in HardwareTree." Name="GetObjectThisp"/>
	FUNCTION VIRTUAL GetObjectThisp
		VAR_INPUT
			pObjectPath 	: ^USINT;			//! <Variable Comment="Objectpath of the Module." Name="GetObjectThisp.pObjectPath"/>
		END_VAR
		VAR_OUTPUT
			pThis 	: UDINT;			//! <Variable Comment="This-Pointer of Object." Name="GetObjectThisp.pThis"/>
		END_VAR;
				//! <Function Comment="Methode to set this-Pointer of Object in HardwareTree." Name="SetObjectThisp"/>
	FUNCTION VIRTUAL SetObjectThisp
		VAR_INPUT
			pObjectPath 	: ^USINT;			//! <Variable Comment="Objectpath of the Module." Name="SetObjectThisp.pObjectPath"/>
			pThis 	: UDINT;			//! <Variable Comment="This-Pointer of Object." Name="SetObjectThisp.pThis"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment="Indicates if the call of the Methode was successful." Name="SetObjectThisp.dRetcode"/>
		END_VAR;
				//! <Function Comment="Call this Methode to get the Pointer to the Objectpath of this Module." Name="GetPointer2ObjectPath"/>
	FUNCTION VIRTUAL GLOBAL GetPointer2ObjectPath
		VAR_INPUT
			pThisPointerOverride 	: pVirtualBase := NIL;
		END_VAR
		VAR_OUTPUT
			p_us_ObjectPath 	: ^USINT;			//! <Variable Comment="Pointer to Objectpath of the Module." Name="GetPointer2ObjectPath.p_us_ObjectPath"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassState::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SerialNo::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SerialNo::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LEDControl::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SDOState::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String
#pragma usingLtd _StdLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SdiasBase::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SDIASBASE
1$UINT, 41$UINT, (SIZEOF(::SdiasBase))$UINT, 
7$UINT, 5$UINT, 0$UINT, 
TO_UDINT(3175101883), "SdiasBase", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::SdiasBase.ClassState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1096059024), "ClassState", 
(::SdiasBase.DeviceID.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4261957967), "DeviceID", 
(::SdiasBase.FPGAVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2929703442), "FPGAVersion", 
(::SdiasBase.SerialNo.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(1856804640), "SerialNo", 
(::SdiasBase.RetryCounter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3383993698), "RetryCounter", 
(::SdiasBase.LEDControl.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(288098344), "LEDControl", 
(::SdiasBase.SDOState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1646536137), "SDOState", 
//Clients:
(::SdiasBase.SdiasIn.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000010$UINT, TO_UDINT(3019270524), "SdiasIn", 
(::SdiasBase.Place.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2202636669), "Place", 
(::SdiasBase.Required.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(648558917), "Required", 
(::SdiasBase.ToStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2501598121), "ToStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::SdiasBase.SerialNoStr.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(321148131), "SerialNoStr", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
END_FUNCTION


#define USER_CNT_SdiasBase 16

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SdiasBase] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SdiasBase::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_SdiasBase, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #LogError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #LogValue();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #MyTrace();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #GetObjectThisp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #SetObjectThisp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetPointer2ObjectPath();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #GetTaskCfg();

#pragma warning (default : 74)
	ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, SerialNo.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #SerialNo::Read();
	vmt.CmdTable.Write		:= #SerialNo::Write();
	SerialNo.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SerialNo.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LEDControl.pMeth			:= StoreMethod( #M_RD_DIRECT(), #LEDControl::Write() );
	IF LEDControl.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, SDOState.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.NewInstr		:= #SDOState::NewInst();
	SDOState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SDOState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= SdiasBase();

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL SdiasBase::Init
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

#ifdef DEACTIVATED_LSL
  IF Place.Read() = DEACTIVATED_LSL THEN
    ClassState := _NoHardware;
    return;
  END_IF;
#endif

  usInitCounter += 1;  

  if usInitCounter = 1 then
  
    Place         := Place.Read();
    Required      := required.Read();
  
    MyPara.uiCmd := SDIAS_CMD_INIT_STATE_LOGIN;
    MyPara.aPara[0] := (#eInitState)$DINT;
    MyPara.aPara[1] := Place$DINT;
    MyPara.aPara[2] := this$DINT;
    MyPara.aPara[3] := (GetTaskCfg())$DINT;
    MyPara.aPara[4] := (#DefaultAccesses)$DINT;
    MyPara.aPara[5] := Required;
    if SdiasIn.NewInst(#MyPara, #MyResult) <> READY then
      LogValue("(SdiasBase::Init) Failed to login pointer to init state for SDIAS module at Place 0x{0}", Place);
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasBase::UpdateRt

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasBase::UpdateRtPostScan

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasBase::UpdateCy

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasBase::ClassState::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR

	ret_code := READY;
  
	CASE pPara^.uiCmd OF
//**********************************************************************************************************************************************************
		SDIAS_CMD_DEVICE_INFO:
      // save device ID and check it
      DeviceID := pPara^.aPara[0]$UINT;
      if CheckDeviceID(udID2Check:=DeviceID) then
        ret_code := READY;        
      else
        ret_code := ERROR;
      end_if;
      
      // save serial number
      SerialNoStr.WriteDataOff(udLen:=_StrLen(src:=pPara^.aPara[1]$^CHAR), udOff:=0, pData:=pPara^.aPara[1]$^CHAR);
      
      // save the Bus Time
      udBusTime := pPara^.aPara[2]$UDINT;
      
      // show the FPGA Version
      FPGAVersion := pPara^.aPara[3]$HSINT;
      
      return;
      
//**********************************************************************************************************************************************************
		SDIAS_CMD_INIT_ACCESSES:
      // if a module needs accesses beyond the ones in the info block, they should be defined in the derivation of the AddAccesses()-Method
      ret_code := AddAccesses();

//**********************************************************************************************************************************************************
    SDIAS_CMD_DATA_POINTER_AVAILABLE: // the pointer to the data are available now => use in derivation if needed

//**********************************************************************************************************************************************************
    SDIAS_CLT_CMD_LOG_MESSAGE:
      // check for valid pointer to message
      if pPara^.aPara[0] then
        LogError(pMsg:=pPara^.aPara[0]$^CHAR);
      end_if;

//**********************************************************************************************************************************************************
    SDIAS_CLT_CMD_LOG_VALUE:
      // check for valid pointer to message
      if pPara^.aPara[0] then
        LogValue(pString:=pPara^.aPara[0]$^CHAR, udValue:=pPara^.aPara[1]$UDINT, udValue2:=pPara^.aPara[2]$UDINT, udValue3:=pPara^.aPara[3]$UDINT);
      end_if;

//**********************************************************************************************************************************************************
    SDIAS_CLT_CMD_CREATE_MUTEX:
      pPara^.uiCmd := SDIAS_CMD_CREATE_MUTEX;
      ret_code := SdiasIn.NewInst(pPara, pResult);

//**********************************************************************************************************************************************************
    SDIAS_CLT_CMD_IS_VARAN_AVAILABLE:
      pPara^.uiCmd := SDIAS_CMD_IS_VARAN_AVAILABLE;
      ret_code := SdiasIn.NewInst(pPara, pResult);
      
//**********************************************************************************************************************************************************
  ELSE
    // we forward this message to the SDIAS Manager
    ret_code := SdiasIn.NewInst(pPara, pResult);
	END_CASE;

END_FUNCTION


FUNCTION SdiasBase::AddRdAccess
	VAR_INPUT
		hOffset 	: HINT;
		uLength 	: UINT;
		ppData 	: pVoid;
		ppStateByte 	: pVoid;
		ppControlByte 	: pVoid;
		pAccessHandle 	: ^UDINT;
		WaitForAccessHandle 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR
  
  MyPara.uiCmd := SDIAS_CMD_ADD_RD_ACCESS;
  MyPara.aPara[0] := this$DINT;
  MyPara.aPara[1] := Place$DINT;
  MyPara.aPara[2] := Required;
  MyPara.aPara[3] := hOffset;
  MyPara.aPara[4] := uLength;
  MyPara.aPara[5] := ppData$DINT;
  MyPara.aPara[6] := ppStateByte$DINT;
  MyPara.aPara[7] := ppControlByte$DINT;
  MyPara.aPara[8] := pAccessHandle$DINT;
  MyPara.aPara[9] := WaitForAccessHandle$DINT;

  ret_code := SdiasIn.NewInst(#MyPara, #MyResult);

  if ret_code <> READY then
    LogValue("(SdiasBase::AddRdAccess) Failed to add read access for SDIAS module at Place 0x{0}", Place);
  end_if;

END_FUNCTION


FUNCTION SdiasBase::AddWrAccess
	VAR_INPUT
		hOffset 	: HINT;
		uLength 	: UINT;
		ppData 	: pVoid;
		ppStateByte 	: pVoid;
		ppControlByte 	: pVoid;
		pAccessHandle 	: ^UDINT;
		WaitForAccessHandle 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR
  
  MyPara.uiCmd := SDIAS_CMD_ADD_WR_ACCESS;
  MyPara.aPara[0] := this$DINT;
  MyPara.aPara[1] := Place$DINT;
  MyPara.aPara[2] := Required;
  MyPara.aPara[3] := hOffset;
  MyPara.aPara[4] := uLength;
  MyPara.aPara[5] := ppData$DINT;
  MyPara.aPara[6] := ppStateByte$DINT;
  MyPara.aPara[7] := ppControlByte$DINT;
  MyPara.aPara[8] := pAccessHandle$DINT;
  MyPara.aPara[9] := WaitForAccessHandle$DINT;

  ret_code := SdiasIn.NewInst(#MyPara, #MyResult);

  if ret_code <> READY then
    LogValue("(SdiasBase::AddWrAccess) Failed to add write access for SDIAS module at Place 0x{0}", Place);
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasBase::ConnectEvent

  // overwrite this, if initmodule is used, so _NotInitialized can be shown during initialisation
  eInitState := _ClassOk;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasBase::DisconnectEvent

  SerialNoStr.Clear();
  DeviceID := 0;
  FPGAVersion := 0;
  
  // at the disconnect we can use directly the server
  ClassState := eInitState := _NoHardware;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasBase::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  
  // should be overwritten by derivation to initialize the module via service accesses in a state machine if necessary (return BUSY while initializing)
  eModuleInitState := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasBase::SerialNo::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	SerialNo := SerialNoStr.Data.Read();
	output := SerialNo;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasBase::SerialNo::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	SerialNo := input;
 	result := (SerialNoStr.Data.Write(SerialNo))$UDINT;

END_FUNCTION


FUNCTION SdiasBase::SdiasBase
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  VAR
    p_SSR			: ^LSL_SSR;
  END_VAR

  ClassState := eInitState := _NotInitialized;

  //get pointer for logging function
	if ( OS_CILGET( "SSR", #p_SSR ) ) then
    p_KernelLog := NIL;
  else
    //Log function is available
		p_KernelLog := ( p_SSR^.KernelLog )$^DINT;
  end_if;

  //get interface for hardwaretree functions
  if ( OS_CILGET(INTERFACE_HARDWARETREE, #pHardwareTree)) then
    pHardwareTree := NIL;
    
    LogError(pMsg:="Hardwaretree-Interface not found. A newer OS is required for Safety-Modules");
  end_if;

	ret_code := C_OK;

END_FUNCTION

#pragma warning(disable: 73)
FUNCTION VIRTUAL GLOBAL SdiasBase::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR

  bIsOK := TRUE;

END_FUNCTION
#pragma warning(default: 73)


FUNCTION VIRTUAL GLOBAL SdiasBase::LEDControl::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR
  
  // only 2 bits are used for LED control
  input := input AND 2#11;
  
  if input <> LEDControl then
    MyPara.uiCmd := SDIAS_CMD_CHANGE_LED_STATE;
    MyPara.aPara[0] := this$DINT;
    MyPara.aPara[1] := Place$DINT;
    MyPara.aPara[2] := input;
    
    if SdiasIn.NewInst(#MyPara, #MyResult) <> READY then
      LogValue("(SdiasBase::LEDControl::Write) Failed to change LED state for SDIAS module at Place 0x{0}", Place);
    end_if;
  end_if;
	LEDControl := input;
 	result := LEDControl;

END_FUNCTION


FUNCTION SdiasBase::StartReadSDO
	VAR_INPUT
		hOffset 	: HINT;
		usLength 	: USINT;
		eCommand 	: t_SDIAS_SDO_Cmd;
	END_VAR
	VAR_OUTPUT
		eRetcode 	: iprStates;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
    RdWrHead : t_SDIAS_SDO_RdWr_Head;
  END_VAR
  
  if usLength > SDIAS_MAX_SDO_READ_LENGTH then
    eRetcode := ERROR;
    return;
  end_if;

  RdWrHead.Offset := hOffset;
  RdWrHead.Length := usLength;
  
  MyPara.uiCmd := SDIAS_CMD_SDO_SEND_REQUEST;
  MyPara.aPara[0] := (#SDOState.pMeth)$DINT;
  MyPara.aPara[1] := eCommand$DINT;
  MyPara.aPara[2] := Place$DINT;
  MyPara.aPara[3] := sizeof(hOffset) + sizeof(usLength); // length of command
  MyPara.aPara[4] := (#RdWrHead)$DINT;

  eRetcode := SdiasIn.NewInst(#MyPara, #MyResult);

  if eRetcode = READY then
    udActiveSDOCnt += 1;
    SDOState := BUSY;
  else
    eLastErrorInfo.Offset := hOffset;
    eLastErrorInfo.Length := usLength;
    SDOState := ERROR;
  end_if;

END_FUNCTION


FUNCTION SdiasBase::StartWriteSDO
	VAR_INPUT
		hOffset 	: HINT;
		usLength 	: USINT;
		pWriteBuffer 	: ^USINT;
		eCommand 	: t_SDIAS_SDO_Cmd;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: iprStates;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
    TempSendBuf: ARRAY [0..127] OF USINT;
    RdWrHead : t_SDIAS_SDO_RdWr_Head;
  END_VAR
  
  if usLength > SDIAS_MAX_SDO_WRITE_LENGTH then
    dRetcode := ERROR;
    return;
  end_if;
  
  RdWrHead.Offset := hOffset;
  RdWrHead.Length := usLength;
  TempSendBuf[0]$t_SDIAS_SDO_RdWr_Head := RdWrHead;
  _memcpy(ptr1:=#TempSendBuf[3], ptr2:=pWriteBuffer, cntr:=usLength);
  
  MyPara.uiCmd := SDIAS_CMD_SDO_SEND_REQUEST;
  MyPara.aPara[0] := (#SDOState.pMeth)$DINT;
  MyPara.aPara[1] := eCommand$DINT;
  MyPara.aPara[2] := Place$DINT;
  MyPara.aPara[3] := sizeof(hOffset) + sizeof(usLength) + usLength; // length of command
  MyPara.aPara[4] := (#TempSendBuf)$DINT;

  dRetcode := SdiasIn.NewInst(#MyPara, #MyResult);

  if dRetcode = READY then
    udActiveSDOCnt += 1;
    SDOState := BUSY;
  else
    eLastErrorInfo.Offset := hOffset;
    eLastErrorInfo.Length := usLength;
    SDOState := ERROR;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasBase::SDOState::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR

	ret_code := ERROR;
  
	CASE pPara^.uiCmd OF
//**********************************************************************************************************************************************************
		SDIAS_CMD_SDO_RESPONSE:    
      // check if we're waiting for a response
      if udActiveSDOCnt then
        ret_code := ReceiveSDOResponse(eCommand:=pPara^.aPara[0]$t_SDIAS_SDO_Cmd,
                                       hOffset:=pPara^.aPara[1]$HINT,
                                       usLength:=pPara^.aPara[2]$USINT, 
                                       eResult:=pPara^.aPara[3]$iprStates, 
                                       pResponseBuffer:=pPara^.aPara[4]$^USINT, 
                                       ResponseLength:=pPara^.aPara[5]$USINT
                                       );
      end_if;
      
//**********************************************************************************************************************************************************
	END_CASE;

END_FUNCTION


FUNCTION SdiasBase::ReadDirect
	VAR_INPUT
		hOffset 	: HINT;
		usLength 	: USINT;
		pData 	: pVoid;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  MyPara.uiCmd := SDIAS_CMD_DA_RD_ACCESS;
  MyPara.aPara[0] := hOffset$DINT;
  MyPara.aPara[1] := usLength$DINT;
  MyPara.aPara[2] := pData$DINT;
  
  if SdiasIn.NewInst(#MyPara, #MyResult) <> READY then
    LogValue("(SdiasBase::ReadDirect) Direct read access failed for SDIAS module at Place 0x{0}", Place);
  end_if;

END_FUNCTION


FUNCTION SdiasBase::WriteDirect
	VAR_INPUT
		hOffset 	: HINT;
		usLength 	: USINT;
		pData 	: pVoid;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  MyPara.uiCmd := SDIAS_CMD_DA_WR_ACCESS;
  MyPara.aPara[0] := hOffset$DINT;
  MyPara.aPara[1] := usLength$DINT;
  MyPara.aPara[2] := pData$DINT;
  
  if SdiasIn.NewInst(#MyPara, #MyResult) <> READY then
    LogValue("(SdiasBase::WriteDirect) Direct write access failed for SDIAS module at Place 0x{0}", Place);
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SdiasBase::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR

  udActiveSDOCnt -= 1;

  // if it succeeded, decrement the number of open requests
  if eResult = READY then
    if udActiveSDOCnt = 0 then
      // if the last one has succeeded, show it on the state server
      SDOState := READY;
    end_if;
  else
    // an error occured while performing the operation
    
    // save the error information
    eLastErrorInfo.Offset := hOffset;
    eLastErrorInfo.Length := usLength;
    eLastErrorCommand := eCommand;
    
    SDOState := ERROR;
  end_if;
  
  ret_code := READY;
  
END_FUNCTION


FUNCTION VIRTUAL SdiasBase::LogError
	VAR_INPUT
		pMsg 	: ^CHAR;
	END_VAR
  VAR
    sz_name : ARRAY [ 0..255 ] OF CHAR;
  END_VAR

  _GetObjName( this, #sz_name[ 0 ] );
  
  MyTrace(pFormat:="ObjectName {0}: {1}", pTxt0:=(#sz_name[ 0 ])$^CHAR, pTxt1:= pMsg, pTxt2:=NIL);

END_FUNCTION


FUNCTION VIRTUAL SdiasBase::LogValue
	VAR_INPUT
		pString 	: ^CHAR;
		udValue 	: UDINT;
		udValue2 	: UDINT;
		udValue3 	: UDINT;
	END_VAR
  VAR
    TempStr       : ARRAY [0..99] OF CHAR;
    TempStr2      : ARRAY [0..99] OF CHAR;
    TempStr3      : ARRAY [0..99] OF CHAR;
    TraceVal      : USINT;
    sz_name       : ARRAY [ 0..255 ] OF CHAR;
    TmpWithObjName: ARRAY [ 0..255 ] OF CHAR;
  END_VAR

  // number of values
  TraceVal := 1;

  _itoa(udValue, #TempStr[0]);
  
  if pString <> NIL then
    _GetObjName( this, #sz_name[ 0 ] );
    _strcpy(dest:=#TmpWithObjName[0], src:="ObjectName ");
    _strcat(dest:=#TmpWithObjName[0], src:=#sz_name[0]);
    _strcat(dest:=#TmpWithObjName[0], src:=": ");
    _strcat(dest:=#TmpWithObjName[0], src:=pString);
    
    if udValue2 <> 16#FFFFFFFF then
      _itoa(udValue2, #TempStr2[0]);
      TraceVal += 1;
    end_if;

    if udValue3 <> 16#FFFFFFFF then
      _itoa(udValue3, #TempStr3[0]);
      TraceVal += 1;
    end_if;
    
    case TraceVal of
      1:MyTrace(pFormat:=#TmpWithObjName[0], pTxt0:=#TempStr[0], pTxt1:=NIL, pTxt2:=NIL);
      2:MyTrace(pFormat:=#TmpWithObjName[0], pTxt0:=#TempStr[0], pTxt1:=#TempStr2[0], pTxt2:=NIL);
      3:MyTrace(pFormat:=#TmpWithObjName[0], pTxt0:=#TempStr[0], pTxt1:=#TempStr2[0], pTxt2:=#TempStr3[0]);        
    end_case;
  else
    MyTrace(pFormat:="<invalid string>", pTxt0:=NIL, pTxt1:=NIL, pTxt2:=NIL);
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL SdiasBase::MyTrace
	VAR_INPUT
		pFormat 	: ^CHAR;
		pTxt0 	: ^CHAR;
		pTxt1 	: ^CHAR;
		pTxt2 	: ^CHAR;
	END_VAR
  VAR
    nLen      : UDINT;
    pChr      : ^CHAR;
    nTxt      : UDINT;
    nRpl      : UDINT;
    pTxt      : ^CHAR;
    pText     : ^CHAR;
    FormText  : ARRAY [0 .. 255] OF CHAR;
  END_VAR

  // this method is a workaround for the TRACE message limitation problem

  pText := #FormText[0];

  _memset(dest:=#FormText[0], usByte:=0, cntr:=256); // to keep the zero termination

  _strncpy(pText, pFormat, 250);
  nLen  := _strlen(pText);
  pChr  := pText;
  
  WHILE nLen DO
    IF pChr^ = '{' THEN         // works for the first 10 replacement texts (single digit numbers)
      nTxt  := (pChr+1)^ - '0';
      CASE nTxt OF
        0:  pTxt  := pTxt0;
        1:  pTxt  := pTxt1;
        2:  pTxt  := pTxt2;
      ELSE
        pTxt  := "INV";
      END_CASE;
      nRpl  := _strlen(pTxt);
      if nLen - 3 + nRpl > 250 then
        pTxt := "LEN";  // replace the replacement text with "LEN" to see that we're out of length for this string
        nRpl := 3;
      end_if;
      _memmove(pChr + nRpl, pChr + 3, nLen);
      _memcpy(pChr, pTxt, nRpl);
      pChr  += nRpl;  // next character to parse is after the replacement text
      nLen  -= 3;     // the remaining length of the format string is decremented by 3
      if nLen > 250 then  // catch overrun of nLen
        nLen := 0;
      end_if;
    ELSE
      pChr  += 1;
      nLen  -= 1;
    END_IF;
  END_WHILE;

  TRACE(#FormText[0]);
  if ( p_KernelLog ) then
    OS_KERNELLOG0(#FormText[0]);
  end_if;

END_FUNCTION


FUNCTION GLOBAL SdiasBase::CheckSum_16
	VAR_INPUT
		pData 	: ^UINT;
		uiDataLength 	: UINT;
		uiCRCStart 	: UINT;
	END_VAR
	VAR_OUTPUT
		uiCRCCalculation 	: UINT;
	END_VAR
  VAR
  	TmpCrc : UINT;
    idxI   : UINT;
    Carry  : USINT;
  END_VAR
  
	TmpCrc := uiCrcStart;			

  for idxI := 0 to (uiDataLength - 1) by 2 do
		Carry := ((TmpCrc SHR 15) AND 0x01)$USINT;
		TmpCrc := ((TmpCrc SHL 1) AND 0xFFFE);
		TmpCrc += (pData + idxI)^;
		TmpCrc += Carry;
  end_for;

	uiCrcCalculation := TmpCrc;
  
END_FUNCTION


FUNCTION VIRTUAL SdiasBase::GetObjectThisp
	VAR_INPUT
		pObjectPath 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		pThis 	: UDINT;
	END_VAR
  
  if ( pHardwareTree <> NIL ) then
    pThis := HWT_iGetObjectThisp(0,pObjectPath);
  else
    pThis := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SdiasBase::SetObjectThisp
	VAR_INPUT
		pObjectPath 	: ^USINT;
		pThis 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
  
  if ( pHardwareTree <> NIL ) then
    dRetcode := HWT_iSetObjectThisp(0,pObjectPath,pThis);
  else
    dRetcode := 0;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasBase::GetPointer2ObjectPath
	VAR_INPUT
		pThisPointerOverride 	: pVirtualBase;
	END_VAR
	VAR_OUTPUT
		p_us_ObjectPath 	: ^USINT;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
    p_us_PreviousPath : ^USINT;
  END_VAR

  if ( pObjectPath = NIL ) then
  
    if ( Place <= SDIAS_MAX_PLACE_NR ) then
    
      MyPara.uiCmd := SDIAS_CMD_GET_HW_PATH;      
      if SdiasIn.NewInst(#MyPara, #MyResult) <> READY then
        LogError("(SdiasBase::GetPointer2ObjectPath) Failed to get hardware path of preceding module");
      else
        p_us_PreviousPath := MyResult.aData[4]$^USINT;

        //alloc memory
        pObjectPath := ( ToStdLib.Malloc( size := p_us_PreviousPath^ + 3 ) )$^USINT;

        ToStdLib.MemCpy ( dest 		:= pObjectPath
                        , source	:= p_us_PreviousPath
                        , size		:= p_us_PreviousPath^ + 1
                        );

        // increase length
        pObjectPath^$UINT += 2;
        
        //insert escape sequence for SDIAS
        ( pObjectPath + pObjectPath^ - 1)^ := HWT_ESCAPE_SDIAS;

        //insert SDIAS place
        ( pObjectPath + pObjectPath^)^ := Place$USINT;

        if pThisPointerOverride then
          //register object path in OS
          SetObjectThisp(pObjectPath:=pObjectPath, pthis:=pThisPointerOverride$UDINT);
        else
          //register object path in OS
          SetObjectThisp(pObjectPath:=pObjectPath, pthis:=this$UDINT);
        end_if;
      end_if;
    else
      p_us_ObjectPath := NIL;
    end_if;    
  end_if;
  
  p_us_ObjectPath := pObjectPath;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasBase::AddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  
  // overload this if the module needs special accesses (not covered by default accesses according to info block)
  eModuleInitState := READY;

END_FUNCTION


FUNCTION VIRTUAL SdiasBase::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  // define in derivation which tasks are needed

// like this
//  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_RT_POST OR SDIAS_TASK_MASK_CY;

  TaskCfg := 0;

END_FUNCTION
