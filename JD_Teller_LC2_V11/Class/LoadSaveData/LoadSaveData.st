//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "LoadSaveData"
	Revision           = "1.0"
	GUID               = "{E5E73053-408B-4C8C-B724-9A0DB4C79456}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(330,120)"
	Comment            = "Jvd 28-8-2013&#13;&#10;&#13;&#10;Deze class bezit methodes om een datablock te laden en op te slaan op file&#13;&#10;&#13;&#10;Dus:&#13;&#10;Datablock -&gt; file (save)&#13;&#10;file -&gt; Datablock (load)">
	<Channels>
		<Server Name="ClassSvr" GUID="{C3E4550E-C07F-41A5-88BB-44F50DE0BED2}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="FileOs" Required="false" Internal="false" Comment="Interface to Os file"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\DataManager_Mada_Load\FileBase.h" Include="false"/>
			<File Path=".\Class\DataManager_Mada_Load\AsciiChr.h" Include="false"/>
			<File Path=".\Class\DataManager_Mada_Load\LSD.vov"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="JD" Author="JvD"/>
		<Dokumentation Revision="1.0" Date="28-8-2013&#13;&#10;" Author="JvD" Company="JD" Description="StartVersie"/>
	</RevDoku>
</Class>
*)
LoadSaveData : CLASS
	TYPE
	  TestStr : STRUCT
	    Letter : CHAR;
	    SourcePtr : HDINT;
	    DestPtr : HDINT;
	    Offset : DINT;
	  END_STRUCT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
	FileOs 	: CltChCmd__FileSys;
  //Variables:
		FileID 	: DINT;
		FileSize 	: DINT;
		vFilename : ARRAY [0..255] OF CHAR;

		Helptext1 : ARRAY [0..255] OF CHAR;

		Helptext2 : ARRAY [0..255] OF CHAR;

		Helptext3 : ARRAY [0..255] OF CHAR;

		PosCounter1 	: DINT;
		posCounter2 	: DINT;
		MyString : ARRAY [0..cMaxAsciiLine] OF CHAR;

		ValueText 	: TextString;
		LineCount 	: DINT;
		SaveNu 	: DINT;
		LoadNu 	: DINT;
		Teller 	: DINT;
		vParameter : ARRAY [0..255] OF CHAR;

		NrVar_Load 	: DINT;
		NrOfErrrors 	: DINT;
		Index : ARRAY [0..9] OF CHAR;

		Test 	: DINT;
		FileState 	: DINT;
		Status_LoadSave 	: DINT;
		Karel 	: DINT;
  //Functions:
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="BuildValue2Ascii"/>
	FUNCTION VIRTUAL GLOBAL BuildValue2Ascii
		VAR_INPUT
			Value 	: DINT;			//! <Variable Comment="Value to be converted to an Ascii string" Name="BuildValue2Ascii.Value"/>
			Dest 	: ^CHAR;			//! <Variable Comment="Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine." Name="BuildValue2Ascii.Dest"/>
			Offset 	: DINT;			//! <Variable Comment="Offset in destination string, must be less than cMaxAsciiLine." Name="BuildValue2Ascii.Offset"/>
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of string without &apos;nil&apos;." Name="BuildValue2Ascii.Size"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="BuildEOL"/>
	FUNCTION VIRTUAL GLOBAL BuildEOL
		VAR_INPUT
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Clears a Ascii text line.&#13;&#10;A line is cleared by placing a &apos;Nil&apos; Caracter at&#13;&#10; the first position of the string.&#13;&#10;" Name="ClearLine"/>
	FUNCTION VIRTUAL ClearLine
		VAR_INPUT
			Dest 	: ^CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL OpenFile
		VAR_INPUT
			FileName 	: ^CHAR;
			Attribute 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;			//! <Variable Comment="Help" Name="OpenFile.Result"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="CloseFile"/>
	FUNCTION VIRTUAL GLOBAL CloseFile
		VAR_OUTPUT
			Result 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Write a string of length length from source to file.&#13;&#10;" Name="WriteFile"/>
	FUNCTION VIRTUAL GLOBAL WriteFile
		VAR_INPUT
			Source 	: ^CHAR;
			Length 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
	
	FUNCTION ClearHelptext1;
	
	FUNCTION ClearHelptext2;
	
	FUNCTION DATA_WRITE
		VAR_INPUT
			pParameter 	: ^CHAR;
			Value 	: DINT;
			SizeDataPtr 	: UDINT;
			pReadyProcPtr 	: ^DINT;
		END_VAR;
	
	FUNCTION SAVE_DATA
		VAR_INPUT
			pDataPtr 	: ^DINT;
			SizeDataPtr 	: UDINT;
			pReadyProcPtr 	: ^DINT;
		END_VAR;
	
	FUNCTION LOAD_DATA
		VAR_INPUT
			pDataPtr 	: ^DINT;
			SizeDataPtr 	: UDINT;
			pReadyProcPtr 	: ^DINT;
		END_VAR;
	
	FUNCTION Count_Lines;
	
	FUNCTION DATA_READ_DINT
		VAR_INPUT
			pParameter 	: ^CHAR;
			SizeDataPtr 	: UDINT;
			pReadyProcPtr 	: ^DINT;
		END_VAR
		VAR_OUTPUT
			Value 	: DINT;
		END_VAR;
	
	FUNCTION ConvAscii2Value
		VAR_INPUT
			Source_ 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Value 	: DINT;
		END_VAR;
				//! <Function Comment="Deze methode saved een variabelestructuur op disk&#13;&#10;&#13;&#10;opbouw file&#13;&#10;&#13;&#10;0=ByteValueAdress 0&#13;&#10;1=ByteValueAdress 1&#13;&#10;2=ByteValueAdress 2&#13;&#10;3=ByteValueAdress 3&#13;&#10;4=ByteValueAdress 4&#13;&#10;&#13;&#10;" Name="SaveDataBlock"/>
	FUNCTION GLOBAL SaveDataBlock
		VAR_INPUT
			pFileName 	: ^CHAR;			//! <Variable Comment="Geef pointer naar filename&#13;&#10;&#13;&#10;voorbeeld&#13;&#10;&quot;D:\rec\file.md&quot;" Name="SaveDataBlock.pFileName"/>
			pDataPtr 	: ^DINT;			//! <Variable Comment="Pointer naar 1e element van het datablok" Name="SaveDataBlock.pDataPtr"/>
			SizeDataPtr 	: UDINT;			//! <Variable Comment="Grootte van het datablock in bytes" Name="SaveDataBlock.SizeDataPtr"/>
			pReadyProcPtr 	: ^DINT;			//! <Variable Comment="Geef pointer van een variabele om het voortgangs percentage te monitoren" Name="SaveDataBlock.pReadyProcPtr"/>
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;			//! <Variable Comment="&#13;&#10;0: error&#13;&#10;1: ok&#13;&#10;" Name="SaveDataBlock.Result"/>
		END_VAR;
	
	FUNCTION GLOBAL LoadDataBlock
		VAR_INPUT
			pFileName 	: ^CHAR;			//! <Variable Comment="Geef pointer naar filename&#13;&#10;&#13;&#10;voorbeeld&#13;&#10;&quot;D:\rec\file.md&quot;" Name="LoadDataBlock.pFileName"/>
			pDataPtr 	: ^DINT;			//! <Variable Comment="Pointer naar 1e element van het datablok" Name="LoadDataBlock.pDataPtr"/>
			SizeDataPtr 	: UDINT;			//! <Variable Comment="Grootte van het datablock in bytes" Name="LoadDataBlock.SizeDataPtr"/>
			pReadyProcPtr 	: ^DINT;			//! <Variable Comment="Geef pointer van een variabele om het voortgangs percentage te monitoren" Name="LoadDataBlock.pReadyProcPtr"/>
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;			//! <Variable Comment="0: error&#13;&#10;1: ok" Name="LoadDataBlock.Result"/>
		END_VAR;
	
	FUNCTION GLOBAL ReadFile
		VAR_INPUT
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL Read2CR
		VAR_INPUT
			Source_ 	: ^CHAR;
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL FileDelete
		VAR_INPUT
			FileName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB LoadSaveData::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_LOADSAVEDATA
1$UINT, 0$UINT, (SIZEOF(::LoadSaveData))$UINT, 
1$UINT, 1$UINT, 0$UINT, 
TO_UDINT(809080914), "LoadSaveData", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::LoadSaveData.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
(::LoadSaveData.FileOs.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(523274688), "FileOs", TO_UDINT(545279513), "_FileSys", 1$UINT, 14$UINT, 
END_FUNCTION


#define USER_CNT_LoadSaveData 6

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_LoadSaveData] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION LoadSaveData::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_LoadSaveData, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #BuildValue2Ascii();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #BuildEOL();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #ClearLine();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #OpenFile();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #CloseFile();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #WriteFile();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION




 


FUNCTION GLOBAL LoadSaveData::SaveDataBlock
	VAR_INPUT
		pFileName 	: ^CHAR;
		pDataPtr 	: ^DINT;
		SizeDataPtr 	: UDINT;
		pReadyProcPtr 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		Result 	: DINT;
	END_VAR
 

  _memset(dest:=#vFilename[0], usByte:=0, cntr:=256); 
  _strcpy(dest:=#vFilename[0], src:=pFileName);
  Status_LoadSave := 0;
  pReadyProcPtr^:= 0;
  Teller := 0;
  _strcpy(dest:=#vFilename[0], src:=pFileName);
  FileID := OpenFile(#vFilename[0], ATT_CREATE_ALWAYS);
  
  if    FileID <=0 then
        TRACE0 ("File {0} niet aangemaakt op schijf",#vFilename[0]);
        TRACE ("Header kan niet geschreven worden...");
  else
        // data schrijven
        TRACE ("Data schrijven...");
        SAVE_DATA(pDataPtr:=pDataPtr, SizeDataPtr:=SizeDataPtr, pReadyProcPtr:=pReadyProcPtr);
        
        
        // Bestand terug sluiten.
        CloseFile();
        TRACE0 ("Bestand {0} sluiten.",#vFilename[0]);
        
        Result := 1;
  end_if;   

    
END_FUNCTION



FUNCTION GLOBAL LoadSaveData::LoadDataBlock
	VAR_INPUT
		pFileName 	: ^CHAR;
		pDataPtr 	: ^DINT;
		SizeDataPtr 	: UDINT;
		pReadyProcPtr 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		Result 	: DINT;
	END_VAR


  _memset(dest:=#vFilename[0], usByte:=0, cntr:=256); 
  _strcpy(dest:=#vFilename[0], src:=pFileName);
  Status_LoadSave := 0;
  pReadyProcPtr^:= 0;
  Teller := 0;
  LineCount :=0;                                                                                  
  Count_Lines();                                                                                     
  NrOfErrrors := 0;                                                                                                  
  FileID := CloseFile(); // sluiten ingeval de file nog mocht openstaan//                            
  FileID := OpenFile(#vFilename[0], ATT_READ_WRITE); // file openen bij leesinstructie// 
  
  if    Filestate = -2 then//                                                                           
        TRACE0 ("Bestand {0} niet gevonden op schijf.",#vFilename[0]);//   
        Result := 0;  
  elsif FileState >= 0 then  
        LOAD_DATA(pDataPtr:=pDataPtr, SizeDataPtr:=SizeDataPtr, pReadyProcPtr:=pReadyProcPtr);
        if    NrOfErrrors = 1 then
              Result := 1;
        else      
              Result := 0;    
        end_if;
  end_if;         

   
        
END_FUNCTION













FUNCTION VIRTUAL GLOBAL LoadSaveData::BuildEOL
	VAR_INPUT
		Dest 	: ^CHAR;
		Offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR

  Size	:= 0;
  If    (Offset + 2) <= cMaxAsciiLine Then
        (Dest + Offset)^	:= cCR;
        Offset	+= 1;
        (Dest + Offset)^	:= cLF;
        Offset	+= 1;
        (Dest + Offset)^	:= Nil$Char;
        Size	:= 2;
  End_If;

END_FUNCTION //VIRTUAL GLOBAL DataManager_Mada_Load::BuildEOL
//[#ENGLISH]
//Copy a string from begin to a Seperator or a 'Nil'.
//[>Source]Pointer to a string where the Ascii string is to be found.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of string without 'nil'.
 //VIRTUAL GLOBAL DataManager_Mada_Load::Read2Nil
//[#ENGLISH]
//Copy a string from begin to a CR or a 'Nil'.
//[>Source]Pointer to a string where the Ascii string is to be found.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of string without 'nil'.

FUNCTION GLOBAL LoadSaveData::Read2CR
	VAR_INPUT
		Source_ 	: ^CHAR;
		Dest 	: ^CHAR;
		Offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR

  VAR
    i		: DINT;
  END_VAR

  Size:= 0;
  Dest	+= Offset;
  For   i:= Offset to cMaxAsciiLine Do
        If    Offset < cMaxAsciiLine Then
              Dest^	:= Source_^;
              Case Source_^ of
              0,  cCR:
                  Dest^	:= Nil$Char;
                  i	:= cMaxAsciiLine;
              Else
                  Size	+= 1;
                  Offset	+= 1;
                  Source_	+= 1;
                  Dest	+= 1;
              End_Case;
        Else
              Dest^	:= Nil$Char;
              Size:= 0;
              i	:= cMaxAsciiLine;
        End_If;
  End_For; 
  
END_FUNCTION

 //VIRTUAL GLOBAL DataManager_Mada_Load::Read2CR
//[#ENGLISH]
//Copy a string from begin to a Seperator or a 'Nil','CR','LF'.
//[>Source]Pointer to a string where the Ascii string is to be found.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of string without 'nil'.
 //VIRTUAL GLOBAL DataManager_Mada_Load::Read2Seperator
//[#ENGLISH]
//[>Value]Value to be converted to an Ascii string
//[>Dest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine
//[<Size]0= Can't place value else size of string without 'nil'

FUNCTION VIRTUAL LoadSaveData::ClearLine
	VAR_INPUT
		Dest 	: ^CHAR;
	END_VAR

  #IfDef TestJE
    Var
      i	: Dint;
    End_Var;
    // Fill with space for test
    For   i:= 0 to cMaxAsciiLine Do
          Dest^	:= cTestChar;	// Nil$Char;
          Dest	+= 1;
    End_For;
    // Last is nil
    Dest	-= 1;
    Dest^	:= Nil$Char;
  #Else
    Dest^	:= Nil$Char;
  #EndIf

END_FUNCTION //VIRTUAL GLOBAL DataManager_Mada_Save::Clearline

FUNCTION VIRTUAL GLOBAL LoadSaveData::BuildValue2Ascii
	VAR_INPUT
		Value 	: DINT;
		Dest 	: ^CHAR;
		Offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR
  Var
    i		: Dint;
    ii		: Dint;
    Temp	: Array[0..11] of CHAR;
  End_Var

  Size	:= -1;
  // Test for sign
  If    Value< 0 then
        If    Offset < cMaxAsciiLine Then
              (Dest + Offset)^	:= '-';
              Offset	+= 1;
              Size	+= 1;
              Value	*= -1;
        Else
              offset	:= cMaxAsciiLine;
        End_If;
  End_If;
  // Convert to Ascii
  i	:= 0;
  ii	:= 10;
  Temp[11]:= Nil$Char;
  Repeat
        Temp[ii]	:= To_Usint( Value mod 10)+ '0';
        Value	/= 10;
        i		+= 1;
        ii		-= 1;
  Until Value= 0 End_Repeat;

  // always 1 char
  //If i<= 0 Then i:= 1; End_If;
  // Place most left
  If    Offset+ i<= cMaxAsciiLine Then
        For   ii:= 11-i to 11 Do
              (Dest + Offset)^	:= Temp[ii];
              Offset	+= 1;
              Size	+= 1;
        End_For;
  Else
        size	:= 0;
  End_If;

END_FUNCTION //VIRTUAL GLOBAL DataManager_Mada_Load::BuildValue2Ascii
//[#ENGLISH]
//Gets system time and convets it to an Ascii string.
//
//Mode determins the format.
//	0	: 	"hh:mm:ss" in 24 hour mode.	( Default)
//	1	: 	"hh:mm:ss xm" in 12 hour mode.
//	See "BuildTime()" for further information on mode.
//
// 24 hour mode is from 00:01 to 24:00.
// 12 hour mode is with "am" (00:00 to 11:59) and "pm" (12:00 to 23:59).
//				But the time is from 00:00 to 12:59 and than from 01:00 to 23:59.
//
//[>Mode]Time format. If an un implemented mode is selected then mode 0 will be used
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine
//[<Size]0= Can't place value else size of string without 'nil'
 //VIRTUAL GLOBAL DataManager_Mada_Load::BuildSysTime
//[#ENGLISH]
//Convert the source time to an Ascii string.
//
//Mode determins the format.
//	0	: 	"hh:mm:ss" in 24 hour mode.	( Default)
//	1	: 	"hh:mm:ss xm" in 12 hour mode.
//	2	:	"[h]h:[m]m:[s]s xm" in 12 hour mode.
//	3	:	?
//
// 24 hour mode is from 00:01 to 24:00.
// 12 hour mode is with "am" (00:00 to 11:59) and "pm" (12:00 to 23:59).
//				But the time is from 00:00 to 12:59 and than from 01:00 to 23:59.
//
//[>Mode]Time format. If an un implemented mode is selected then mode 0 will be used
//[>Source]Time to be converted in a standerd time format.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine
//[<Size]0= Can't place value else size of string without 'nil'
 //VIRTUAL GLOBAL DataManager_Mada_Load::BuildTime
//[#ENGLISH]
//Convert the source date to an Ascii string.
//
//Mode determins the format.
//	0	: 	"yyyy-mm-dd"	( Default)
//	1	: 	"dd-mm-yyyy".
//	2	:	?
//
//[>Mode]Date format. If an un implemented mode is selected then mode 0 will be used.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of string without 'nil'.
 //VIRTUAL GLOBAL DataManager_Mada_Load::BuildSysDate

//[#ENGLISH]
//Convert the source date to an Ascii string.
//
//Mode determins the format.
//	0	: 	"yyyy-mm-dd"	( Default)
//	1	: 	"dd-mm-yyyy".
//	2	:	"[d]d-[m]m-[yyy]y"
//	3	:	?
//
//[>Mode]Date format. If an un implemented mode is selected then mode 0 will be used.
//[>Source]Date to be converted in a standerd date format.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of string without 'nil'.
 //VIRTUAL GLOBAL DataManager_Mada_Load::BuildDate
//[#ENGLISH]
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine
//[<Size]0= Can't place value else size of string without 'nil'
 //VIRTUAL GLOBAL DataManager_Mada_Load::BuildSeperator
//[#ENGLISH]
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[>Source]String to be copied to an Ascii string.
//[>Dest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Length]Length of the string to be copied.
//[<Size]0= Can't place value else size of string without 'nil'.
 //VIRTUAL GLOBAL DataManager_Mada_Load::StringCopy


FUNCTION VIRTUAL GLOBAL LoadSaveData::OpenFile
	VAR_INPUT
		FileName 	: ^CHAR;
		Attribute 	: UDINT;
	END_VAR
	VAR_OUTPUT
		Result 	: DINT;
	END_VAR

  // Only 1 handle per time in the "DataManager_Mada_Load" Class
  If    FileID <= 0 Then
        // Open the file
        If    Attribute= ATT_CREATE_ALWAYS Then
              FileID	:= Result	:= FileOs	:= FileOs.FileOpen( FileName, Attribute);
        Else
              FileID	:= Result	:= FileOs	:= FileOs.FileOpen( FileName, Attribute);
        End_If;	
        If    FileID <= 0 Then
              Filestate		:= -2;
              Trace("'DataManager_Load::OpenFile' -2: Can't open file.");
              Trace( FileName);	// The file that could not be opend.
        Else
              FileSize	:= 0;
        End_If;
  Else
        Filestate	:= -1;
        Trace("'DataManager_Load::OpenFile' -1: Can't open a second file per 'DataManager_Load' Class.");
  End_If;

END_FUNCTION //VIRTUAL GLOBAL DataManager_Mada_Load::OpenFile


FUNCTION VIRTUAL GLOBAL LoadSaveData::CloseFile
	VAR_OUTPUT
		Result 	: DINT;
	END_VAR

  If    FileID> 0 Then
        FileOs.FileClose(FileID);
        FileID	:= 0;
  End_If;
  Result	:= FileID;

END_FUNCTION //VIRTUAL GLOBAL DataManager_Mada_Load::CloseFile





//[#ENGLISH]
//This method looks for Names in a DataTable to be found by a name type.
// The table has the following formats
//		SizeOf( Table)			// [DINT] The size of the data table is automaticaly generated by LASAL and not visable.
//		'x',"My First Text",
//		'x',"My Second Text",
//		'x',"...",
// 'x' 			is the name type.
// "..."		is the name to be copied
// Always a ',' at the end. This places a NIL char at the end of the string.
//[>NameType]Type of name to be found
//[>Source]Pointer to the begin of a DataTable of the discribed format.
//[>SOffset]Offset in source Table. This is nessesary to find next name of the same "NameType".
//[<Offset]0..4= Can't find the name type. For the header of the file is already added.
 //VIRTUAL GLOBAL DataManager_Mada_Load::FindName
//[#ENGLISH]
//Write a string of length length from source to file.
//[>Source]Pointer to a string where the Ascii string is to be found.
//[>Length]Length of thestring to be copied to file
//[<Size]0= Can't place value else size of string without 'nil'.
FUNCTION VIRTUAL GLOBAL LoadSaveData::WriteFile
	VAR_INPUT
		Source 	: ^CHAR;
		Length 	: DINT;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR

  Size	:= 0;
  If    FileID > 0 Then
        Size	:= FileOs	:= To_Dint( FileOs.FileWrite( FileID, Source, To_UDint( Length)));
        FileSize	+= Size;
        If    Size<> Length Then
              Filestate	:= -5;
              Trace( "'DataManager_Load::WriteFile' -5 Can't write the whole word to file.");
        End_If;
  Else
        Filestate	:= -3;
        Trace( "'DataManager_Load::WriteFile' -3 Can't write to file because there is no handle.");
  End_If;

END_FUNCTION //VIRTUAL GLOBAL DataManager_Mada_Load::WriteFile
//[#ENGLISH]
//Read a string from file to a LF or a 'Nil'. CR must be followed by a LF.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of string without 'nil'.
 //VIRTUAL GLOBAL DataManager_Mada_Load::ReadFile


FUNCTION LoadSaveData::ClearHelptext1
VAR
	i: INT;
END_VAR
  for i := 0 to 255 do // tekst eerst wissen
      Helptext1[i] :=0;
  end_for;
END_FUNCTION


FUNCTION LoadSaveData::ClearHelptext2
VAR
	i: INT;
END_VAR
  for i := 0 to 255 do // tekst eerst wissen
      Helptext2[i] :=0;
  end_for;
END_FUNCTION


FUNCTION LoadSaveData::DATA_WRITE
	VAR_INPUT
		pParameter 	: ^CHAR;
		Value 	: DINT;
		SizeDataPtr 	: UDINT;
		pReadyProcPtr 	: ^DINT;
	END_VAR
  VAR
    ValuedText  : ^Char;
  END_VAR


  Teller += 1;
  pReadyProcPtr^ := (Teller * 100) / to_dint(SizeDataPtr);
  
  
  ValuedText  := #MyString[0];
  ClearLine(Dest:=ValuedText);

  // Waarde omzetten naar tekst
  BuildValue2Ascii(Value:=Value, Dest:=ValuedText, Offset:=0);  // waarde omzetten naar tekst
  TRACE1 ("Waarde naar tekstbestand geschreven: {0} = {1} ",pParameter,ValuedText);

  ClearHelptext1();
  ClearHelptext2();

  // pParameter naar tekstvariabele kopiëren
  PosCounter1 := Read2CR(Source_:=pParameter, Dest:=#Helptext1[0], Offset:=0);

  _strcat(dest:=#Helptext1[0], src:="="); // "=" teken tussenplakken

  BuildValue2Ascii(Value:=Value, Dest:=ValuedText, Offset:=0);  // waarde omzetten naar tekst
  _strcpy(dest:=#Helptext2[0], src:=ValuedText);

  _strcat(dest:=#Helptext1[0], src:=#Helptext2[0]);

  // positie einde tekst bepalen
  PosCounter2 := to_dint(_strlen(src:=#Helptext1[0]));

  // CR/LF toevoegen op einde lijn
  BuildEOL(Dest:=#Helptext1[0], Offset:=PosCounter2);

  // lijn aan tekstbestand toevoegen
  Filestate := WriteFile(Source:=#Helptext1[0], Length:=PosCounter2+2);

END_FUNCTION

FUNCTION LoadSaveData::Count_Lines

  LineCount := 0;

  CloseFile();

  FileID := OpenFile(#vFilename[0], ATT_READ_WRITE);

  if    Filestate = -2 then
        TRACE0 ("Bestand {0} niet gevonden op schijf.",#vFilename[0]);
  else
        // aantal lijnen in bestand tellen.
        ReadFile(Dest:=#Helptext1[0], Offset:=0);
        PosCounter1 := Read2CR(Source_:=#Helptext1[0], Dest:=#Helptext2[0], Offset:=0);
        while PosCounter1 >1 do
              ReadFile(Dest:=#Helptext1[0], Offset:=0);
              PosCounter1 := Read2CR(Source_:=#Helptext1[0], Dest:=#Helptext2[0], Offset:=0);
              LineCount +=1;  
        end_while;
  end_if;
    
  FileID := CloseFile();
  
END_FUNCTION

FUNCTION LoadSaveData::SAVE_DATA
	VAR_INPUT
		pDataPtr 	: ^DINT;
		SizeDataPtr 	: UDINT;
		pReadyProcPtr 	: ^DINT;
	END_VAR

  VAR
  	i : dint;
    Index : array [0..9] of char;
  END_VAR

  for   i:= 0 to to_int(SizeDataPtr-1) do
        
        _memset(dest:=#Index[0], usByte:=0, cntr:=10);
        BuildValue2Ascii(Value:=i, Dest:=#Index[0], Offset:=0);


        DATA_WRITE(pParameter:=#Index[0], Value:=(pDataPtr+i)^$byte, SizeDataPtr:=SizeDataPtr, pReadyProcPtr:=pReadyProcPtr);

  end_for;


  Status_LoadSave := 0;
  
  
END_FUNCTION




FUNCTION LoadSaveData::LOAD_DATA
	VAR_INPUT
		pDataPtr 	: ^DINT;
		SizeDataPtr 	: UDINT;
		pReadyProcPtr 	: ^DINT;
	END_VAR


  VAR
    i : dint;
    //Index : array [0..9] of char;
  END_VAR

  for   i:= 0 to to_int(SizeDataPtr) do
        _memset(dest:=#Index[0], usByte:=0, cntr:=10);
        BuildValue2Ascii(Value:=i, Dest:=#Index[0], Offset:=0);

        (pDataPtr+i)^ := (DATA_READ_DINT(pParameter:=#Index[0], SizeDataPtr:=SizeDataPtr, pReadyProcPtr:=pReadyProcPtr))$byte;
  end_for;
  
  Status_LoadSave := 0;
  //Deze regel kom uit de Data_read_dint methode
  FileID := CloseFile();

END_FUNCTION








FUNCTION LoadSaveData::DATA_READ_DINT
	VAR_INPUT
		pParameter 	: ^CHAR;
		SizeDataPtr 	: UDINT;
		pReadyProcPtr 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		Value 	: DINT;
	END_VAR
  VAR

    Line : DINT;
  	Pos : DINT;
    LineOK : DINT;
    Read_equalpos : DINT;
    Read_Endpos : DINT;
    StringLength : DINT;
    TempPara : Array[0..255] of char;
    Valuetext : Array[0..59] of char;
    ii : int;
    
  END_VAR
  
  Teller +=1;
  pReadyProcPtr^ := (Teller * 100) / to_dint(SizeDataPtr);

  _memset(dest:=#TempPara[0], usByte:= 0, cntr:=256); // eerst wissen dan
  _memcpy(ptr1:= #TempPara[0], ptr2:=pParameter, cntr:=  256); // vullen

  // hulpvariabelen wissen
  _memset(dest:=#Helptext1[0], usByte:= 0, cntr:=256); // eerst wissen dan
  _memset(dest:=#Helptext2[0], usByte:= 0, cntr:=256); // eerst wissen dan
  _memset(dest:=#Valuetext[0], usByte:= 0, cntr:=60); // eerst wissen dan


   if     LineCount > 0 then

          for   Line := 1 to LineCount do

                ReadFile(Dest:=#Helptext1[0], Offset:=0);

                StringLength := Read2CR(Source_:=#Helptext1[0], Dest:=#Helptext2[0], Offset:=0); // totale lengte tekstlijn


                // posities van het =-teken en het einde van de tekstregel bepalen   
                // #pvo 120815
                Read_equalpos := 0;
                Read_Endpos := 0;
                for     Pos:=0 to StringLength do
                        if    Helptext2[Pos]=61 then // 61 is ascii-code voor = (is gelijk aan)
                              Read_equalpos := Pos; 
                        end_if;
                        if    Helptext2[Pos]=0 then
                              Read_Endpos := Pos;
                        end_if;
                end_for;

                _memset(dest:=#vParameter[0], usByte:= 0, cntr:= sizeof(vParameter)); 
                
                if    Read_equalpos > 0 then
                      // parameter uit tekststring filteren
                      _strcpy(dest:=#vParameter[0], src:=#Helptext2[0]);
                end_if;                
                
                for   ii:= to_int(Read_equalpos) to 255 do
                      vParameter[Read_equalpos] := 0;
                end_for;

                
        
                // als parameter gevraagde parameter is, dan de lus stoppen en de Value-waarde filteren
                // tekststrings omzetten naar hoofdletters
                _strupr(str:=#TempPara[0]);
                _strupr(str:=#vParameter[0]);

                LineOK := _strcmp(str1:=#TempPara[0], str2:=#vParameter[0]); 
                if    LineOK = 0 then 
                      NrVar_Load += 1;
                      exit;
                end_if;
               
               if     Line = LineCount then
                      //Waarde 0 schrijven
                      Value := 0;
                      
                      //controle hoeveel variabelen er geladen zijn
                      NrVar_Load += 1;
                      
                      NrOfErrrors +=1;

                      LineCount := 0;  

                      //Bestand sluiten en opnieuw openen -> cursus naar begin of line
                      FileID := CloseFile();
                             
                      //aantal lijnen in tekstfile scannen
                      LineCount :=0;
                      Count_Lines();    

                      FileID := CloseFile(); // sluiten ingeval de file nog mocht openstaan
                      FileID := OpenFile(#vFilename[0], ATT_READ_WRITE); // file openen bij leesinstructie
                      
                      if    Filestate = -2 then
                            TRACE0 ("Bestand {0} niet gevonden op schijf.",#vFilename[0]);
                      end_if;
                end_if;
            end_for;
    end_if;
    
  
    
    // waarde uitlezen uit de volledige string, vanaf =-teken tot einde
    // kan alleen gelezen worden als er een =-teken in de tekst zit
    if    Read_equalpos > 0 then
          _strcpy(dest:=#ValueText[0], src:=#Helptext2[to_udint(Read_equalpos)+1]);
    end_if;

    // tekstwaarde Value omzetten naar getalwaarde.
    Value := ConvAscii2Value(Source_:=#ValueText[0]);



END_FUNCTION


FUNCTION LoadSaveData::ConvAscii2Value
	VAR_INPUT
		Source_ 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Value 	: DINT;
	END_VAR
  Var
    i			: DINT;
    Sign		: DINT;
  End_Var;

  Sign := 1;
  Value:= 0;
  For   i:= 0 to 20 Do
        Case Source_^ of
        0..cUS, cSeparator:
          // The end
          i	:= 20;
        '-':
          // It is a negative value
          Sign := -1;
        '0'..'9':
          // convert to DINT
          Value	*= 10;
          Value	+= To_Dint( Source_^- '0');
        End_Case;
        Source_	+= 1;
  End_For;

  Value *= Sign;
END_FUNCTION











FUNCTION GLOBAL LoadSaveData::ReadFile
	VAR_INPUT
		Dest 	: ^CHAR;
		Offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR
  
  Var
    EndPtr	: ^CHAR;
  End_Var;

  Size	:= 0;
  If    FileID > 0 Then
        EndPtr	:= Dest	+ cMaxAsciiLine;
        Dest	+= (Offset- 1);
        Repeat
              Dest	+= 1;
              FileOs	:= To_Dint( FileOs.FileRead(FileID, Dest, 1));
              If    FileOs<> 0 Then
                    Size	+= FileOs; 
                    If    Dest^= cCR Then	// Skip LF
                          Dest	-= 1;
                          Size	-= 1;
                    End_If;
              Else
                    Dest^	:= Nil$Char;
                    FileOs	:= FileOs;
              End_If;
        Until ( Dest^ = Nil$Char
             | Dest^ = cLF
             | Dest	>= EndPtr )
        End_Repeat;
        
        Dest^	:= Nil$Char;
        FileSize	+= Size;
        If    Size> 1 Then 
              Size	-= 1; 
        End_If;
  Else
        Filestate	:= -4;	// Can't read.
        Trace( "'DataManager_Load::ReadFile' -4 Can't read from file because there is no handle.");
  End_If;  

END_FUNCTION





FUNCTION GLOBAL LoadSaveData::FileDelete
	VAR_INPUT
		FileName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Result 	: DINT;
	END_VAR
  
  Result := FileOs.FileDelete(filename:=FileName);

END_FUNCTION
