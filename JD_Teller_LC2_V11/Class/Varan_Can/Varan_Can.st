//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define VARAN_CAN_OS_VERSION	16#1100 + 226
#define CANBUS_INVALID_VALUE	-2147483393			//16#800000FF
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include <.\lsl_st_can.h>

(*!
<Class
	Name               = "Varan_Can"
	Revision           = "1.40"
	GUID               = "{02B108BC-8908-432B-A402-772A8191EE57}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(578,120)">
	<Channels>
		<Server Name="CanBusNr" GUID="{EF8BC05F-C68C-4471-A5CC-41AAA5B47387}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="number from OS"/>
		<Server Name="CanError" GUID="{C5E8772A-EFC0-4E4D-A90D-595DFC022479}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="CanIsoError" GUID="{A8FD6D6C-DA67-43CB-AB40-B0D71001C93C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Enabled" GUID="{867F0C91-31DC-4728-8B2C-53257AD425E6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="State" GUID="{17916D54-3690-4562-A7D7-E745BD94369C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="CallUserRt" Required="false" Internal="false" Comment="connected server is called bevore Tx Data is write to varan"/>
		<Client Name="Can_AddressOffset" Required="true" Internal="false" Comment="offset in device for can"/>
		<Client Name="Index" Required="true" Internal="false" Comment="index of can interface on device"/>
		<Client Name="ISOCanOn" Required="false" Internal="false" Comment="0=ISO Can off (no varan DOs are needed), 1=ISO Can on"/>
		<Client Name="Pll_Prescaler" Required="false" Internal="false" Comment="prescaler of varan time for ISO Tx Can Objects (0,1=sending objects in varan time, 2=sending in varan time multiplied by 2, 3=sending in varan time multplied by 3,...)"/>
		<Client Name="To_Can" Required="false" Internal="false" Comment="is automatically conencted to can"/>
		<Client Name="To_StdLib" Required="false" Internal="false"/>
		<Client Name="To_Varan_Base" Required="true" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\Varan_Can\Varan_Can_Defs.h" Include="false"/>
			<File Path=".\lsl_st_can.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="renste"/>
		<Dokumentation Revision="1.40" Date="12.02.2014" Author="PieSte" Company="Sigmatek" Description="Add read Client Can_AddressOffset in Init to set value with connected server."/>
		<Dokumentation Revision="1.30" Date="05.12.2013" Author="LanSte" Company="Sigmatek" Description="Added Payload Support"/>
		<Dokumentation Revision="1.20" Date="05.11.2012" Author="RamAnd&#13;&#10;RamAnd" Company="Sigmatek" Description="Removed 2 unnecessary accesses to the Varan Manager DPRAM to reduce realtime load.&#13;&#10;Corrected configuration of ISO CAN objects (Termination problem if 12 CAN objects have been used)"/>
		<Dokumentation Revision="1.10" Date="19.09.2011" Author="RamAnd" Company="Sigmatek" Description="Prepared class to get deriven (some methods are now virtual and some defines moved from the code to the define section of the class)"/>
		<Dokumentation Revision="1.9" Date="30.05.2011" Author="RamAnd" Company="Sigmatek" Description="IF-query with EAX in UpdateRt could have led to problems."/>
		<Dokumentation Revision="1.8" Date="04.01.2011" Author="BleErn" Company="Sigmatek" Description="Added Client Transparent that allows to disable a VARAN-HW-Class"/>
		<Dokumentation Revision="1.7" Date="31.05.2010" Author="BleErn" Company="Sigmatek" Description="Added support for RtPostScan"/>
		<Dokumentation Revision="1.6" Date="20.07.2009" Author="ObeChr" Company="Sigmatek" Description="Required was ignored by setting StatusBits, now using SetRunState in VaranBase"/>
	</RevDoku>
</Class>
*)
Varan_Can : CLASS
	TYPE
#pragma pack(push, 1)
	  t_GlobalConfig : STRUCT
	    us_Control : USINT;
	    us_State : USINT;
	    ui_BitTiming0 : UINT;
	    ui_BitTiming1 : UINT;
	    ui_TransmitErrorCnt : UINT;
	    us_ReceiveErrorCnt : USINT;
	    us_IsochronNotReadyCnt : USINT;
	    ui_Reserved : UINT;
	    ud_ISOTXTime : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_GlobDO : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_DOSettings : ^t_VaranDOSettingsRd;
	    p_DataRead : ^t_GlobalConfig;
	    us_OldRetryCounter : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ISORxDataOneMessage : STRUCT
	    ud_Data1 : UDINT;
	    ud_Data2 : UDINT;
	    us_ReceiveCounter : USINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_ISORxDataAllMessages : ARRAY [0..VARAN_CAN_ISO_MAX_RX_OBJ-1] OF t_ISORxDataOneMessage;
#pragma pack(push, 1)
	  t_ISODORx : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_DOSettings : ^t_VaranDOSettingsRd;
	    p_DataRead : ^t_ISORxDataAllMessages;
	    us_OldRetryCounter : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ISOTxDataOneMessage : STRUCT
	    ud_Data1 : UDINT;
	    ud_Data2 : UDINT;
	    us_MessageControl : USINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_ISOTxDataAllMessages : ARRAY [0..VARAN_CAN_ISO_MAX_TX_OBJ-1] OF t_ISOTxDataOneMessage;
	  t_ISODOTx : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_DOSettings : ^t_VaranDOSettingsWr;
	    p_DataWrite : ^t_ISOTxDataAllMessages;
	    us_OldRetryCounter : USINT;
	  END_STRUCT;
#pragma pack(push, 1)
	  t_ISORxConfigOneMessage : STRUCT
	    us_ConfigRegister : BSINT
	    [
	      1 DLC0,
	      2 DLC1,
	      3 DLC2,
	      4 DLC3,
	      5 Extended,
	      6 Remote,
	    ];
	    ud_Arbitration : UDINT;
	    ui_MessageStart : UINT;
	    us_Reserved : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ISORxControlStruct : STRUCT
	    us_NumberOfObjects : USINT;
	    a_Objects : ARRAY [0..VARAN_CAN_ISO_MAX_RX_OBJ-1] OF t_ISORxConfigOneMessage;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ISORxDataStruct : STRUCT
	    us_OldReceiveCounter : USINT;
	    us_DLCLength : USINT;
	    us_Flags : BSINT
	    [
	      1 NewData,
	      2 LostData,
	      3 First,
	    ];
	    ud_Data1 : UDINT;
	    ud_Data2 : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ISORxDO : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_DOSettings : ^t_VaranDOSettingsRd;
	    p_DataRead : ^t_ISORxDataAllMessages;
	    us_OldRetryCounter : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ISOTxConfigOneMessage : STRUCT
	    us_ConfigRegister : BSINT
	    [
	      1 DLC0,
	      2 DLC1,
	      3 DLC2,
	      4 DLC3,
	      5 Extended,
	      6 Remote,
	    ];
	    ud_Arbitration : UDINT;
	    ui_MessageStart : UINT;
	    us_Reserved : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ISOTxControlStruct : STRUCT
	    us_NumberOfObjects : USINT;
	    a_Objects : ARRAY [0..VARAN_CAN_ISO_MAX_TX_OBJ-1] OF t_ISOTxConfigOneMessage;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ISOTxDataStruct : STRUCT
	    ui_Time : UINT;
	    ui_TimeCounter : UINT;
	    ud_Data1 : UDINT;
	    ud_Data2 : UDINT;
	    us_UserSend : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ISOTxDO : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_DOSettings : ^t_VaranDOSettingsWr;
	    p_DataWrite : ^t_ISOTxDataAllMessages;
	    us_OldRetryCounter : USINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	State 	: SvrChCmd_DINT;
	Enabled 	: SvrCh_DINT;
	CanError 	: SvrCh_DINT;
	CanIsoError 	: SvrCh_DINT;
	CanBusNr 	: SvrCh_DINT;
  //Clients:
	To_Varan_Base 	: CltChCmd_Varan_Base;
	To_StdLib 	: CltChCmd__StdLib;
	Can_AddressOffset 	: CltCh_HDINT;
	Pll_Prescaler 	: CltCh_DINT;
	CallUserRt 	: CltCh_DINT;
	To_Can 	: CltChCmd__Can;
	ISOCanOn 	: CltCh_DINT;
	Index 	: CltCh_DINT;
  //Variables:
		s_ISORx_DO 	: t_ISODORx;
		s_ISOTx_DO 	: t_ISODOTx;
		s_Glob_DO 	: t_GlobDO;
		p_NodeString 	: ^USINT;
		ud_DeviceAddress 	: UDINT;
		pVaran 	: ^LSL_VARAN;
		ud_VaranManagerNr 	: UDINT;
		us_Firstscan 	: USINT;
		s_GlobalSettings 	: t_GlobalConfig;
		s_ISOTxConfig 	: t_ISOTxControlStruct;
		s_ISOTxData : ARRAY [0..VARAN_CAN_ISO_MAX_TX_OBJ-1] OF t_ISOTxDataStruct;

		s_ISORxConfig 	: t_ISORxControlStruct;
		s_ISORxData : ARRAY [0..VARAN_CAN_ISO_MAX_RX_OBJ-1] OF t_ISORxDataStruct;

		ui_Baudrate 	: UINT;
		b_NotFirstRt 	: BOOL;
		b_DOsInstalled 	: BOOL;
		ud_TxCounter 	: UDINT;
		ud_AddTime 	: UDINT;
		ud_MaxTime 	: UDINT;
		ud_Timemeasure 	: UDINT;
		ui_CanError 	: UINT;
		ui_CanErrorOld 	: UINT;
		b_OSCanAvailable 	: BOOL;
		b_PayloadSupport 	: BOOL;
		pMultiVaran 	: ^LSL_MULTI_VARAN;
		ud_HandleModule 	: UDINT;
  //Functions:
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Construction of class (set standard baudrate to 500kBit/s)&#13;&#10;=================================================================================================&#13;&#10;" Name="Varan_Can"/>
	FUNCTION Varan_Can
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Init of class&#13;&#10;=================================================================================================&#13;&#10;" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to update isochron can objects&#13;&#10;=================================================================================================&#13;&#10;" Name="RtWork"/>
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function must be called with each connect of device&#13;&#10;=================================================================================================&#13;&#10;" Name="Varan_Connect"/>
	FUNCTION VIRTUAL GLOBAL Varan_Connect
		VAR_INPUT
			ud_data 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;			//! <Variable Comment="0=OK" Name="Varan_Connect.sd_retval"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to set baudrate in init&#13;&#10;=================================================================================================&#13;&#10;" Name="SetBaudrate"/>
	FUNCTION GLOBAL SetBaudrate
		VAR_INPUT
			ui_baud 	: UINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a isochron Can Rx Object&#13;&#10;=================================================================================================&#13;&#10;" Name="AddISOCanRxObj"/>
	FUNCTION GLOBAL AddISOCanRxObj
		VAR_INPUT
			ud_object_nr 	: UDINT;			//! <Variable Comment="object number of can message" Name="AddISOCanRxObj.ud_object_nr"/>
			us_length 	: USINT;			//! <Variable Comment="length of can message" Name="AddISOCanRxObj.us_length"/>
			us_flags 	: BSINT;			//! <Variable Comment="Bit 0: 1=Extended Identifier, Bit 1: 1=Remote Object" Name="AddISOCanRxObj.us_flags"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a isochron Can Tx Object&#13;&#10;=================================================================================================&#13;&#10;" Name="AddISOCanTxObj"/>
	FUNCTION GLOBAL AddISOCanTxObj
		VAR_INPUT
			ud_object_nr 	: UDINT;
			us_length 	: USINT;
			us_flags 	: BSINT;
			ui_time_multiplier 	: UINT;			//! <Variable Comment="0,1: can message is send every varan time, 2=mesage is send every second varan time, ..." Name="AddISOCanTxObj.ui_time_multiplier"/>
			ui_multiplier_offset 	: UINT;			//! <Variable Comment="offset to send messages graded" Name="AddISOCanTxObj.ui_multiplier_offset"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Varan_Disconnect;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to set Data Objects off (is called from derived class)&#13;&#10;=================================================================================================&#13;&#10;" Name="SetDOsOff"/>
	FUNCTION VIRTUAL GLOBAL SetDOsOff;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to check retry counter (is called from derived class)&#13;&#10;=================================================================================================&#13;&#10;" Name="GetRetryCounter"/>
	FUNCTION VIRTUAL GLOBAL GetRetryCounter
		VAR_OUTPUT
			sd_retries 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get data from an Isochron Can Rx Object&#13;&#10;=================================================================================================&#13;&#10;" Name="GetISOData"/>
	FUNCTION GLOBAL GetISOData
		VAR_INPUT
			sd_handle 	: DINT;			//! <Variable Comment="handle of object" Name="GetISOData.sd_handle"/>
			p_data 	: ^void;			//! <Variable Comment="pointer to data" Name="GetISOData.p_data"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to set data for an Isochron Can Tx Object&#13;&#10;=================================================================================================&#13;&#10;" Name="SetISOData"/>
	FUNCTION GLOBAL SetISOData
		VAR_INPUT
			sd_handle 	: DINT;
			p_data 	: ^void;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="GetBaudrate"/>
	FUNCTION GLOBAL GetBaudrate
		VAR_OUTPUT
			ui_baud 	: UINT;			//! <Variable Comment="in kBit" Name="GetBaudrate.ui_baud"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="SetRemoteFlag"/>
	FUNCTION GLOBAL SetRemoteFlag
		VAR_INPUT
			sd_handle 	: DINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL InitMe
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetCanNr;
	
	FUNCTION GLOBAL ChkObjExists
		VAR_INPUT
			ObjNr 	: UDINT;
			Mode 	: UDINT;
			us_flags 	: BSINT;			//! <Variable Comment="Bit 0: 1=Extended Identifier, Bit 1: 1=Remote Object" Name="ChkObjExists.us_flags"/>
		END_VAR
		VAR_OUTPUT
			handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;write function of Enable - Can Server&#13;&#10;=================================================================================================&#13;&#10;" Name="Enabled.Write"/>
	FUNCTION VIRTUAL GLOBAL Enabled::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _Can
#pragma usingLtd _StdLib
#pragma usingLtd Varan_Base


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Varan_Can::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_VARAN_CAN
1$UINT, 40$UINT, (SIZEOF(::Varan_Can))$UINT, 
5$UINT, 8$UINT, 0$UINT, 
TO_UDINT(206510048), "Varan_Can", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Varan_Can.State.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1422331979), "State", 
(::Varan_Can.Enabled.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1874609566), "Enabled", 
(::Varan_Can.CanError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2041939562), "CanError", 
(::Varan_Can.CanIsoError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4115620224), "CanIsoError", 
(::Varan_Can.CanBusNr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1318795701), "CanBusNr", 
//Clients:
(::Varan_Can.To_Varan_Base.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3206450932), "To_Varan_Base", TO_UDINT(862125188), "Varan_Base", 2$UINT, 2$UINT, 
(::Varan_Can.To_StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2139173287), "To_StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::Varan_Can.Can_AddressOffset.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3701318094), "Can_AddressOffset", 
(::Varan_Can.Pll_Prescaler.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(330476248), "Pll_Prescaler", 
(::Varan_Can.CallUserRt.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2801721227), "CallUserRt", 
(::Varan_Can.To_Can.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1707743844), "To_Can", TO_UDINT(3102794146), "_Can", 0$UINT, 3$UINT, 
(::Varan_Can.ISOCanOn.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(532270954), "ISOCanOn", 
(::Varan_Can.Index.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1999087025), "Index", 
END_FUNCTION


#define USER_CNT_Varan_Can 6

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Varan_Can] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Varan_Can::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Varan_Can, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Varan_Connect();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #Varan_Disconnect();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #SetDOsOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #GetRetryCounter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #InitMe();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #GetCanNr();

#pragma warning (default : 74)
	State.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Enabled.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Enabled::Write() );
	IF Enabled.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CanError.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF CanError.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CanIsoError.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF CanIsoError.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= Varan_Can();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma usingLtd Hub_Base

(************************************************************************************
*
*	Class for Varan can module
*	Created : Sigmatek	/	SR	/	July 2007
*	Changes : 
*
*
*     FOR NEWER CHANGES SEE REVISION DOCUMENTATION IN CLASS PROPERTIES
*
*
*   1.4 => 1.5  / 22.01.2009 Mark: PH001
*     - add the function ChkObjExists
*		1.3 => 1.4	/	14.02.2008
*			- [DB 782]: - change the configuration of the timing registers 
*						- now it's possible to enable / disable the can over the server
*						  "Enabled", if it's managed by the OS.
*						- check, if OS can manage the can over varan by every hardware-connect
*		1.2 => 1.3	/	24.01.2008
*			- [DB 767]: can bus via varan can only be managed by OS, when the OS can determine a
*						can-bus-number
*		1.1 => 1.2	/	03.12.2007
*			- [DB 743]: make compatible to OS (varan can is managed by OS except ISO objects)
*		1.0 => 1.1	/	27.09.2007
*			- [DB 688]: insert error server, variable Pll settings for Isochron Tx Can Objects
*
************************************************************************************)

//[#ENGLISH]
//=================================================================================================
//Construction of class (set standard baudrate to 500kBit/s)
//=================================================================================================
FUNCTION  Varan_Can::Varan_Can
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR

	//check OS Version
	if ( _RTOSVersion >= VARAN_CAN_OS_VERSION ) then
		b_OSCanAvailable := TRUE;
	else
		b_OSCanAvailable := FALSE;
	end_if;

//	if ( b_OSCanAvailable = FALSE ) then

	//set standard baud to 500kBit
	s_GlobalSettings.ui_BitTiming0	:= 16#0055;
	s_GlobalSettings.ui_BitTiming1	:= 16#000E;
	ui_Baudrate := 500;
//	end_if;
	
	CanBusNr := CANBUS_INVALID_VALUE;

	ret_code	:= C_OK;

END_FUNCTION //  Varan_Can::Varan_Can
//[#ENGLISH]
//=================================================================================================
//Init of class
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Varan_Can::Init
VAR
// For NewInst command 
    _Para 	            : CmdStruct;  
    _Result 	          : Results;   
		paraGetModuleHandel : t_VM_CMD_GetModuleHandle; 
	
END_VAR

    
	//------------------------------------------------------------------------------------------------
	//in first init we get Varan pointer and manager number
	if ( us_Firstscan = 0 ) then

		//first read if Can is used
		ISOCanOn := ISOCanOn.read();
    //get client values
    Can_AddressOffset := Can_AddressOffset.Read();
		
		//GetManager number and pointer to OS
		ud_VaranManagerNr := To_Varan_Base.VaranIn.GetManagerNumber( p_varan := #pVaran );		
	
		//get pointer to position string
		if ( p_nodeString = NIL ) then
			p_NodeString := To_Varan_Base.GetPointer2NodeString();
    end_if;
    
			//do not come here
			if ( p_NodeString = NIL ) then
				State := _RootError;
				return;
			end_if;
      
		/// Check if Payload is supported by the VM    
    _Para.uiCmd := VM_CMD_IS_PAYLOAD_SUPPORTED;
    _Result.aData[0]$BOOL := 0;   // Set to 0 in case the NewInst Method is not Implemented
    To_Varan_Base.NewInst(#_Para, #_Result);
    b_PayloadSupport := _Result.aData[0]$BOOL;
    
    if  b_PayloadSupport then
    
      // Get the pointer for the Payload inteface
      if ( OS_CILGet( INTERFACE_MULTIVARANMANAGER, #pMultiVaran ) <> SYS_ERR_NONE) then
        // Should be impossible b_PayloadSupport is only set when this interface was already called succesfully
        TRACE( "Varan_Can::Varan_Can No Multi_Varan Interface found" );        
        return;
		end_if;
	
      _Para.uiCmd := VM_CMD_GET_MODULE_HANDLE;
      
      paraGetModuleHandel.p_us_position_info := p_NodeString;
      paraGetModuleHandel.p_ud_module_handle := #ud_HandleModule;
      
      _Para.aPara[0]  := (#paraGetModuleHandel)$DINT;      
      To_Varan_Base.NewInst(#_Para, #_Result);

	end_if;
	//------------------------------------------------------------------------------------------------
	//until tenth init run user can add can objects
	elsif ( us_Firstscan = 5 ) then     
		InitMe();
	end_if;

	us_Firstscan += 1;

END_FUNCTION //VIRTUAL GLOBAL Varan_Can::Init
//[#ENGLISH]
//=================================================================================================
//Function must be called with each connect of device
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Varan_Can::Varan_Connect
	VAR_INPUT
		ud_data 	: UDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

	//check OS Version
	if ( _RTOSVersion >= VARAN_CAN_OS_VERSION ) then
		b_OSCanAvailable 	:= TRUE;
		CanBusNr 			:= CANBUS_INVALID_VALUE;
	else
		b_OSCanAvailable := FALSE;
	end_if;

	//------------------------------------------------------------------------------------------------
	//check if can is on
	if ( ISOCanOn = 0 ) | (To_Varan_Base.GetPointer2NodeInfo() = NIL)
#ifdef IsTransparent_IS_AVAILABLE
  | To_Varan_Base.IsTransparent() 
#endif
  then
		sd_retval := VARANMANAGER_OK;
		return;
	end_if;

	//get device address
	ud_DeviceAddress := To_Varan_Base.GetDeviceAddress();

	//to get right can number from OS
	GetCanNr();				

	//------------------------------------------------------------------------------------------------
	//first disable can
	if ( b_OSCanAvailable = FALSE ) then
		s_GlobalSettings.us_Control := 0;
    
    if b_PayloadSupport then  // -------------------------------------------------------------------------------------------------

      sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                    , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                    , udOffset    := Can_AddressOffset + VARAN_CAN_GLOBAL_CONFIG_OFFSET
                                                    , udLength    := sizeof( t_GlobalConfig )
                                                    , pusData     := ( #s_GlobalSettings)$^USINT
                                                    , pudErrorInfo:= NIL);  

      //look if an error occurs
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _DirectAccessFailed;
        return;
      end_if;
    else
    
		//set global config
		sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
											, uiAddress		:= ud_DeviceAddress + Can_AddressOffset + VARAN_CAN_GLOBAL_CONFIG_OFFSET
											, uiLen			:= sizeof( t_GlobalConfig )
											, uiRetryTimeout:= To_Varan_Base.GetRetryTimeout( ud_bytes := sizeof( t_GlobalConfig ) )
											, pvData		:= #s_GlobalSettings
											, puiError		:= NIL
											);

		//look if an error occurs
		if ( sd_retval <> VARANMANAGER_OK ) then
			State := _DirectAccessFailed;
			return;
		end_if;
    end_if;
  end_if;	// if ( b_OSCanAvailable = FALSE ) then  
    
  if b_PayloadSupport then
    
    sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                  , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                  , udOffset    := Can_AddressOffset + VARAN_CAN_ISO_TX_OFFSET_CONTROL
                                                  , udLength    := (s_ISORxConfig.us_NumberOfObjects + 1) * sizeof( t_ISORxConfigOneMessage )
                                                  , pusData     := ( #s_ISOTxConfig.a_Objects[ 0 ] )$^USINT
                                                  , pudErrorInfo:= NIL);  

    //look if an error occurs
    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      return;
    end_if;
    
    sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                  , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                  , udOffset    := Can_AddressOffset + VARAN_CAN_ISO_RX_OFFSET_CONTROL
                                                  , udLength    := (s_ISORxConfig.us_NumberOfObjects + 1) * sizeof( t_ISORxConfigOneMessage )
                                                  , pusData     := ( #s_ISORxConfig.a_Objects[ 0 ] )$^USINT
                                                  , pudErrorInfo:= NIL);  

    //look if an error occurs
    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      return;
	end_if;		
    
  else   	

	//------------------------------------------------------------------------------------------------
	//config iso can transmit messages must be terminated with an empty object (ui_MessageStart = 0), so we write one more object than the existing number

  //set configuration of transmit iso can objects
  sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
                    , uiAddress		:= ud_DeviceAddress + Can_AddressOffset + VARAN_CAN_ISO_TX_OFFSET_CONTROL
                    , uiLen			:= (s_ISOTxConfig.us_NumberOfObjects + 1) * sizeof( t_ISOTxConfigOneMessage )
                    , uiRetryTimeout:= To_Varan_Base.GetRetryTimeout( ud_bytes := (s_ISOTxConfig.us_NumberOfObjects + 1) * sizeof( t_ISOTxConfigOneMessage ) )
                    , pvData		:= #s_ISOTxConfig.a_Objects[ 0 ]
                    , puiError		:= NIL
                    );

  //look if an error occurs
  if ( sd_retval <> VARANMANAGER_OK ) then
    State := _DirectAccessFailed;
    return;
  end_if;


	//------------------------------------------------------------------------------------------------
	//config iso can receive messages  must be terminated with an empty object (ui_MessageStart = 0), so we write one more object than the existing number

  //set configuration of transmit iso can objects
  sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
                    , uiAddress		:= ud_DeviceAddress + Can_AddressOffset + VARAN_CAN_ISO_RX_OFFSET_CONTROL
                    , uiLen			:= (s_ISORxConfig.us_NumberOfObjects + 1) * sizeof( t_ISORxConfigOneMessage )
                    , uiRetryTimeout:= To_Varan_Base.GetRetryTimeout( ud_bytes := (s_ISORxConfig.us_NumberOfObjects + 1) * sizeof( t_ISORxConfigOneMessage ) )
                    , pvData		:= #s_ISORxConfig.a_Objects[ 0 ]
                    , puiError		:= NIL
                    );

  //look if an error occurs
  if ( sd_retval <> VARANMANAGER_OK ) then
    State := _DirectAccessFailed;
    return;
  end_if;
  end_if;

	//------------------------------------------------------------------------------------------------
	//enable can
	//set iso tx control time (to prevent inconsistent data)
	Pll_Prescaler := Pll_Prescaler.read();
	if ( Pll_Prescaler > 1 ) then
		s_GlobalSettings.ud_ISOTXTime := ( Pll_Prescaler$UDINT * To_Varan_Base.GetVaranTime() / 10 ) - ( To_Varan_Base.GetVaranTime() / 20 );
	else
		s_GlobalSettings.ud_ISOTXTime := To_Varan_Base.GetVaranTime() / 20;
	end_if;

	//check if OS know CAN
	if ( b_OSCanAvailable = FALSE ) then

		s_GlobalSettings.us_Control := 1;
    if b_PayloadSupport then  // -------------------------------------------------------------------------------------------------

      sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                    , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                    , udOffset    := Can_AddressOffset + VARAN_CAN_GLOBAL_CONFIG_OFFSET
                                                    , udLength    := sizeof( t_GlobalConfig )
                                                    , pusData     := ( #s_GlobalSettings )$^USINT
                                                    , pudErrorInfo:= NIL);  

      //look if an error occurs
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _DirectAccessFailed;
        return;
      end_if;
    else
		//set global config
		sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
											, uiAddress		:= ud_DeviceAddress + Can_AddressOffset + VARAN_CAN_GLOBAL_CONFIG_OFFSET
											, uiLen			:= sizeof( t_GlobalConfig )
											, uiRetryTimeout:= To_Varan_Base.GetRetryTimeout( ud_bytes := sizeof( t_GlobalConfig ) )
											, pvData		:= #s_GlobalSettings
											, puiError		:= NIL
											);

		//look if an error occurs
		if ( sd_retval <> VARANMANAGER_OK ) then
			State := _DirectAccessFailed;
			return;
		end_if;
    end_if;
	else
    if b_PayloadSupport then  // -------------------------------------------------------------------------------------------------

      sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                    , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                    , udOffset    := Can_AddressOffset + VARAN_CAN_GLOBAL_CONFIG_OFFSET + t_GlobalConfig.ud_ISOTXTime
                                                    , udLength    := sizeof( UDINT )
                                                    , pusData     := ( #s_GlobalSettings.ud_ISOTXTime )$^USINT
                                                    , pudErrorInfo:= NIL);  

      //look if an error occurs
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _DirectAccessFailed;
        return;
      end_if;
    else
		//only set iso counter, other does OS
		sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
											, uiAddress		:= ud_DeviceAddress + Can_AddressOffset + VARAN_CAN_GLOBAL_CONFIG_OFFSET + t_GlobalConfig.ud_ISOTXTime
                        , uiLen			:= sizeof(UDINT)
											, uiRetryTimeout:= To_Varan_Base.GetRetryTimeout( ud_bytes := 4 )
											, pvData		:= #s_GlobalSettings.ud_ISOTXTime
											, puiError		:= NIL
											);

		//look if an error occurs
		if ( sd_retval <> VARANMANAGER_OK ) then
			State := _DirectAccessFailed;
			return;
		end_if;
	end_if;
  end_if;

	//------------------------------------------------------------------------------------------------
	if ( s_Glob_DO.p_Handle <> NIL ) then
		

		//reset data object
    if b_PayloadSupport then      
      To_Varan_Base.EnableDO(ud_DOHandle:=s_Glob_DO.p_Handle$UDINT);
    else
      s_Glob_DO.p_DOSettings^.ud_Address := ud_DeviceAddress + Can_AddressOffset + VARAN_CAN_GLOBAL_CONFIG_OFFSET;
		To_Varan_Base.ResetDataObject	( p_handleDO	:= s_Glob_DO.p_Handle
										, us_state		:= VARAN_DO_CONT_RUN
										, ud_bytes		:= 1
										);
	end_if;
	end_if;

	//------------------------------------------------------------------------------------------------
	//look if DO is available
	if ( s_ISOTx_DO.p_Handle <> NIL ) then	

		//reset data object (we start it in first rt)
    if b_PayloadSupport then
      To_Varan_Base.DisableDO(ud_DOHandle:=s_ISOTx_DO.p_Handle$UDINT);   
    else
		//correct address fo data object write
		s_ISOTx_DO.p_DOSettings^.ud_Address := ud_DeviceAddress + Can_AddressOffset + VARAN_CAN_ISO_TX_OFFSET_DATA;
		To_Varan_Base.ResetDataObject	( p_handleDO	:= s_ISOTx_DO.p_Handle
										, us_state		:= VARAN_DO_NO_RUN
										, ud_bytes		:= s_ISOTxConfig.us_NumberOfObjects * sizeof( t_ISOTxDataOneMessage )
										);
    end_if;
    
		//set prescaler    
		if ( Pll_Prescaler > 1 ) then
		
			ud_AddTime := To_Varan_Base.GetVaranTime();
			ud_MaxTime := ud_AddTime * Pll_Prescaler$UDINT;
      
      if b_PayloadSupport then
        To_Varan_Base.SetPrescaler( ud_DOHandle       := s_ISOTx_DO.p_Handle$UDINT
                                  , Prescaler         := Pll_Prescaler$UDINT - 1
                                  , PrescalerCnt      := Pll_Prescaler$UDINT - 1
                                  , b_MultipleTimeBase:= false);
      else
			s_ISOTx_DO.p_Handle^.ucExePrescaler := Pll_Prescaler$USINT - 1;
			s_ISOTx_DO.p_Handle^.ucExePrescalerCnt := Pll_Prescaler$USINT - 1;
		end_if;
    end_if;

		end_if;

	//look if DO is available
	if ( s_ISORx_DO.p_Handle <> NIL ) then	
	


		//reset data object
    if b_PayloadSupport then
      To_Varan_Base.EnableDO(ud_DOHandle:=s_ISORx_DO.p_Handle$UDINT);
    else
		//correct address fo data object write
		s_ISORx_DO.p_DOSettings^.ud_Address := ud_DeviceAddress + Can_AddressOffset + VARAN_CAN_ISO_RX_OFFSET_DATA;
		To_Varan_Base.ResetDataObject	( p_handleDO	:= s_ISORx_DO.p_Handle
										, us_state		:= VARAN_DO_CONT_RUN
										, ud_bytes		:= s_ISORxConfig.us_NumberOfObjects * sizeof( t_ISORxDataOneMessage )
										);
	end_if;

	end_if;

	//to get right can number form OS
	//GetCanNr();				

	b_NotFirstRt := FALSE;

END_FUNCTION // Varan_Can::Varan_Connect
//[#ENGLISH]
//=================================================================================================
//Function to update isochron can objects
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Varan_Can::RtWork
VAR_INPUT
	EAX			: UDINT;
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR
VAR
	i			: UINT;
  TempCntDLC : USINT;
	us_new_cnt	: USINT;
	p_data_wr	: ^t_ISOTxDataStruct;
	p_do_wr		: ^t_ISOTxDataOneMessage;
	p_data_rd	: ^t_ISORxDataStruct;
	p_do_rd		: ^t_ISORxDataOneMessage;
END_VAR

	//------------------------------------------------------------------------------------------------
	//check if can is on
	if ( ISOCanOn = 0 ) then
		return;
	end_if;

  IF EAX = 0 THEN

    //------------------------------------------------------------------------------------------------
    //first enable Sync Out and start DO
    if ( b_NotFirstRt = FALSE ) then
      b_NotFirstRt := TRUE;

      //start Tx ISO DO
      if ( s_ISOTx_DO.p_Handle <> NIL ) then
      
        if b_PayloadSupport then
          To_Varan_Base.EnableDO(ud_DOHandle:=s_ISOTx_DO.p_Handle$UDINT);
        else
        s_ISOTx_DO.p_Handle^.ucCtrlStat := To_Varan_Base.SetRunStatus(VARAN_DO_CONT_RUN);
        end_if;
        
        ud_TxCounter := ud_MaxTime;
      end_if;
    end_if;

    //------------------------------------------------------------------------------------------------
    //check state of can controller
    if ( ( s_Glob_DO.p_DataRead^.us_Control and 1 ) = 1 ) then
      Enabled := 1;
    else
      Enabled := 0;
    end_if;	

    //------------------------------------------------------------------------------------------------
    //check errors
    ui_CanError := s_Glob_DO.p_DataRead^.ui_TransmitErrorCnt + s_Glob_DO.p_DataRead^.us_ReceiveErrorCnt;

    if ( ui_CanError > ui_CanErrorOld ) then
      CanError += 1;
    end_if;
    ui_CanErrorOld := ui_CanError;

    if ( s_Glob_DO.p_DataRead^.us_IsochronNotReadyCnt <> s_GlobalSettings.us_IsochronNotReadyCnt ) then
      CanIsoError += TO_USINT( s_Glob_DO.p_DataRead^.us_IsochronNotReadyCnt - s_GlobalSettings.us_IsochronNotReadyCnt );
      s_GlobalSettings.us_IsochronNotReadyCnt := s_Glob_DO.p_DataRead^.us_IsochronNotReadyCnt;
    end_if;

    //------------------------------------------------------------------------------------------------
    //check iso rx can objects
    if ( s_ISORxConfig.us_NumberOfObjects > 0 ) then

      //check all messages
      for i := 0 to s_ISORxConfig.us_NumberOfObjects - 1 do

        p_data_rd 	:= #s_ISORxData[ i ];
        p_do_rd		:= #s_ISORx_DO.p_DataRead^[ i ];
      
        //first get old receive counter
        if ( p_data_rd^.us_Flags.First = FALSE ) then
          p_data_rd^.us_Flags.First := TRUE;
          p_data_rd^.us_OldReceiveCounter := p_do_rd^.us_ReceiveCounter and 16#F;
        else
          TempCntDLC := p_do_rd^.us_ReceiveCounter;
      
          //check if we receive data
          if ( ( TempCntDLC and 16#F ) <> p_data_rd^.us_OldReceiveCounter ) then

            //get receive counter
            us_new_cnt := TempCntDLC and 16#F;
          
            //set flag for new data
            p_data_rd^.us_Flags.NewData := TRUE;
          
            //check if data is lost
            if ( ( ( us_new_cnt - p_data_rd^.us_OldReceiveCounter ) and 16#F ) > 1 ) then
            
              //data is lost
              p_data_rd^.us_Flags.LostData := TRUE;
            else
              p_data_rd^.us_Flags.LostData := FALSE;					
            end_if;		

            //copy data
            p_data_rd^.ud_Data1 := p_do_rd^.ud_Data1;
            p_data_rd^.ud_Data2 := p_do_rd^.ud_Data2;

            //copy old receive counter
            p_data_rd^.us_OldReceiveCounter := us_new_cnt;
            p_data_rd^.us_DLCLength := ( TempCntDLC shr 4 );
          end_if;
        end_if;
      end_for;
    end_if;

  ELSE

    //------------------------------------------------------------------------------------------------
    //check iso tx can objects
    if ( Pll_Prescaler = 0 | ud_TxCounter = ud_MaxTime ) then

      //call update methode of user
      CallUserRt.write( 1 );

      ud_TxCounter$UDINT := ud_AddTime;
    
      if ( s_ISOTxConfig.us_NumberOfObjects > 0 ) then
        
        //check all messages
        for i := 0 to s_ISOTxConfig.us_NumberOfObjects - 1 do

          p_data_wr 	:= #s_ISOTxData[ i ];
          p_do_wr		:= #s_ISOTx_DO.p_DataWrite^[ i ];
      
          //check if we do it automatically
          if ( p_data_wr^.ui_Time <> 0 ) then
            //check if we must send object
            if ( p_data_wr^.ui_TimeCounter >= p_data_wr^.ui_Time ) then

              //set back time counter
              p_data_wr^.ui_TimeCounter := 0;

              //copy data
              p_do_wr^.ud_Data1 := p_data_wr^.ud_Data1;
              p_do_wr^.ud_Data2 := p_data_wr^.ud_Data2;

              //set execution flag
              p_do_wr^.us_MessageControl := 1;

            else
              //reset execution flag
              p_do_wr^.us_MessageControl := 0;				
            end_if;

            //increment time counter
            p_data_wr^.ui_TimeCounter += 1;
        
          else
            //copy data
            p_do_wr^.ud_Data1 := p_data_wr^.ud_Data1;
            p_do_wr^.ud_Data2 := p_data_wr^.ud_Data2;

            if ( p_data_wr^.us_UserSend ) then
              p_data_wr^.us_UserSend := 0;
            
              //set execution flag
              p_do_wr^.us_MessageControl := 1;
            else
              //reset execution flag
              p_do_wr^.us_MessageControl := 0;				
            end_if;
          end_if;
        end_for;
      end_if;
    else
      ud_TxCounter += ud_AddTime;
    end_if;
  
  END_IF;
	
	state:= READY;

END_FUNCTION //VIRTUAL GLOBAL Varan_Can::RtWork

//[#ENGLISH]
//=================================================================================================
//Function to set baudrate in init
//=================================================================================================
//[<sd_retval]0=OK
FUNCTION GLOBAL Varan_Can::SetBaudrate
VAR_INPUT
	ui_baud		: UINT;
END_VAR
VAR_OUTPUT
	sd_retval 	: DINT;
END_VAR

	sd_retval := 0;	
	
	//check if OS know CAN
	GetCanNr();

	if ( b_OSCanAvailable = FALSE ) then

		//check baud
		case ( ui_baud ) of

			10:		s_GlobalSettings.ui_BitTiming0	:= 16#10CB;
					s_GlobalSettings.ui_BitTiming1	:= 16#02BC;

			20:		s_GlobalSettings.ui_BitTiming0	:= 16#0865;
					s_GlobalSettings.ui_BitTiming1	:= 16#015E;

			50:		s_GlobalSettings.ui_BitTiming0	:= 16#036F;
					s_GlobalSettings.ui_BitTiming1	:= 16#0078;

			100:	s_GlobalSettings.ui_BitTiming0	:= 16#01AD;
					s_GlobalSettings.ui_BitTiming1	:= 16#0046;

			125:	s_GlobalSettings.ui_BitTiming0	:= 16#0157;
					s_GlobalSettings.ui_BitTiming1	:= 16#0038;

			250:	s_GlobalSettings.ui_BitTiming0	:= 16#00AB;
					s_GlobalSettings.ui_BitTiming1	:= 16#001C;

			500:	s_GlobalSettings.ui_BitTiming0	:= 16#0055;
					s_GlobalSettings.ui_BitTiming1	:= 16#000E;

			615:	s_GlobalSettings.ui_BitTiming0	:= 16#0045;
					s_GlobalSettings.ui_BitTiming1	:= 16#000B;

			1000:	s_GlobalSettings.ui_BitTiming0	:= 16#002A;
					s_GlobalSettings.ui_BitTiming1	:= 16#0007;

			else
					sd_retval := -1;
					return;
		end_case;

		ui_Baudrate := ui_baud;

	else

		ui_Baudrate := ui_baud;

		//check baud
		case ( ui_baud ) of

			20:		ui_Baud := 6;
			50:		ui_Baud := 5;
			100:	ui_Baud := 4;
			125:	ui_Baud := 3;
			250:	ui_Baud := 2;
			500:	ui_Baud := 1;
			615:	ui_Baud := 0;
			1000:	ui_Baud := 7;
			
		end_case;

		//if ( CanBusNr = CANBUS_INVALID_VALUE ) then
		//	GetCanNr();
		//end_if;
		
		//OS_Function
		sd_retval := To_Can.SetBaudrate	( CanNR		:= CanBusNr$USINT
										, Baudrate	:= ui_Baud$USINT
										);
	end_if;

END_FUNCTION //GLOBAL Varan_Can::SetBaudrate
//[#ENGLISH]
//=================================================================================================
//Function to add a isochron Can Rx Object
//=================================================================================================
//[>ud_object_nr]object number of can message
//[>us_length]length of can message
//[>us_flags]Bit 0: 1=Extended Identifier, Bit 1: 1=Remote Object
//[<sd_retval]positive = handle, negative = error code
FUNCTION GLOBAL Varan_Can::AddISOCanRxObj
VAR_INPUT
	ud_object_nr			: UDINT;
	us_length				: USINT;
	us_flags				: BSINT;
END_VAR
VAR_OUTPUT
	sd_retval				: DINT;
END_VAR

	//is list full
	if ( s_ISORxConfig.us_NumberOfObjects < VARAN_CAN_ISO_MAX_RX_OBJ ) then

		//check if we are in init
		if ( b_DOsInstalled = TRUE ) then
			sd_retval := -3;
			return;
		end_if;
		
		//check length
		if ( us_length > 8 ) then			
			sd_retval := -2;			//length error
			return;
		end_if;

		//look if extended
		if ( us_flags.1 = FALSE ) then
			ud_object_nr := ud_object_nr shl 18;
		end_if;
		//set configuration
		s_ISORxConfig.a_Objects[ s_ISORxConfig.us_NumberOfObjects ].us_ConfigRegister := us_length;
		s_ISORxConfig.a_Objects[ s_ISORxConfig.us_NumberOfObjects ].us_ConfigRegister.Extended := us_flags.1;
		s_ISORxConfig.a_Objects[ s_ISORxConfig.us_NumberOfObjects ].us_ConfigRegister.Remote := us_flags.2;
		s_ISORxConfig.a_Objects[ s_ISORxConfig.us_NumberOfObjects ].ud_Arbitration := ud_object_nr;
		s_ISORxConfig.a_Objects[ s_ISORxConfig.us_NumberOfObjects ].ui_MessageStart := VARAN_CAN_ISO_RX_OFFSET_DATA + s_ISORxConfig.us_NumberOfObjects * sizeof( t_ISORxDataOneMessage );

		sd_retval$UDINT := s_ISORxConfig.us_NumberOfObjects or VARAN_CAN_ISO_RX_HANDLE_MASK;
		s_ISORxConfig.us_NumberOfObjects += 1;

	else
		//list full
		sd_retval := -1;
	end_if;

END_FUNCTION //GLOBAL Varan_Can::AddISOCanRxObj
//[#ENGLISH]
//=================================================================================================
//Function to add a isochron Can Tx Object
//=================================================================================================
//[>ud_object_nr]object number of can message
//[>us_length]length of can message
//[>us_flags]Bit 0: 1=Extended Identifier, Bit 1: 1=Remote Object
//[>ui_time_multiplier]0,1: can message is send every varan time, 2=mesage is send every second varan time, ...
//[>ui_multiplier_offset]offset to send messages graded
//[<sd_retval]positive = handle, negative = error code
FUNCTION GLOBAL Varan_Can::AddISOCanTxObj
VAR_INPUT
	ud_object_nr			: UDINT;
	us_length				: USINT;
	us_flags				: BSINT;
	ui_time_multiplier		: UINT;
	ui_multiplier_offset	: UINT;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR

	//is list full
	if ( s_ISOTxConfig.us_NumberOfObjects < VARAN_CAN_ISO_MAX_TX_OBJ ) then

		//check if we are in init
		if ( b_DOsInstalled = TRUE ) then
			sd_retval := -3;
			return;
		end_if;
		
		//check length
		if ( us_length > 8 ) then			
			sd_retval := -2;			//length error
			return;
		end_if;

		//check multiplier offset
		if ( ui_multiplier_offset > ui_time_multiplier ) then
			sd_retval := -4;	//offset error
		end_if;

		//check time multiplier
		if ( ui_time_multiplier = 0 ) then
			ui_multiplier_offset := 0;
		end_if;

		//look if extended
		if ( us_flags.1 = FALSE ) then
			ud_object_nr := ud_object_nr shl 18;
		end_if;

		//set configuration
		s_ISOTxConfig.a_Objects[ s_ISOTxConfig.us_NumberOfObjects ].us_ConfigRegister := us_length;
		s_ISOTxConfig.a_Objects[ s_ISOTxConfig.us_NumberOfObjects ].us_ConfigRegister.Extended := us_flags.1;
		s_ISOTxConfig.a_Objects[ s_ISOTxConfig.us_NumberOfObjects ].us_ConfigRegister.Remote := us_flags.2;
		s_ISOTxConfig.a_Objects[ s_ISOTxConfig.us_NumberOfObjects ].ud_Arbitration := ud_object_nr;
		s_ISOTxConfig.a_Objects[ s_ISOTxConfig.us_NumberOfObjects ].ui_MessageStart := VARAN_CAN_ISO_TX_OFFSET_DATA + s_ISOTxConfig.us_NumberOfObjects * sizeof( t_ISOTxDataOneMessage );

		//set offset
		s_ISOTxData[ s_ISOTxConfig.us_NumberOfObjects ].ui_Time := ui_time_multiplier;
		s_ISOTxData[ s_ISOTxConfig.us_NumberOfObjects ].ui_TimeCounter := ui_time_multiplier - ui_multiplier_offset;

		sd_retval$UDINT := s_ISOTxConfig.us_NumberOfObjects or VARAN_CAN_ISO_TX_HANDLE_MASK;;
		s_ISOTxConfig.us_NumberOfObjects += 1;

	else
		//list full
		sd_retval := -1;
	end_if;

END_FUNCTION //GLOBAL Varan_Can::AddISOCanTxObj
//[#ENGLISH]
//=================================================================================================
//Function to set Data Objects off (is called from derived class)
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Varan_Can::SetDOsOff

	//------------------------------------------------------------------------------------------------
	//check if can is on
	if ( ISOCanOn = 0 ) then
		return;
	end_if;

	//------------------------------------------------------------------------------------------------
	//if DO is installed
	if ( s_ISOTx_DO.p_Handle <> NIL ) then

    To_Varan_Base.DisableDO(ud_DOHandle := s_ISOTx_DO.p_Handle$UDINT);
	end_if;

	//if DO is installed
	if ( s_ISORx_DO.p_Handle <> NIL ) then
     To_Varan_Base.DisableDO(ud_DOHandle := s_ISORx_DO.p_Handle$UDINT);
	end_if;
  
  To_Varan_Base.DisableDO(ud_DOHandle := s_Glob_DO.p_Handle$UDINT);

END_FUNCTION //GLOBAL Varan_Can::SetDOsOff
//[#ENGLISH]
//=================================================================================================
//Function to check retry counter (is called from derived class)
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Varan_Can::GetRetryCounter
	VAR_OUTPUT
		sd_retries 	: UDINT;
	END_VAR

	sd_retries := 0;	

	//------------------------------------------------------------------------------------------------
	//check if can is on
	if ( ISOCanOn = 0 ) then
		return;
	end_if;
  
  sd_retries :=  To_Varan_Base.GetRetryCounter(ud_DOHandle := s_ISOTx_DO.p_Handle$UDINT);
  if ( sd_retries <> s_ISOTx_DO.us_OldRetryCounter ) then
		To_Varan_Base.RetryCounter += TO_USINT( sd_retries - s_ISOTx_DO.us_OldRetryCounter );
		s_ISOTx_DO.us_OldRetryCounter := sd_retries$USINT;
		end_if;
  

  sd_retries :=  To_Varan_Base.GetRetryCounter(ud_DOHandle := s_ISORx_DO.p_Handle$UDINT);
  if ( sd_retries <> s_ISORx_DO.us_OldRetryCounter ) then
		To_Varan_Base.RetryCounter += TO_USINT( sd_retries - s_ISORx_DO.us_OldRetryCounter );
		s_ISORx_DO.us_OldRetryCounter := sd_retries$USINT;
		end_if;
  
  sd_retries :=  To_Varan_Base.GetRetryCounter(ud_DOHandle := s_Glob_DO.p_Handle$UDINT);
  if ( sd_retries <> s_Glob_DO.us_OldRetryCounter ) then
		To_Varan_Base.RetryCounter += TO_USINT( sd_retries - s_Glob_DO.us_OldRetryCounter );
		s_Glob_DO.us_OldRetryCounter := sd_retries$USINT;
	end_if;
	//------------------------------------------------------------------------------------------------

END_FUNCTION //GLOBAL Varan_Can::GetRetryCounter
//[#ENGLISH]
//=================================================================================================
//Function to get data from an Isochron Can Rx Object
//=================================================================================================
//[>sd_handle]handle of function AddISOCanRxObj
//[>p_data]pointer to write data
//[<sd_retval]0=0k, -1=invalid handle, -2=invalid data pointer, -3=data lost, -4=no new data
FUNCTION GLOBAL Varan_Can::GetISOData
VAR_INPUT
	sd_handle		: DINT;
	p_data			: ^void;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR
VAR
	pRxData			: ^t_ISORxDataStruct;
END_VAR

	//is pointer valid
	if ( p_data = NIL ) then
		sd_retval := -2;
		return;
	end_if;

	//check handle and Can is on
	if ( ( sd_handle and VARAN_CAN_ISO_RX_HANDLE_MASK ) = 0 | ISOCanOn = 0 ) then
		sd_retval := -1;
		return;
	end_if;
	
	sd_handle := sd_handle and 16#FFFF;

	//check handle
	if ( sd_handle >= 0 & sd_handle < s_ISORxConfig.us_NumberOfObjects ) then

		pRxData := #s_ISORxData[ sd_handle ];

		//look for new data
		if ( pRxData^.us_Flags.NewData = TRUE ) then

			//copy data
			To_StdLib.MemCpy( dest		:= p_data
							, source	:= #pRxData^.ud_Data1
							, size		:= pRxData^.us_DLCLength
							);

			pRxData^.us_Flags.NewData := FALSE;

			if ( pRxData^.us_Flags.LostData = TRUE ) then
				sd_retval := -3;
			else
				sd_retval := 0;		//everything alright
			end_if;

		else
			sd_retval := -4;
		end_if;
			
	else
		sd_retval := -1;
	end_if;

END_FUNCTION //GLOBAL Varan_Can::GetISOData
//[#ENGLISH]
//=================================================================================================
//Function to set data for an Isochron Can Tx Object
//=================================================================================================
//[>sd_handle]Handle from functinon AddISOCanTxObj
//[>p_data]pointer to data
//[<sd_retval]0=0k, -1=invalid handle, -2=invalid data pointer, -3=no new data
FUNCTION GLOBAL Varan_Can::SetISOData
VAR_INPUT
	sd_handle		: DINT;
	p_data			: ^void;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR
VAR
	pTxData			: ^t_ISOTxDataStruct;
END_VAR

	//is pointer valid
	if ( p_data = NIL ) then
		sd_retval := -2;
		return;
	end_if;

	//check handle and Can is on
	if ( ( sd_handle and VARAN_CAN_ISO_TX_HANDLE_MASK ) = 0  | ISOCanOn = 0 ) then
		sd_retval := -1;
		return;
	end_if;
	
	sd_handle := sd_handle and 16#FFFF;

	//check handle
	if ( sd_handle >= 0 & sd_handle < s_ISOTxConfig.us_NumberOfObjects ) then

		pTxData := #s_ISOTxData[ sd_handle ];

		//set new data
		To_StdLib.MemCpy( dest		:= #pTxData^.ud_Data1
						, source	:= p_data
						, size		:= s_ISOTxConfig.a_Objects[ sd_handle ].us_ConfigRegister and 16#F
						);

		//set new data flag
		pTxData^.us_UserSend := 1;
		
		sd_retval := 0;
			
	else
		sd_retval := -1;
	end_if;

END_FUNCTION //GLOBAL Varan_Can::SetISOData

//[#ENGLISH]
//=================================================================================================
//write function of Enable - Can Server
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Varan_Can::Enabled::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
VAR
	sd_retval	: DINT;
END_VAR

	//check if OS know CAN
	
	GetCanNr();

	//check if can is on
	if ( ISOCanOn = 0 ) | (To_Varan_Base.GetPointer2NodeInfo() = NIL) then
		result := 0;
		return;
	end_if;
		
	input := input and 1;

	if ( Enabled <> input ) then

		Enabled := input;

		if ( Enabled ) then

			//enable can
			s_GlobalSettings.us_Control := 1;
		else
			
			//disable can
			s_GlobalSettings.us_Control := 0;
		end_if;

		if ( b_OSCanAvailable = FALSE ) then
      if b_PayloadSupport then  // -------------------------------------------------------------------------------------------------

        sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                      , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                      , udOffset    := Can_AddressOffset + VARAN_CAN_GLOBAL_CONFIG_OFFSET
                                                      , udLength    := sizeof( t_GlobalConfig )
                                                      , pusData     := ( #s_GlobalSettings)$^USINT
                                                      , pudErrorInfo:= NIL);  
                                                      
                                                      
                                                          //look if an error occurs
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _DirectAccessFailed;
          return;
        end_if;

      else
			//set global config
			sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
												, uiAddress		:= ud_DeviceAddress + Can_AddressOffset + VARAN_CAN_GLOBAL_CONFIG_OFFSET
												, uiLen			:= sizeof( t_GlobalConfig )
												, uiRetryTimeout:= To_Varan_Base.GetRetryTimeout( ud_bytes := sizeof( t_GlobalConfig ) )
												, pvData		:= #s_GlobalSettings
												, puiError		:= NIL
												);
        
        //look if an error occurs
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _DirectAccessFailed;
          return;
        end_if;
      end_if;
      
		else
      if b_PayloadSupport then  // -------------------------------------------------------------------------------------------------

        sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                      , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                      , udOffset    := Can_AddressOffset + VARAN_CAN_GLOBAL_CONFIG_OFFSET
                                                      , udLength    := sizeof(USINT)
                                                      , pusData     := (#s_GlobalSettings.us_Control)$^USINT
                                                      , pudErrorInfo:= NIL);  

        //look if an error occurs
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _DirectAccessFailed;
          return;
        end_if;
		else
			//set global config
			//write only first byte because OS manages the can bus
			sd_retval := VARAN_iWriteMemoryDA	( uiManager		:= ud_VaranManagerNr
												, uiAddress		:= ud_DeviceAddress + Can_AddressOffset + VARAN_CAN_GLOBAL_CONFIG_OFFSET
                          , uiLen			:= sizeof(USINT)
												, uiRetryTimeout:= To_Varan_Base.GetRetryTimeout( ud_bytes := 1 )
												, pvData		:= #s_GlobalSettings.us_Control
												, puiError		:= NIL
												);
		
		//look if an error occurs
		if ( sd_retval <> VARANMANAGER_OK ) then
			State := _DirectAccessFailed;
			return;
		end_if;
    
	end_if;

		end_if;		

	end_if;
	 	
	result := Enabled;

END_FUNCTION //VIRTUAL GLOBAL Varan_Can::Enabled::Write
//[#ENGLISH]
//[<ui_baud]in kBit
FUNCTION GLOBAL Varan_Can::GetBaudrate
VAR_OUTPUT
	ui_baud		: UINT;
END_VAR

	//check if OS know CAN
	
	GetCanNr();

	if ( b_OSCanAvailable = FALSE ) then

		ui_baud := ui_Baudrate;
	else
		
		ui_baud := 0;

		//check if can is on
		if ( ISOCanOn = 0 ) then
			return;
		end_if;

		//if ( CanBusNr = CANBUS_INVALID_VALUE ) then
		//	GetCanNr();
		//end_if;
		
		//OS_Function
		To_Can.GetBaudrate	( CanNR		:= CanBusNr$USINT
							, Baudrate	:= ( #ui_baud )$^USINT
							);

		//we must do this to be compatible to old version without OS support
		case ( ui_baud ) of
			0:	ui_baud := 615;
			1:	ui_baud := 500;
			2:	ui_baud := 250;
			3:	ui_baud := 125;
			4:	ui_baud := 100;
			5:	ui_baud := 50;
			6:	ui_baud := 20;
			7:	ui_baud := 1000;
		end_case;
	end_if;

END_FUNCTION //GLOBAL Varan_Can::GetBaudrate
//[#ENGLISH]
//[>sd_handle]handle of object
//[<sd_retval]0=OK
FUNCTION GLOBAL Varan_Can::SetRemoteFlag
VAR_INPUT
	sd_handle		: DINT;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR

	//check if we are in init
	if ( b_DOsInstalled = TRUE ) then
		sd_retval := -3;
		return;
	end_if;

	//check if can is on
	if ( ISOCanOn = 0 ) then
		sd_retval := -1;
		return;
	end_if;

	//check handle
	if ( sd_handle and VARAN_CAN_ISO_RX_HANDLE_MASK ) then

		sd_handle := sd_handle and 16#FFFF;
		
		//check handle
		if ( sd_handle >= 0 & sd_handle < s_ISORxConfig.us_NumberOfObjects ) then
			s_ISORxConfig.a_Objects[ sd_handle ].us_ConfigRegister.Remote := TRUE;
			sd_retval := 0;			
		else
			sd_retval := -1;
		end_if;


	//check handle
	elsif ( sd_handle and VARAN_CAN_ISO_TX_HANDLE_MASK ) then

		sd_handle := sd_handle and 16#FFFF;
		
		//check handle
		if ( sd_handle >= 0 & sd_handle < s_ISOTxConfig.us_NumberOfObjects ) then
			s_ISOTxConfig.a_Objects[ sd_handle ].us_ConfigRegister.Remote := TRUE;			
		else
			sd_retval := -1;
		end_if;

	else
		sd_retval := -1;
	end_if;

END_FUNCTION //GLOBAL Varan_Can::SetRemoteFlag

FUNCTION VIRTUAL Varan_Can::InitMe
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

	//if we are not installed
	if ( ISOCanOn & b_DOsInstalled = FALSE ) then
	
		b_DOsInstalled := TRUE;
		if b_PayloadSupport then
		
      sd_retval := To_Varan_Base.AddRdPayloadDO(  ud_dol_type   := VARAN_DOL_ISO
                                  , p_ud_handle   := ( #s_Glob_DO.p_Handle)$^UDINT
                                  , ud_offset_read:= Can_AddressOffset + VARAN_CAN_GLOBAL_CONFIG_OFFSET                              
                                  , ud_length_read:= t_GlobalConfig.us_IsochronNotReadyCnt + 1
                                  , p_ud_data_read:= ( #s_Glob_DO.p_DataRead)$^UDINT
                                  , ud_type       := VM_MEMORY_ACCESS);
      

      
      //look if an error occurs
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _CreateDOFailed;
        return;
      end_if;	
    else
		//install DO for global settings
		sd_retval := To_Varan_Base.VaranIn.AddRdDO	( p_us_position_info	:= p_NodeString
													, ud_dol_type			:= VARAN_DOL_ISO
													, p_ud_handle			:= ( #s_Glob_DO.p_Handle )$^UDINT
													, ud_address			:= 0
													, ud_length				:= t_GlobalConfig.us_IsochronNotReadyCnt + 1
													, p_ud_data				:= ( #s_Glob_DO.p_DataRead )$^UDINT
													, ud_type				:= VM_MEMORY_ACCESS
													);

		//check return code
		if ( sd_retval <> VARANMANAGER_OK ) then
			State := _CreateDOFailed;
			return;
		end_if;

		//get address pointer to change address later when module is connected	
		s_Glob_DO.p_DOSettings := s_Glob_DO.p_DataRead - VM_DO_OFFSET_RD;
		end_if;
		//look if DO is needed
		if ( s_ISOTxConfig.us_NumberOfObjects > 0 ) then		
      if b_PayloadSupport then
      
        sd_retval := To_Varan_Base.AddWrPayloadDO(  ud_dol_type   := VARAN_DOL_ISO
                                    , p_ud_handle   := ( #s_ISOTx_DO.p_Handle)$^UDINT
                                    , ud_offset_write:= Can_AddressOffset + VARAN_CAN_ISO_TX_OFFSET_DATA                                
                                    , ud_length_write:= s_ISOTxConfig.us_NumberOfObjects * sizeof( t_ISOTxDataOneMessage )
                                    , p_ud_data_write:= ( #s_ISOTx_DO.p_DataWrite)$^UDINT
                                    , ud_type       := VM_MEMORY_ACCESS);
        

        
        //look if an error occurs
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _CreateDOFailed;
          return;
        end_if;	
      else
			//add iso DO
			sd_retval := To_Varan_Base.VaranIn.AddWrDO	( p_us_position_info	:= p_NodeString
														, ud_dol_type			:= VARAN_DOL_ISO
														, p_ud_handle			:= ( #s_ISOTx_DO.p_Handle )$^UDINT
														, ud_address			:= 0
														, ud_length				:= s_ISOTxConfig.us_NumberOfObjects * sizeof( t_ISOTxDataOneMessage )
														, p_ud_data				:= ( #s_ISOTx_DO.p_DataWrite )$^UDINT
														, ud_type				:= VM_MEMORY_ACCESS
														);

			//check return code
			if ( sd_retval <> VARANMANAGER_OK ) then
				State := _CreateDOFailed;
				return;
			end_if;

			//get address pointer to change address later when module is connected	
			s_ISOTx_DO.p_DOSettings := s_ISOTx_DO.p_DataWrite - VM_DO_OFFSET_WR;
		end_if;
		end_if;

		if ( s_ISORxConfig.us_NumberOfObjects > 0 ) then		
      if b_PayloadSupport then
      
        sd_retval := To_Varan_Base.AddRdPayloadDO(  ud_dol_type   := VARAN_DOL_ISO
                                    , p_ud_handle   := ( #s_ISORx_DO.p_Handle)$^UDINT
                                    , ud_offset_read:= Can_AddressOffset + VARAN_CAN_ISO_RX_OFFSET_DATA                                
                                    , ud_length_read:= s_ISORxConfig.us_NumberOfObjects * sizeof( t_ISORxDataOneMessage )
                                    , p_ud_data_read:= ( #s_ISORx_DO.p_DataRead)$^UDINT
                                    , ud_type       := VM_MEMORY_ACCESS);
        

        
        //look if an error occurs
        if ( sd_retval <> VARANMANAGER_OK ) then
          State := _CreateDOFailed;
          return;
        end_if;	     
      else
			//add iso DO
			sd_retval := To_Varan_Base.VaranIn.AddRdDO	( p_us_position_info	:= p_NodeString
                                                 , ud_dol_type        := VARAN_DOL_ISO
														, p_ud_handle			:= ( #s_ISORx_DO.p_Handle )$^UDINT
														, ud_address			:= 0
														, ud_length				:= s_ISORxConfig.us_NumberOfObjects * sizeof( t_ISORxDataOneMessage )
														, p_ud_data				:= ( #s_ISORx_DO.p_DataRead )$^UDINT
                                                 , ud_type            := VM_MEMORY_ACCESS
                                                 );
    
			//check return code
			if ( sd_retval <> VARANMANAGER_OK ) then
				State := _CreateDOFailed;
				return;
			end_if;
     
			//get address pointer to change address later when module is connected	
			s_ISORx_DO.p_DOSettings := s_ISORx_DO.p_DataRead - VM_DO_OFFSET_RD;
		end_if;
	end_if;
	end_if;

END_FUNCTION //GLOBAL Varan_Can::InitMe

FUNCTION VIRTUAL Varan_Can::GetCanNr
VAR
	pCanuser		: ^OS_CANUSER;
	p_node			: ^USINT;
END_VAR

	//if we have no number
	if ( CanBusNr = CANBUS_INVALID_VALUE & b_OSCanAvailable = TRUE ) then
	
		//get node pointer
		p_node := To_Varan_Base.GetPointer2NodeString();

		//check if we have one
		if ( p_Node = NIL ) then
			return;
		end_if;
		
		if ( OS_CILGet( "CANUSER", #pCanuser$void ) ) then
		else
			CanBusNr := CANUSER_GETNRBYPATH( master := ud_VaranManagerNr, p_node, index := 0 );

			//if the OS can't determine a can bus number, the can bus can't managed by the OS
			if ( CanBusNr = 0 ) then
				b_OSCanAvailable := FALSE;
			end_if;
		end_if;

	end_if;

END_FUNCTION // Varan_Can::GetCanNr

FUNCTION VIRTUAL GLOBAL Varan_Can::Varan_Disconnect

	CanBusNr := CANBUS_INVALID_VALUE;

END_FUNCTION //GLOBAL Varan_Can::Varan_Disconnect



//PH001
FUNCTION GLOBAL Varan_Can::ChkObjExists
	VAR_INPUT
		ObjNr 	: UDINT;
		Mode 	: UDINT;
		us_flags 	: BSINT;
	END_VAR
	VAR_OUTPUT
		handle 	: DINT;
	END_VAR
  VAR
  	x   : DINT;
  END_VAR
  
  x := 0;
  
  //not found
  handle := -1;
  
  //look if extended
  if ( us_flags.1 = FALSE ) then
    ObjNr := ObjNr shl 18;
  end_if;
  
  // ISO RX OBJECT
  if Mode = 0 then
  
    while x < VARAN_CAN_ISO_MAX_RX_OBJ do
      
      if s_ISORxConfig.a_Objects[x ].ud_Arbitration = TO_UDINT(ObjNr) then
        handle := x OR VARAN_CAN_ISO_RX_HANDLE_MASK;
        return;
      end_if;
      x += 1;
    end_while;

  
  // ISO TX OBJECT
  elsif Mode = 2 then
  
    while x < VARAN_CAN_ISO_MAX_TX_OBJ do
      
      if s_ISOTxConfig.a_Objects[x ].ud_Arbitration = TO_UDINT(ObjNr) then
        handle := x OR VARAN_CAN_ISO_TX_HANDLE_MASK;
        return;
      end_if;
      x += 1;
    end_while;
    
  end_if;

END_FUNCTION
