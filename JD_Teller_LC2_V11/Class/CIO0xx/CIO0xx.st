//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define ID_CIO0xx 28

#define ID_CIO011 1
#define ID_CIO012 2
#define ID_CIO013 3
#define ID_CIO014 4
#define ID_CIO016 6
#define ID_CIO017 7


#define CIO0xx_Errormask 2#1111111110001111
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "CIO0xx"
	Revision           = "2.40"
	GUID               = "{7BD2B8AD-439B-4261-AD4D-27A099D659FD}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(570,1560)"
	Comment            = "Base class for all CIO classes">
	<Channels>
		<Server Name="Counter1" GUID="{9DCE1176-914C-451D-AEBA-757C41167E84}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="counts pos. edges of input 1 if CounterMode1and2 &lt;&gt; 0"/>
		<Server Name="Counter2" GUID="{9453BC91-5929-43E5-A5C3-AD282B6BF583}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="counts pos. edges of input 2 if CounterMode1and2 = 1"/>
		<Server Name="Encoder" GUID="{E5BDBA55-3A1F-4B67-B8C5-E1472C5F9A9F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Shows the encoder position if CounterMode1and2 = 2 | 3 (2 = gating 1 times | 3 = gating 4 times)"/>
		<Server Name="Input1" GUID="{36DE007F-57DD-4762-B02A-3748BE3B3A18}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 1"/>
		<Server Name="Input2" GUID="{84923E0B-65E8-4C03-8DB7-D200BCACF683}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 2"/>
		<Server Name="Input3" GUID="{E6503819-525F-4A18-98FD-2B73DB9E234B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 3"/>
		<Server Name="Input4" GUID="{79F01CCC-662E-4CA8-8C03-2885720FC32E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 4"/>
		<Server Name="Input5" GUID="{2316EB9B-4FA0-437C-9B23-7E27B2202D83}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 5"/>
		<Server Name="Input6" GUID="{7C5501F5-7BB0-4FD0-9772-73039D5C0D5D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 6"/>
		<Server Name="Input7" GUID="{1B115D64-8082-4DBB-B30B-B24D6BF1FCB7}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 7"/>
		<Server Name="Input8" GUID="{85ADBFE6-98FC-4ABA-89D3-D0AD8A3EB1D8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 8"/>
		<Server Name="Input_Byte" GUID="{271FCED8-39C8-474C-9F18-E7C58973710F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="The digital inputs are shown in an 8-bit field, in this server. "/>
		<Server Name="Output1" GUID="{AA4185AA-BFD1-4DCB-8C73-9DAB66CA1D81}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Output 1"/>
		<Server Name="Output2" GUID="{2CBCE74F-D9CF-463A-9E95-48A1D9437408}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Output 2"/>
		<Server Name="Output3" GUID="{1258D334-5E8B-467D-80B5-AF340F7E00E6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Output 3"/>
		<Server Name="Output4" GUID="{8B971520-E661-46C6-8B45-1489F4B44978}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Output 4"/>
		<Server Name="Output5" GUID="{D1C5E64F-1CA5-47B4-BE9C-8E5F3D3B63A0}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Output 5"/>
		<Server Name="Output6" GUID="{394E3709-6CEB-4401-9887-F4E0B5FDD53E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Output 6"/>
		<Server Name="Output7" GUID="{69F267C8-6052-4F86-8FEF-04597743BDD0}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Output 7"/>
		<Server Name="Output8" GUID="{0B603FCE-BBE2-4F7B-8C00-46330D55CECD}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Output 8"/>
		<Server Name="Output_Byte" GUID="{61D2AE2F-F4C4-45F6-8EFB-EA370754E992}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="In this server the digital outputs are shown in an 8-bit field"/>
		<Server Name="State" Visualized="true" Comment="This Server shows the state of the Modul">
		</Server>
		<Server Name="VoltageOkV1" GUID="{3656F074-70B5-4D31-A930-5948253B8786}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0 = Voltage &lt; 18V | 1 = Voltage for outputs ok (Outputs 1-4)"/>
		<Server Name="VoltageOkV2" GUID="{5764BDBA-0F55-4C68-AC8C-E1A52696060F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0 = Voltage &lt; 18V | 1 = Voltage for outputs ok (Outputs 5-8)"/>
		<Client Name="AIx_RtCy" Required="false" Internal="false" DefValue="1" Comment="0 = cyclic | 1 = realtime updating (as initvalue)"/>
		<Client Name="AnalogMode" Required="false" Internal="false" Comment="Sets the UpdateMode for the analog Inputs (works only for CDIAS)&#13;&#10;0 .. Every Cycle one Input gets converted by ADC&#13;&#10;1 .. All Inputs get converted in on Cycle (takes more time)"/>
		<Client Name="AOx_RtCy" Required="false" Internal="false" DefValue="1" Comment="0 = cyclic | 1 = realtime updating (as initvalue)"/>
		<Client Name="CounterMode1and2" Required="false" Internal="false" Comment="0 = off | 1 = upcounter on pos edge off each input (results in server &quot;Counter1&quot; and &quot;Counter2&quot;) | 2 = Enoder (Gating 1 times) (Server &quot;Encoder&quot;) | 3 = Encoder (Gating 4times)&#13;&#10;&#13;&#10;Set as initvalue"/>
		<Client Name="Input3IRQMode" Required="false" Internal="false" Comment="Set irq mode (0 = no irq | 1 = pos. edge | 2 = neg. edge | 3 = pos. and neg. edge) (as initvalue)"/>
		<Client Name="InvertInput1" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertInput2" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertInput3" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertInput4" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertInput5" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertInput6" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertInput7" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertInput8" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertOutput1" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertOutput2" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertOutput3" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertOutput4" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertOutput5" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertOutput6" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertOutput7" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="InvertOutput8" Required="false" Internal="false" Comment="0 = Normal | 1 = Inverted (as initvalue)"/>
		<Client Name="IRQWrite" Required="false" Internal="false" Comment="calls the write function off the connected object on IRQ (Bit0 = 1 =&gt; pos edge / Bit1 = 1 =&gt; neg edge)"/>
		<Client Name="RtCyInputs" Required="false" Internal="false" DefValue="1" Comment="Realtime(1) or cyclic Work(0)"/>
		<Client Name="RtCyOutputs" Required="false" Internal="false" DefValue="1" Comment="Operates all digital outputs (output 1 – 8) in a cyclic or realtime task"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="wocpet"/>
		<Dokumentation Revision="2.40" Date="05.12.2013" Author="FucHer&#13;&#10;LanSte" Company="Sigmatek" Description="Changed AWL to Structured Text&#13;&#10;Required and RtCy Clients default Value = 1&#13;&#10;Added payload support"/>
		<Dokumentation Revision="2.30" Date="30.08.2013" Author="EisMic" Company="Sigmatek" Description="Added serial number display"/>
		<Dokumentation Revision="2.24" Date="17.07.2012" Author="ObeChr" Company="Sigmatek" Description="Added special Mode for CDIAS: Both analog Inputs can be converted in one Cycle&#13;&#10;Implemented time measurement for internal tests in methods UpdateRt, UpdateRtPostScan and UpdateCy"/>
		<Dokumentation Revision="2.23" Date="19.01.2011" Author="BleErn" Company="Sigmatek" Description="Added support for CIO017"/>
		<Dokumentation Revision="2.22" Date="22.07.2010" Author="WocPet" Company="Sigmatek" Description="Changes in base class: new client &quot;Required&quot; added"/>
		<Dokumentation Revision="2.21" Date="08.07.2010" Author="wocpet/bleern" Company="Sigmatek" Description="Write protection from server &quot;Counter1&quot; , &quot;Counter2&quot; and &quot;Encoder&quot; removed&#13;&#10;Servers OutputByte/OutputWord are thread-safe now"/>
		<Dokumentation Revision="2.20" Date="11.05.2010" Author="wocpet" Company="Sigmatek" Description="Initial version - based on old CIO012_IM class - with RT Postscan"/>
	</RevDoku>
	<Network Name="CIO0xx">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{5DD530EF-1072-40DF-8DAC-F3A26DD0F284}"
				Class      = "HwBaseCDIAS"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="SerialNo"/>
					<Server Name="State"/>
					<Client Name="MasterConnect"/>
					<Client Name="Place"/>
					<Client Name="Required" Value="1"/>
					<Client Name="TimeBase"/>
					<Client Name="TimeBaseOffset"/>
					<Client Name="To_StdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.State" Destination="_base.State" Vertices="(690,210),(518,210),"/>
			<Connection Source="_base.MasterConnect" Destination="this.MasterConnect" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(690,270),(518,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using HwBaseCDIAS

CIO0xx : CLASS
: HwBaseCDIAS
	TYPE
	  _T_CIOxx_IRQState : BSINT
	  [
	    1 posEdge,
	    2 negEdge,
	  ];
	  T_SSW :
	  (
	    StartADC_Std,
	    ReadStatusADC_Std,
	    ReadStatusValue_Std,
	    ReadValue_Std
	  )$UDINT;
	END_TYPE
  //Servers:
	Input1 	: SvrCh_DINT;
	Input2 	: SvrCh_DINT;
	Input3 	: SvrCh_DINT;
	Input4 	: SvrCh_DINT;
	Input5 	: SvrCh_DINT;
	Input6 	: SvrCh_DINT;
	Input7 	: SvrCh_DINT;
	Input8 	: SvrCh_DINT;
	Output1 	: SvrCh_DINT;
	Output2 	: SvrCh_DINT;
	Output3 	: SvrCh_DINT;
	Output4 	: SvrCh_DINT;
	Output5 	: SvrCh_DINT;
	Output6 	: SvrCh_DINT;
	Output7 	: SvrCh_DINT;
	Output8 	: SvrCh_DINT;
	VoltageOkV1 	: SvrCh_DINT;
	VoltageOkV2 	: SvrCh_DINT;
	Counter1 	: SvrCh_DINT;
	Counter2 	: SvrCh_DINT;
	Encoder 	: SvrCh_DINT;
	Input_Byte 	: SvrCh_HDINT;
	Output_Byte 	: SvrCh_HDINT;
  //Clients:
	RtCyInputs 	: CltCh_DINT;
	InvertInput1 	: CltCh_DINT;
	InvertInput2 	: CltCh_DINT;
	InvertInput3 	: CltCh_DINT;
	InvertInput4 	: CltCh_DINT;
	InvertInput5 	: CltCh_DINT;
	InvertInput6 	: CltCh_DINT;
	InvertInput7 	: CltCh_DINT;
	InvertInput8 	: CltCh_DINT;
	RtCyOutputs 	: CltCh_DINT;
	InvertOutput1 	: CltCh_DINT;
	InvertOutput2 	: CltCh_DINT;
	InvertOutput3 	: CltCh_DINT;
	InvertOutput4 	: CltCh_DINT;
	InvertOutput5 	: CltCh_DINT;
	InvertOutput6 	: CltCh_DINT;
	InvertOutput7 	: CltCh_DINT;
	InvertOutput8 	: CltCh_DINT;
	Input3IRQMode 	: CltCh_DINT;
	IRQWrite 	: CltCh_DINT;
	CounterMode1and2 	: CltCh_DINT;
	AIx_RtCy 	: CltCh_DINT;
	AOx_RtCy 	: CltCh_DINT;
	AnalogMode 	: CltCh_DINT;
  //Variables:
		FirstScan 	: USINT;
		sd_VaranType 	: DINT;
		ScanMode 	: DINT;
		Myplace 	: UINT;
		InvertIn : BSINT
		[
		];

		InvertOut : BSINT
		[
		];

		OutputBits : BSINT
		[
		];

		OutputBitsOld 	: USINT;
		HandleCall 	: DINT;
		Handle8BitWrite 	: ^USINT;
		Handle8BitRead 	: ^USINT;
		HandleCounter1 	: ^UINT;
		HandleCounter2 	: ^UINT;
		HandleReadVok 	: ^UINT;
		OldInputsCY 	: USINT;
		UpdateType 	: DINT;
		oldCounter1 	: UINT;
		oldCounter2 	: UINT;
		EEProm : ARRAY [0..255] OF USINT;

		IRQCount 	: DINT;
		IRQState 	: _T_CIOxx_IRQState;
		HandleCallCy 	: DINT;
		HandleCallAI 	: ^UINT;
		b_DOIsRunningHandleCallAI 	: t_SingleRunState;
		HandleSetStart 	: ^USINT;
		Handle4Bit 	: ^USINT;
		HandleReady 	: ^USINT;
		HwInValue1 	: UINT;
		HWInValue2 	: UINT;
		thispAI : ARRAY [0..1] OF pVoid;

		LastCall 	: DINT;
		HandleCallStart1 	: ^UINT;
		b_DOIsRunningHandleCallStart1 	: t_SingleRunState;
		HandleSetStart1 	: DINT;
		HandleAO 	: DINT;
		HandleCallAO 	: DINT;
		Handle8Bit 	: ^USINT;
		HandleCallStart 	: ^UINT;
		b_DOIsRunningHandleCallStart 	: t_SingleRunState;
		HandleCallReady 	: ^UINT;
		b_DOIsRunningHandleCallReady 	: t_SingleRunState;
		HandleCallAI1 	: ^UINT;
		b_DOIsRunningHandleCallAI1 	: t_SingleRunState;
		counter 	: DINT;
		SSW 	: DINT;
		AIChannel 	: UDINT;
		HandleReady1 	: ^USINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL UpDataCY
		VAR_INPUT
			Handle 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpDateRT
		VAR_INPUT
			Handle 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan
		VAR_INPUT
			handle 	: UDINT := 0;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetEEState
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetEEData
		VAR_INPUT
			Offset 	: UINT;
		END_VAR
		VAR_OUTPUT
			Data 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddOneChannel
		VAR_INPUT
			thisp 	: ^void;
			RTCY 	: DINT;
			channel 	: DINT;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetCallHandle
		VAR_INPUT
			channel 	: DINT;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
	
	FUNCTION GetVariante
		VAR_OUTPUT
			Variante 	: USINT;
		END_VAR;
	
	FUNCTION Varan_Callback
		VAR_INPUT
			ud_reason 	: UDINT;
		END_VAR;
	
	FUNCTION UpdateInputInit
		VAR_INPUT
			Inputs 	: BINT;
		END_VAR;
	
	FUNCTION IRQMethod;
	
	FUNCTION VIRTUAL GLOBAL CheckVariante
		VAR_OUTPUT
			ok 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CallOutput;
	
	FUNCTION VIRTUAL GLOBAL CallInputs;
	
	FUNCTION VIRTUAL GLOBAL UpdateAIs;
	
	FUNCTION VIRTUAL GLOBAL UpdateAOs;
	
	FUNCTION VIRTUAL GLOBAL ReCallFactory;
	
	FUNCTION AddPayloadDOstoVaranMover
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION AddDOstoVaranMover
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output3::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output4::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output5::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output6::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output7::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output8::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output_Byte::Write
		VAR_INPUT
			input (EAX) 	: HDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: HDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB CIO0xx::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_CIO0XX
2$UINT, 40$UINT, (SIZEOF(::CIO0xx))$UINT, 
23$UINT, 24$UINT, 0$UINT, 
TO_UDINT(2636333112), "CIO0xx", //Class
TO_UDINT(1800499398), "HwBaseCDIAS", 2$UINT, 50$UINT, //Baseclass
//Servers:
(::CIO0xx.Input1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1344628668), "Input1", 
(::CIO0xx.Input2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3375117830), "Input2", 
(::CIO0xx.Input3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3190490768), "Input3", 
(::CIO0xx.Input4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(542085939), "Input4", 
(::CIO0xx.Input5.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1464378277), "Input5", 
(::CIO0xx.Input6.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3460428319), "Input6", 
(::CIO0xx.Input7.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3108422281), "Input7", 
(::CIO0xx.Input8.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(704241432), "Input8", 
(::CIO0xx.Output1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2425114930), "Output1", 
(::CIO0xx.Output2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(159711368), "Output2", 
(::CIO0xx.Output3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2122461214), "Output3", 
(::CIO0xx.Output4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3773212093), "Output4", 
(::CIO0xx.Output5.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2548143403), "Output5", 
(::CIO0xx.Output6.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(250135697), "Output6", 
(::CIO0xx.Output7.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2045768711), "Output7", 
(::CIO0xx.Output8.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3914394006), "Output8", 
(::CIO0xx.VoltageOkV1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(524465163), "VoltageOkV1", 
(::CIO0xx.VoltageOkV2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2253120945), "VoltageOkV2", 
(::CIO0xx.Counter1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(547260585), "Counter1", 
(::CIO0xx.Counter2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3113736467), "Counter2", 
(::CIO0xx.Encoder.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(500247242), "Encoder", 
(::CIO0xx.Input_Byte.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(351474530), "Input_Byte", 
(::CIO0xx.Output_Byte.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3711077976), "Output_Byte", 
//Clients:
(::CIO0xx.RtCyInputs.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(584155512), "RtCyInputs", 
(::CIO0xx.InvertInput1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1397765792), "InvertInput1", 
(::CIO0xx.InvertInput2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3394856730), "InvertInput2", 
(::CIO0xx.InvertInput3.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3177076620), "InvertInput3", 
(::CIO0xx.InvertInput4.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(591053359), "InvertInput4", 
(::CIO0xx.InvertInput5.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1413345977), "InvertInput5", 
(::CIO0xx.InvertInput6.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3442778883), "InvertInput6", 
(::CIO0xx.InvertInput7.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3123942293), "InvertInput7", 
(::CIO0xx.InvertInput8.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(713854468), "InvertInput8", 
(::CIO0xx.RtCyOutputs.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4169181740), "RtCyOutputs", 
(::CIO0xx.InvertOutput1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2223929388), "InvertOutput1", 
(::CIO0xx.InvertOutput2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(495397270), "InvertOutput2", 
(::CIO0xx.InvertOutput3.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1786779904), "InvertOutput3", 
(::CIO0xx.InvertOutput4.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4108618915), "InvertOutput4", 
(::CIO0xx.InvertOutput5.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2212740149), "InvertOutput5", 
(::CIO0xx.InvertOutput6.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(451603855), "InvertOutput6", 
(::CIO0xx.InvertOutput7.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1844305177), "InvertOutput7", 
(::CIO0xx.InvertOutput8.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4250058888), "InvertOutput8", 
(::CIO0xx.Input3IRQMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4210845645), "Input3IRQMode", 
(::CIO0xx.IRQWrite.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1819634321), "IRQWrite", 
(::CIO0xx.CounterMode1and2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(497033340), "CounterMode1and2", 
(::CIO0xx.AIx_RtCy.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3360312291), "AIx_RtCy", 
(::CIO0xx.AOx_RtCy.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2879028953), "AOx_RtCy", 
(::CIO0xx.AnalogMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1995983072), "AnalogMode", 
END_FUNCTION


#define USER_CNT_CIO0xx 30

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_CIO0xx] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION CIO0xx::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= HwBaseCDIAS::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= HwBaseCDIAS::State.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, HwBaseCDIAS::State.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_CIO0xx;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpDataCY();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpDateRT();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetEEState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #GetEEData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #AddOneChannel();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #GetCallHandle();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #CheckVariante();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #CallOutput();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #CallInputs();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #UpdateAIs();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #UpdateAOs();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #ReCallFactory();

#pragma warning (default : 74)
	HwBaseCDIAS::State.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF HwBaseCDIAS::State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output1::Write() );
	IF Output1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output2::Write() );
	IF Output2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output3.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output3::Write() );
	IF Output3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output4.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output4::Write() );
	IF Output4.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output5.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output5::Write() );
	IF Output5.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output6.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output6::Write() );
	IF Output6.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output7.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output7::Write() );
	IF Output7.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output8.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output8::Write() );
	IF Output8.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Counter1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Counter1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Counter2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Counter2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Encoder.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Encoder.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output_Byte.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output_Byte::Write() );
	IF Output_Byte.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL CIO0xx::Init
VAR
	sz_name	: array[ 0..255 ] of char;	//ws003
	HardEncMode		: USINT; // Hardwareencoder- or countingmode
	sd_retval		: DINT;
END_VAR

//============================ Profiler start======================================================
#ifdef DM_Profiler 
  InitTimeMeasurement(usMode := DMTIME_RT);
  InitTimeMeasurement(usMode := DMTIME_CY);
  InitTimeMeasurement(usMode := DMTIME_RTPOSTSCAN);
#endif
//============================ Profiler end========================================================

	if FirstScan = 0 then
     
     //first call base class
		 HWBaseCDIAS::Init();
     //reset update type
		 UpDateType :=-1;

    //readout clients and save
		if InvertInput1.Read() then
      InvertInput1 := InvertIn.1 := true;
    end_if;  
		if InvertInput2.Read() then
      InvertInput2 := InvertIn.2 := true;
    end_if;  
		if InvertInput3.Read() then
      InvertInput3 := InvertIn.3 := true;
    end_if;  
		if InvertInput4.Read() then
      InvertInput4 := InvertIn.4 := true;
    end_if;  
		if InvertInput5.Read() then
      InvertInput5 := InvertIn.5 := true;
    end_if;  
		if InvertInput6.Read() then
      InvertInput6 := InvertIn.6 := true;
    end_if;  
		if InvertInput7.Read() then
      InvertInput7 := InvertIn.7 := true;
    end_if;  
		if InvertInput8.Read() then
      InvertInput8 := InvertIn.8 := true;
    end_if;  

    //readout clients and save
		if InvertOutput1.Read() then
      InvertOutput1 := InvertOut.1 := true;
    end_if;  
		if InvertOutput2.Read() then
      InvertOutput2 := InvertOut.2 := true;
    end_if;  
		if InvertOutput3.Read() then
      InvertOutput3 := InvertOut.3 := true;
    end_if;  
		if InvertOutput4.Read() then
      InvertOutput4 := InvertOut.4 := true;
    end_if;  
		if InvertOutput5.Read() then
      InvertOutput5 := InvertOut.5 := true;
    end_if;  
		if InvertOutput6.Read() then
      InvertOutput6 := InvertOut.6 := true;
    end_if;  
		if InvertOutput7.Read() then
      InvertOutput7 := InvertOut.7 := true;
    end_if;  
		if InvertOutput8.Read() then
      InvertOutput8 := InvertOut.8 := true;
    end_if;  

    
		CounterMode1and2 := (CounterMode1and2.Read() AND 3);
		Input3IRQMode    := (Input3IRQMode.Read() AND 2#11);

		if RtCyInputs.Read() then
      RtCyInputs := true;
    end_if;  
		if RtCyOutputs.Read() then
      RtCyOutputs := true;
    end_if;  


		////#SR003 start
		//-----------------------------------------------------------------------------------------
		//look for varan bus
		sd_VaranType := MasterConnect.IsVaranAvailable();
    
		if ( b_VaranAvailable ) then

			if ( RtCyInputs | RtCyOutputs | AIx_RtCy | CounterMode1and2 | AOx_RtCy ) then	//#SR007
				ScanMode    := VARAN_DOL_ISO;
        RtCyInputs  := true;
        RtCyOutputs := true;
        AIx_RtCy    := true;
        AOx_RtCy    := true;
			else
				ScanMode := VARAN_DOL_ASY;
			end_if;

			Myplace := Place$UINT*16#100;
								
			if ( sd_VaranType = 1 ) then
      
        if b_PayloadSupport then
				//DO anlegen
          sd_retval := AddRdWrPayloadDO(ud_dol_type     := ScanMode$UDINT
                                      , p_ud_handle     := ( #HandleCall )$^UDINT
                                      , ud_offset_read  := Myplace + 1
                                      , ud_length_read  := 11
                                      , p_ud_data_read  := ( #Handle8BitRead )$^UDINT
                                      , ud_offset_write := Myplace
                                      , ud_length_write := 1
                                      , p_ud_data_write := ( #Handle8BitWrite )$^UDINT
                                      , ud_type         := 1);
        else
          //DO anlegen
				sd_retval := MasterConnect.AddRdWrDO( ud_dol_type 		:= ScanMode$UDINT
													, p_ud_handle		:= ( #HandleCall )$^UDINT
													, ud_address_read	:= Myplace + 1
													, ud_length_read	:= 11
													, p_ud_data_read	:= ( #Handle8BitRead )$^UDINT
                                              , ud_address_write:= Myplace
													, ud_length_write	:= 1
													, p_ud_data_write	:= ( #Handle8BitWrite )$^UDINT
													, ud_type			:= 1
													);
        end_if;

				//look for an error
				if ( sd_retval <> 0 ) then
					State.uiIO_Flags 				:= 0;
					State.uiIO_Flags.NoCalibration	:= 1;			//#SR004
					State.uiIO_Flags.PhysicAccessOff:= 1;
					return;
				end_if;

				//set right pointer for ref voltage
				HandleReadVok 	:= Handle8BitRead + 2;
				HandleCounter1 	:= Handle8BitRead + 7;
			
				if ( CounterMode1and2 = 1 ) then
					HandleCounter2 := Handle8BitRead + 9;
				end_if;
			end_if;

			//set callback for civ
			MasterConnect.SetObjectCallback( us_place := Place$USINT, ud_action_ptr := ( #Varan_Callback() )$UDINT, ud_thisp := this$UDINT );

			//add update call
			MasterConnect.AddVaranTask( ud_dol_type := ScanMode$UDINT, p_this := this, callOptions := CALL_OPTION_RT_PRESCAN OR CALL_OPTION_RT_POSTSCAN );

			FirstScan := 1;
			UpdateType := 0;

		else
		//#SR003 end
	 
			//-----------------------------------------------------------------------------------------	
			 if kennung = ID_CIO0xx then
       
			// --- read eerpom ----------------------------------------------
		   	MasterConnect.ReadEEData( Adress := Place, pData := #EEProm[0] );

        if CheckVariante() = false then
          State.uiIO_Flags := 0;
          State.uiIO_Flags.WrongHW := 1;
          State.uiIO_Flags.PhysicAccessOff := 1;
          return;
        end_if;  

				IF RtCyInputs | RtCyOutputs | AIx_RtCy THEN
					ScanMode := DmRealtime;
          RtCyInputs  := true;
          RtCyOutputs := true;
          AIx_RtCy    := true;
          
				ELSE
					ScanMode := DMCY;
				END_IF;

				Myplace := Place$UINT*16#100;

				IF MasterType = 2 & connection <> 0 THEN
					UpDateType :=0;
				ELSE
					UpDateType :=1;
				END_IF;

				// --- encoder -----------------------------------------------------------------------------
				CASE CounterMode1and2 OF
					0:	HardEncMode := 0; // off
					1:	HardEncMode := 0; // pos edge
					2:	HardEncMode := 2; // gating 1 times
					3:	HardEncMode := 3; // gating 4 times
				END_CASE;
				IF UpdateType = 1 THEN
					(IOSegmentByte+6)^ := HardEncMode;
				ELSE
					MasterConnect.Wr8Bit(myplace+6,HardEncMode);
				END_IF;

				// now we have to check how we are connected to the master
				if UpDateType = 0 then

					IF ScanMode = DmCY THEN
						HandleCallCy := MasterConnect.AddCall2Main(Mode:=1, RTCY:=ScanMode, thisp:=this);			//#SR000
						IF RtCyInputs = 0 THEN
							Handle8BitRead$UDINT  := (MasterConnect.AddRd8Bit(Adress:=MyPlace$UINT+1, RTCY:=ScanMode, thisp:=this))$UDINT + _IOSegment$UDINT;
						END_IF;
						IF RtCyOutputs = 0 THEN
							Handle8BitWrite$UDINT := (MasterConnect.AddWr8Bit(Adress:=MyPlace$UINT+0, RTCY:=ScanMode, thisp:=this, data:=OutputBits$USINT XOR InvertOut))$UDINT + _IOSegment$UDINT;
						END_IF;
						HandleReadVok$UDINT   := (MasterConnect.AddRd8Bit(Adress:=MyPlace$UINT+3, RTCY:=ScanMode, thisp:=this))$UDINT + _IOSegment$UDINT;
						MasterConnect.AddRet(RTCY:=ScanMode);
					END_IF;

					IF RtCyInputs | RtCyOutputs | CounterMode1and2 THEN
						HandleCall := MasterConnect.AddCall2Main(Mode:=1, RTCY:=DMRealtime, thisp:=this, callOptions := CALL_OPTION_RT_PRESCAN OR CALL_OPTION_RT_POSTSCAN );
						IF CounterMode1and2 THEN // counter 1 allways
							HandleCounter1$UDINT	:= (MasterConnect.AddRd16Bit(Adress:=MyPlace$UINT+16#08, RTCY:=DMRealtime, thisp:=this))$UDINT + _IOSegment$UDINT;
							oldCounter1 := (MasterConnect.Rd16Bit(MyPlace$UINT+16#08))$UINT;
						END_IF;
						IF CounterMode1and2 = 1 THEN // counter 2 only mode 1
							HandleCounter2$UDINT	:= (MasterConnect.AddRd16Bit(Adress:=MyPlace$UINT+16#0A, RTCY:=DMRealtime, thisp:=this))$UDINT + _IOSegment$UDINT;
							oldCounter2 := (MasterConnect.Rd16Bit(MyPlace$UINT+16#0A))$UINT;
						END_IF;
						IF RtCyInputs THEN
							Handle8BitRead$UDINT  := (MasterConnect.AddRd8Bit(Adress:=MyPlace$UINT+1, RTCY:=DMRealtime, thisp:=this))$UDINT + _IOSegment$UDINT;
						END_IF;
						IF RtCyOutputs THEN
							Handle8BitWrite$UDINT := (MasterConnect.AddWr8Bit(Adress:=MyPlace$UINT+0, RTCY:=DMRealtime, thisp:=this, data:=OutputBits$USINT XOR InvertOut))$UDINT + _IOSegment$UDINT;
						END_IF;
						if ScanMode <> DmCy THEN															//#SR000
							HandleReadVok$UDINT   := (MasterConnect.AddRd8Bit(Adress:=MyPlace$UINT+3, RTCY:=ScanMode, thisp:=this))$UDINT + _IOSegment$UDINT;
						end_if;
						MasterConnect.AddRet(RTCY:=DMRealtime);
					END_IF;

					// now read direct the data and put them into server to avoid startup problem 
					UpdateInputInit((MasterConnect.Rd8Bit(myplace+3) SHL 8)$UINT OR TO_UINT(MasterConnect.Rd8Bit((place*16#100)$UINT+1) XOR InvertIn));
				else
					IF ScanMode = DmCY THEN
						HandleCallCy := MasterConnect.AddCall2List(Mode:=0, RTCY:=ScanMode, thisp:=this);
					END_IF;

					Handle8BitRead$UDINT  := IOSegmentByte$UDINT+1;
					Handle8BitWrite$UDINT := IOSegmentByte$UDINT+0;
					HandleReadVok$UDINT   := IOSegmentByte$UDINT+3;
          
          

					IF RtCyInputs | RtCyOutputs | AIx_RtCy | CounterMode1and2 THEN
						HandleCall := MasterConnect.AddCall2List(Mode:=0, RTCY:=DMRealtime, thisp:=this, callOptions := CALL_OPTION_RT_PRESCAN OR CALL_OPTION_RT_POSTSCAN );
					END_IF;
					IF CounterMode1and2 THEN // counter 1 allways
						HandleCounter1$UDINT	:= IOSegmentWord$UDINT+16#08;
						oldCounter1 := (HandleCounter1$^UINT)^;
					END_IF;
					IF CounterMode1and2 = 1 THEN // counter 2 only mode 1
						HandleCounter2$UDINT	:= IOSegmentWord$UDINT+16#0A;
						oldCounter2 := (HandleCounter2$^UINT)^;
					END_IF;

					// now read direct the data and put them into server to avoid startup problem 
					UpdateInputInit( (TO_UINT((IOSegmentByte+3)^) SHL 8) OR (TO_UINT((IOSegmentByte+1)^ XOR InvertIn)) );
				end_if;

				FirstScan :=1;
				State.uiIO_Flags:=0;

				OutputBitsOld := NOT(OutputBits);
				UpDateRt(Handle := HandleCall$UDINT );

				// --- irq ---------------------------------------------------------------------------------	
				IF Input3IRQMode THEN
					IF MasterConnect.AddCDiasIRQ(0,#IRQMethod(),this) = 0 THEN
						//ws003
						_GetObjName( this, #sz_name[ 0 ] );
						trace( #sz_name[ 0 ] );
						//pObj := LSL_GetHdr(this);
						//TRACE( (#pObj^.pObjDsc^.SymName)$^CHAR ); // => give out the objectname
						// /ws003
					ELSE
						// enable the irq
						IF UpdateType = 1 THEN
							(IOSegmentByte+4)^ := Input3IRQMode$USINT;
						ELSE
							MasterConnect.Wr8Bit(myplace+4,(Input3IRQMode$USINT));
						END_IF;
					END_IF;
				END_IF;

				// --- read eerpom --------------------------------------------------------------------------
				MasterConnect.ReadEEData(Adress:=Place, pData:=#EEProm[0]);

			else
				State.uiIO_Flags:=0;
				//#SR004 start
				if ( Kennung = 255 ) then
					State.uiIO_Flags.NoHW := 1;
				else	
					State.uiIO_Flags.WrongHW := 1;
				end_if;
				//#SR004 end
				State.uiIO_Flags.PhysicAccessOff :=1;
			end_if;
		end_if;			//#SR003
	end_if;

	IF ( _firstscan & b_VaranAvailable = FALSE ) THEN			//#SR007
		IF FirstScan THEN
			// ref on
			IF UpdateType = 1 THEN
				(IOSegmentByte+16#16)^ := 16#80;
			ELSE
				MasterConnect.Wr8Bit(myplace+16#16,16#80);
			END_IF;
		END_IF;
	END_IF;



END_FUNCTION


FUNCTION CIO0xx::Varan_Callback
	VAR_INPUT
		ud_reason 	: UDINT;
	END_VAR
VAR
	HardEncMode		: USINT;
	sd_retval		: DINT;
	a_data			: ARRAY[0..10] OF USINT;
	sz_name	: array[ 0..255 ] of char;
END_VAR

	//look for reason
	if ( ud_reason = 0 ) then		//connect
		if b_PayloadSupport & sd_VaranType = 2 then
		
      sd_retval := AddPayloadDOstoVaranMover();
    
      if ( sd_retval <> 0 ) then
        State.uiIO_Flags					:= 0;
        State.uiIO_Flags.NoCalibration		:= 1;
        State.uiIO_Flags.PhysicAccessOff	:= 1;
        return;
      end_if;
    end_if;
      
		//read Kennung
		Kennung := MasterConnect.GetKennung( Place );
	 	
		//check right mod id
	 	if ( Kennung = ID_CIO0xx ) then
		
			// --- read eerpom ----------------------------------------------
		  MasterConnect.ReadEEData( Adress := Place, pData := #EEProm[0] );

			//look for right variant
			if CheckVariante() = false then
				State.uiIO_Flags					:= 0;
				State.uiIO_Flags.WrongHW 			:= 1;
				State.uiIO_Flags.PhysicAccessOff	:= 1;
				return;
			end_if;				

			// --- encoder -----------------------------------------------------------------------------
			case ( CounterMode1and2 ) of
				0:	HardEncMode := 0; // off
				1:	HardEncMode := 0; // pos edge
				2:	HardEncMode := 2; // gating 1 times
				3:	HardEncMode := 3; // gating 4 times
			end_case;

			MasterConnect.Wr8Bit( myplace + 6, HardEncMode );

			//write data with direct access
			sd_retval := MasterConnect.RdDO( ud_address	:= Myplace + 1
											, ud_length	:= 11
											, p_ud_data	:= #a_data
											, ud_type	:= 1
											);

			//look for an error
			if ( sd_retval <> 0 ) then
				State.uiIO_Flags					:= 0;
//#SR003				State.uiIO_Flags.WrongHW 			:= 1;
				State.uiIO_Flags.PhysicAccessOff	:= 1;
				return;
			end_if;

			IF CounterMode1and2 THEN // counter 1 allways
				oldCounter1 := a_data[ 7 ]$UINT;
			END_IF;
			IF CounterMode1and2 = 1 THEN // counter 2 only mode 1
				oldCounter2 := a_data[ 9 ]$UINT;
			END_IF;

			Output_Byte.write( 0 );			

			// now read direct the data and put them into server to avoid startup problem 
			UpdateInputInit( ( a_data[ 2 ] SHL 8 )$UINT OR TO_UINT( a_data[ 0 ] XOR InvertIn ) );

			// --- irq ---------------------------------------------------------------------------------	
			if ( Input3IRQMode ) then
				if ( MasterConnect.AddCDiasIRQ(0,#IRQMethod(), this ) = 0 ) then
					_GetObjName( this, #sz_name[ 0 ] );
					trace( #sz_name[ 0 ] );
				end_if;
			end_if;

			//read eeprom
		   	sd_retval := MasterConnect.ReadEEData( Adress := Place, pData := #EEProm[ 0 ] );

			//look for an error
			if ( sd_retval <> 0 ) then
				State.uiIO_Flags					:= 0;
				State.uiIO_Flags.NoCalibration		:= 1;			//#SR003
				State.uiIO_Flags.PhysicAccessOff	:= 1;
				return;
			end_if;

			//#SR006 start
			if ( sd_VaranType = 2 & b_PayloadSupport = FALSE) then
				
        sd_retval := AddDOstoVaranMover();
        
					if ( sd_retval <> 0 ) then
						State.uiIO_Flags 				:= 0;
						State.uiIO_Flags.NoCalibration	:= 1;
          State.uiIO_Flags.PhysicAccessOff	:= 1;
						return;
					end_if;
				end_if;			
			//CAICIOAInputChannel0.ReCallFactory();
			//CAICIOAInputChannel1.ReCallFactory();
			//CIOOutputChannel0.ReCallFactory();
      ReCallFactory();

			if ( sd_VaranType = 1 ) then			//#SR006
        if b_PayloadSupport = FALSE then
				//set right address of do
				MasterConnect.SetNewDOAddressRdWr( p_data := Handle8BitWrite$^DINT, ud_address_read := Myplace + 1, ud_address_write := Myplace );

				//set right address of do
				MasterConnect.SetNewDOAddressWr( p_data := HandleSetStart$^DINT, ud_address := Myplace + 16#10 );

				//set right address of do
				MasterConnect.SetNewDOAddressWr( p_data := HandleSetStart1$^DINT, ud_address := Myplace + 16#11 );

				//set right address of do
				MasterConnect.SetNewDOAddressRd( p_data := HandleReady$^DINT, ud_address := Myplace + 16#13 );

				//set right address of do
				MasterConnect.SetNewDOAddressRd( p_data := Handle8Bit$^DINT, ud_address := Myplace + 16#10 );
			
				//set right address of do
				MasterConnect.SetNewDOAddressWr( p_data := HandleAO$^DINT, ud_address := Myplace + 16#14 );
	      end_if;
  				//start data object
				MasterConnect.ResetDO( p_data_object := HandleCall$^DINT, us_state := VARAN_DO_CONT_RUN, ud_bytes := 12 );
	
				//start data object
				MasterConnect.ResetDO( p_data_object := HandleCallStart$^DINT, us_state := VARAN_DO_NO_RUN, ud_bytes := 1 );
  			
				//start data object
				MasterConnect.ResetDO( p_data_object := HandleCallStart1$^DINT, us_state := VARAN_DO_NO_RUN, ud_bytes := 1 );
  
  				//start data object
				MasterConnect.ResetDO( p_data_object := HandleCallReady$^DINT, us_state := VARAN_DO_NO_RUN, ud_bytes := 1 );
  				//start data object
				MasterConnect.ResetDO( p_data_object := HandleCallAI$^DINT, us_state := VARAN_DO_NO_RUN, ud_bytes := 3 );

        //start data object
        if b_PayloadSupport then
          EnableDO(ud_DOHandle := HandleCallAO$UDINT);
        else
				MasterConnect.ResetDO( p_data_object := HandleCallAO$^DINT, us_state := VARAN_DO_SINGLE_RUN, ud_bytes := 2 );
			end_if;
				
			end_if;

			MasterConnect.Wr16Bit(Myplace+16#14,(EEProm[16#C8])$UINT); // initialize analog output with 0		//#SR003
			( HandleAO$^UINT )^ := EEProm[ 16#C8 ]$UINT;				//#SR003
			MasterConnect.Wr8Bit( myplace + 16#16,16#80 );

			State.uiIO_Flags:=0;				//Mark module as ok
			
		else
			State.uiIO_Flags := 0;
			//#SR003 start
			if ( Kennung = 255 ) then
				State.uiIO_Flags.NoHW := 1;
			else	
				State.uiIO_Flags.WrongHW := 1;
			end_if;
			//#SR003 end
			State.uiIO_Flags.PhysicAccessOff := 1;
		end_if;

	else
		
		if ( sd_VaranType = 1 ) then	//#SR006
			//start data object
			MasterConnect.ResetDO( p_data_object := HandleCall$^DINT, us_state := VARAN_DO_NO_RUN, ud_bytes := 12 );

			//pointer is NIL, if module isn't available
      if ( HandleCallAO <> NIL ) then
        //start data object
        MasterConnect.ResetDO( p_data_object := HandleCallAO$^DINT, us_state := VARAN_DO_NO_RUN, ud_bytes := 2 );
      end_if;
		end_if;
    
    // Reset Singlerun flags
    b_DOIsRunningHandleCallStart1 := 0;
    b_DOIsRunningHandleCallStart  := 0;
    b_DOIsRunningHandleCallReady  := 0;
    b_DOIsRunningHandleCallAI     := 0;
    b_DOIsRunningHandleCallAI1    := 0;

		State.uiIO_Flags					:= 0;
		State.uiIO_Flags.NoHW	 			:= 1;				//#SR003
		State.uiIO_Flags.PhysicAccessOff	:= 1;

		//CIOOutputChannel0.SetStateOff();
	end_if;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::GetEEData
VAR_INPUT
  Offset 	: UINT;
END_VAR
VAR_OUTPUT
  Data 	: UINT;
END_VAR

	Data := EEProm[Offset]$UINT;

END_FUNCTION


FUNCTION CIO0xx::GetVariante
	VAR_OUTPUT
		Variante 	: USINT;
	END_VAR

  Variante := EEProm[3];

END_FUNCTION


FUNCTION CIO0xx::UpdateInputInit
VAR_INPUT
	Inputs		: BINT;
END_VAR

	Input1 := inputs.1;
	Input2 := inputs.2;
	Input3 := inputs.3;
	Input4 := inputs.4;
	Input5 := inputs.5;
	Input6 := inputs.6;
	Input7 := inputs.7;
	Input8 := inputs.8;

	VoltageOkV1 := Inputs.9;
	VoltageOkV2 := Inputs.10;

	//that the server's are refreshed by the next CY/RT passing
	Input_Byte := inputs and 16#ff;
	OldInputsCy := Inputs$USINT;

END_FUNCTION


FUNCTION CIO0xx::IRQMethod
  
// FucHer 14.08.2013: siehe Hilfe-Kapitel 'Programmierung > AWL Anweisungen > Statusregistermanipulation > STI'
// Laut Otto Koller für ARM nicht notwendig. Für INTEL gilt "Never change a working program".
#ifdef _LSL_TARGETARCH_X86
  STI();
#endif

  IRQState := (IOSegmentByte + 4)^;
  IRQState := IRQState and 2#11;
  if IRQState <> 0 then
    IRQCount +=1;
    IRQWrite.Write (IRQState);
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::AddOneChannel
	VAR_INPUT
		thisp 	: ^void;
		RTCY 	: DINT;
		channel 	: DINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR
VAR
	ScanModeAdd : DINT;
	sd_retval	: DINT;
END_VAR

	//look for varan bus
  
	//look if init is called
	if ( Kennung = 16#FF ) then
		CIO0xx::Init();
	end_if;


	Handle := 0;
	IF UpdateType = 1 THEN
		//(IOSegmentByte+4)^ := Input3IRQMode$USINT;

		IF Channel = 0 | Channel = 1 THEN
			// input 
			IF Channel = 0 THEN
				IF AIx_RtCy =  0 THEN
			   		ScanModeAdd := DmCY;
			  	ELSE
			   		ScanModeAdd := DmRealtime;
			  	END_IF;
        HandleCallAI	:= (MasterConnect.AddCall2List(0,ScanModeAdd,this))$^UINT ;
        HandleSetStart	:= 
        Handle8Bit	:= IOSegmentByte + 16#10;
        Handle4Bit	:= IOSegmentByte+16#12;
        HandleReady	:= IOSegmentByte+16#13;
			END_IF;
		
      if AnalogMode then
        if channel = 0 then
          Handle$UDINT 		:= (#HwInValue1)$UDINT -_IOSegment$UDINT;
        else
          Handle$UDINT 		:= (#HwInValue2)$UDINT- _IOSegment$UDINT;
        end_if;
      else
        Handle$UDINT 		:= (#HwInValue1)$UDINT - _IOSegment$UDINT;
      end_if;
      
			thispAI[Channel] := thisp;
      

		ELSIF Channel = 8 THEN
			// output
			IF AOx_RtCy =  0 THEN
		   		ScanModeAdd := DmCY;
		  	ELSE
		   		ScanModeAdd := DmRealtime;
		  	END_IF;

			LastCall := MasterConnect.AddCall2List(0,ScanModeAdd,thisp, callOptions := CALL_OPTION_RT_PRESCAN OR CALL_OPTION_RT_POSTSCAN);
			Handle$UDINT := IOSegmentWord$UDINT - _IOSegment$UDINT + 16#14 ;

			//set output data to 0
			( ( IOSegmentWord + 16#14 )$^UINT )^ := EEProm[ 16#C8 ]$UINT;			//#SR004

		END_IF;
	ELSE
		IF Channel = 0 | Channel = 1 THEN
			// input 
			IF Channel = 0 THEN

				//#SR003 start
				if ( b_VaranAvailable = TRUE ) then
					if ( sd_VaranType = 1 ) then			//#SR007
						//DO anlegen
            if b_PayloadSupport then
              sd_retval := AddWrPayloadDO(ud_dol_type     := ScanMode$UDINT
															, p_ud_handle		:= ( #HandleCallStart )$^UDINT
                                        , ud_offset_write := myplace + 16#10
                                        , ud_length_write := 1
                                        , p_ud_data_write := ( #HandleSetStart )$^UDINT
                                        , ud_type         := 1
                                        );

              //look for an error
              if ( sd_retval <> 0 ) then
                State.uiIO_Flags 				:= 0;
                State.uiIO_Flags.Nocalibration	:= 1;			//#SR004
                State.uiIO_Flags.PhysicAccessOff:= 1;
                return;
              end_if;

              ( HandleSetStart$^USINT )^ := 16#FF;

              //DO anlegen
              sd_retval := AddWrPayloadDO(ud_dol_type     := ScanMode$UDINT
                                        , p_ud_handle     := ( #HandleCallStart1 )$^UDINT
                                        , ud_offset_write := myplace + 16#11
                                        , ud_length_write := 1
                                        , p_ud_data_write := ( #HandleSetStart1 )$^UDINT
                                        , ud_type         := 1
                                        );

              //look for an error
              if ( sd_retval <> 0 ) then
                State.uiIO_Flags				:= 0;
                State.uiIO_Flags.NoCalibration	:= 1;			//#SR004
                State.uiIO_Flags.PhysicAccessOff:= 1;
                return;
              end_if;

              ( HandleSetStart1$^USINT )^ := 16#FF;

              //DO anlegen
              sd_retval := AddRdPayloadDO(ud_dol_type   := ScanMode$UDINT
                                        , p_ud_handle   := ( #HandleCallReady )$^UDINT
                                        , ud_offset_read:= myplace + 16#13
                                        , ud_length_read:= 1
                                        , p_ud_data_read:= ( #HandleReady )$^UDINT
                                        , ud_type       := 1
                                        );

              //look for an error
              if ( sd_retval <> 0 ) then
                State.uiIO_Flags				:= 0;
                State.uiIO_Flags.NoCalibration	:= 1;			//#SR004
                State.uiIO_Flags.PhysicAccessOff:= 1;
                return;
              end_if;

              //DO anlegen
              sd_retval := AddRdPayloadDO(ud_dol_type   := ScanMode$UDINT
                                        , p_ud_handle   := ( #HandleCallAI )$^UDINT
                                        , ud_offset_read:= myplace + 16#10
                                        , ud_length_read:= 1
                                        , p_ud_data_read:= ( #Handle8Bit )$^UDINT
                                        , ud_type       := 1
                                        );
              //look for an error
              if ( sd_retval <> 0 ) then
                State.uiIO_Flags				:= 0;
                State.uiIO_Flags.NoCalibration	:= 1;			//#SR004
                State.uiIO_Flags.PhysicAccessOff:= 1;
                return;
              end_if;

              //#SR007 start
              //DO anlegen (Adress 16#11 must not read -> ADC goes to sleep mode)
              sd_retval := AddRdPayloadDO(ud_dol_type:=ScanMode$UDINT
                                      , p_ud_handle:=( #HandleCallAI1 )$^UDINT
                                      , ud_offset_read:=myplace + 16#12
                                      , ud_length_read:=1
                                      , p_ud_data_read:=( #Handle4Bit )$^UDINT
                                      , ud_type:=1
                                      );

              //look for an error
              if ( sd_retval <> 0 ) then
                State.uiIO_Flags				:= 0;
                State.uiIO_Flags.NoCalibration	:= 1;
                State.uiIO_Flags.PhysicAccessOff:= 1;
                return;
              end_if;
            else
              sd_retval := MasterConnect.AddWrDO( ud_dol_type := ScanMode$UDINT
                                                , p_ud_handle := ( #HandleCallStart )$^UDINT
															, ud_address		:= myplace + 16#10
															, ud_length			:= 1
															, p_ud_data			:= ( #HandleSetStart )$^UDINT
															, ud_type			:= 1
															);

						//look for an error
						if ( sd_retval <> 0 ) then
							State.uiIO_Flags 				:= 0;
							State.uiIO_Flags.Nocalibration	:= 1;			//#SR004
							State.uiIO_Flags.PhysicAccessOff:= 1;
							return;
						end_if;

						( HandleSetStart$^USINT )^ := 16#FF;

						//DO anlegen
              sd_retval := MasterConnect.AddWrDO( ud_dol_type := ScanMode$UDINT
															, p_ud_handle		:= ( #HandleCallStart1 )$^UDINT
															, ud_address		:= myplace + 16#11
															, ud_length			:= 1
															, p_ud_data			:= ( #HandleSetStart1 )$^UDINT
															, ud_type			:= 1
															);

						//look for an error
						if ( sd_retval <> 0 ) then
							State.uiIO_Flags				:= 0;
							State.uiIO_Flags.NoCalibration	:= 1;			//#SR004
							State.uiIO_Flags.PhysicAccessOff:= 1;
							return;
						end_if;

						( HandleSetStart1$^USINT )^ := 16#FF;

						//DO anlegen
              sd_retval := MasterConnect.AddRdDO( ud_dol_type := ScanMode$UDINT
															, p_ud_handle		:= ( #HandleCallReady )$^UDINT
															, ud_address		:= myplace + 16#13
															, ud_length			:= 1
															, p_ud_data			:= ( #HandleReady )$^UDINT
															, ud_type			:= 1
															);

						//look for an error
						if ( sd_retval <> 0 ) then
							State.uiIO_Flags				:= 0;
							State.uiIO_Flags.NoCalibration	:= 1;			//#SR004
							State.uiIO_Flags.PhysicAccessOff:= 1;
							return;
						end_if;

						//DO anlegen
              sd_retval := MasterConnect.AddRdDO( ud_dol_type := ScanMode$UDINT
															, p_ud_handle		:= ( #HandleCallAI )$^UDINT
															, ud_address		:= myplace + 16#10
															, ud_length			:= 1							//#SR007 (instead of 3)
															, p_ud_data			:= ( #Handle8Bit )$^UDINT
															, ud_type			:= 1
															);

						//look for an error
						if ( sd_retval <> 0 ) then
							State.uiIO_Flags				:= 0;
							State.uiIO_Flags.NoCalibration	:= 1;			//#SR004
							State.uiIO_Flags.PhysicAccessOff:= 1;
							return;
						end_if;

						//#SR007 start
						//DO anlegen (Adress 16#11 must not read -> ADC goes to sleep mode)
              sd_retval := MasterConnect.AddRdDO( ud_dol_type := ScanMode$UDINT
															, p_ud_handle		:= ( #HandleCallAI1 )$^UDINT
															, ud_address		:= myplace + 16#12
															, ud_length			:= 1
															, p_ud_data			:= ( #Handle4Bit )$^UDINT
															, ud_type			:= 1
															);

						//look for an error
						if ( sd_retval <> 0 ) then
							State.uiIO_Flags				:= 0;
							State.uiIO_Flags.NoCalibration	:= 1;
							State.uiIO_Flags.PhysicAccessOff:= 1;
							return;
						end_if;
            end_if;
						//#SR007 end
					end_if;
				else
				//#SR003 end	
	
					IF AIx_RtCy =  0 THEN
				   		ScanModeAdd := DmCY;
				  	ELSE
				   		ScanModeAdd := DmRealtime;
				  	END_IF;

					//#SR000 Start
          HandleCallStart	:= (MasterConnect.AddCall2Main(DMSingle,ScanModeAdd,this))$^UINT;
					HandleSetStart$UDINT	:= (MasterConnect.AddWr8Bit(Myplace+16#10,ScanModeAdd,this,16#FF))$UDINT + _IOSegment$UDINT;
					MasterConnect.AddRet(ScanModeAdd);

					//#SR002 start
          HandleCallStart1	:= (MasterConnect.AddCall2Main(DMSingle,ScanModeAdd,this))$^UINT ;
					HandleSetStart1$UDINT	:= (MasterConnect.AddWr8Bit(Myplace+16#11,ScanModeAdd,this,16#FF))$UDINT + _IOSegment$UDINT;
					MasterConnect.AddRet(ScanModeAdd);
					//#SR002 end

          HandleCallReady := (MasterConnect.AddCall2Main(DMSingle,ScanModeAdd,this))$^UINT;
          HandleReady		:= (MasterConnect.AddRd8Bit(Myplace+16#13,ScanModeAdd,this))$^USINT + _IOSegment;
					MasterConnect.AddRet(ScanModeAdd);						

          LastCall$^UINT				:= HandleCallAI	:= (MasterConnect.AddCall2Main(DMSingle,ScanModeAdd,this))$^UINT ;
          Handle8Bit		:= (MasterConnect.AddRd8Bit(Myplace+16#10,ScanModeAdd,this))$^USINT + _IOSegment;
          Handle4Bit		:= (MasterConnect.AddRd8Bit(Myplace+16#12,ScanModeAdd,this))$^USINT + _IOSegment;
					MasterConnect.AddRet(ScanModeAdd);
					//#SR000 End
				end_if;		//#SR003

			END_IF;
			Handle$UDINT := (#HwInValue1)$UDINT - _IOSegment$UDINT;
			thispAI[Channel] := thisp;

		ELSIF Channel = 8 THEN
			// output
			//#SR003 start
			if ( b_VaranAvailable ) then

				if ( sd_VaranType = 1 ) then			//#SR007
				  if b_PayloadSupport then
            sd_retval := AddWrPayloadDO(ud_dol_type:=ScanMode$UDINT
                         , p_ud_handle:=( #LastCall )$^UDINT
                         , ud_offset_write:=myplace + 16#14
                         , ud_length_write:=2
                         , p_ud_data_write:=( #Handle )$^UDINT
                         , ud_type:=1);
				
          else
          
					sd_retval := MasterConnect.AddWrDO	( ud_dol_type 		:= ScanMode$UDINT
														, p_ud_handle		:= ( #LastCall )$^UDINT
														, ud_address		:= myplace + 16#14
														, ud_length			:= 2
														, p_ud_data			:= ( #Handle )$^UDINT
														, ud_type			:= 1
														);
          end_if;
					//look for an error
					if ( sd_retval <> 0 ) then
						State.uiIO_Flags				:= 0;
						State.uiIO_Flags.NoCalibration	:= 1;			//#SR004
						State.uiIO_Flags.PhysicAccessOff:= 1;
						return;
					end_if;
	
					HandleAO := Handle;
					HandleCallAO := LastCall;

//#SR004				( Handle$^UINT )^ := EEProm[ 16#C8 ]$UINT;
					Handle$UDINT -= _IOSegment;
				
				else
					Handle$UDINT := HandleAO$UDINT - _IOSegment;		//#SR007

				end_if;
				//make task for AO class
//#SR006				MasterConnect.AddVaranTask( ud_dol_type := ScanModeAdd$UDINT, p_this := thisp );

			else
			//#SR003 end

				IF AOx_RtCy =  0 THEN
			   		ScanModeAdd := DmCY;
			  	ELSE
			   		ScanModeAdd := DmRealtime;
			  	END_IF;

				LastCall := MasterConnect.AddCall2Main(0,ScanModeAdd,thisp, callOptions := CALL_OPTION_RT_PRESCAN OR CALL_OPTION_RT_POSTSCAN);
				Handle := MasterConnect.AddWr16Bit(Myplace+16#14,ScanModeAdd,thisp,(EEProm[16#C8])$UINT);
				MasterConnect.AddRet(ScanModeAdd);
				MasterConnect.Wr16Bit(Myplace+16#14,(EEProm[16#C8])$UINT); // initialize with 0
			end_if;

		END_IF;
	END_IF;

END_FUNCTION

#pragma warning(disable:73);
FUNCTION VIRTUAL GLOBAL CIO0xx::GetCallHandle
	VAR_INPUT
		channel 	: DINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR

	Handle := LastCall;

END_FUNCTION
#pragma warning(default:73);


FUNCTION VIRTUAL GLOBAL CIO0xx::UpDateRT
	VAR_INPUT
		Handle 	: UDINT;
	END_VAR  
  VAR
  	newCounter1 :UINT;
    newCounter2 :UINT;
    newInputs   :DINT;
    InputMask   :USINT;
    pInPutSrv   :^DINT;
    Volbits     :UINT;
	END_VAR

//============================ Profiler start======================================================
#ifdef  DM_Profiler								
  StartTimeMeasurement(DMTIME_RT);
#endif	
//============================ Profiler end========================================================   

  if Handle = HandleCall$UDINT & Handle > 0 | b_VaranAvailable then
    // Update Counter
    if HandleCounter1 <> 0 then
      if HandleCounter2 <> 0 then   
        newCounter2 := HandleCounter2^;
        Counter2 += to_sint((newCounter2) - oldCounter2);
        oldCounter2 := newCounter2;
      end_if;
	
      newCounter1 := HandleCounter1^;      
      if HandleCounter2 = 0 then
        Encoder += to_sint( newCounter1 - oldCounter1);
      else
        Counter1 += to_sint((newCounter1) - oldCounter1);
      end_if;
      oldCounter1 := newCounter1;
    end_if;
	
      //Update Digital Inputs
    if RtCyInputs <> 0 | b_VaranAvailable then
	
      newInputs := Handle8bitRead^ xor InvertIn;//get Data from Controller and Invert it in Case of the Invert bit is set
      InputMask := OldInputsCY xor newInputs$USINT;//old Input xor new Input (to see changes)
      OldInputsCY := newInputs$USINT;
      if InputMask <> 0 then
        Input_Byte := newInputs$UDINT; 
        pInputSrv :=#Input1.Ddata;

        repeat
  
          if inputMask and 1 then       
            pInputSrv^ := newInputs and 1;      
          end_if;
  
          inputMask := inputMask shr 1;   
          newInputs := newInputs shr 1; 
          pInputSrv += sizeof(SvrCh);     
  
        until inputMask = 0 end_repeat; 
          
      end_if; 
    end_if;
    
      //Update VoltageOKBits
    if b_VaranAvailable = FALSE  | ScanMode <> DmCy then
      VolBits := HandleReadVok^;
      
      if VolBits and 1 then
        VoltageOkV1 := 1;
      else
        VoltageOkV1 := 0;
      end_if;
      if Volbits and 2#10 then
        VoltageOkV2 := 1;
      else
        VoltageOkV2 := 0;
      end_if;
    end_if;
  end_if;
  
  if Handle = HandleCallAI$UDINT & Handle > 0| b_VaranAvailable = TRUE then
  // Update Analog Inputs IM
  
  
    if AnalogMode = FALSE & b_VaranAvailable = FALSE then
      if UpdateType = 1 then
        if counter > 5 then
          counter := 0;
          SSW := 0;
        end_if;
        
        case SSW of
          0:  
            Counter := 0;
            (HandleSetStart +(AIChannel xor 1))^ := 16#FF;
            SSW += 1;
            return;
          1:
            if HandleReady^ and 2#10 then
              Counter += 1;
            else

              Counter := 0;
              (HandleSetStart +(AIChannel xor 1))^ := 16#FF;
              SSW += 1;
              return;
            end_if;
          2:
            if HandleReady^ and 2#01 then
              HwInValue1 :=(Handle8Bit)^ or (((Handle4Bit)^ and 16#F) shl 8)  ;
 
              SSW := 0;
              AIChannel := AIChannel xor 1;
              CallInputs();
              return;
            else
              Counter +=1;
            end_if;
         
        end_case;

      end_if;

    elsif AnalogMode = TRUE then  // FAST MODE
  
      (HandleSetStart+1)^:= 16#FF;
  
      // Wait for Ready Bits
      while HandleReady^ and 2#10 do   end_while;
      while HandleReady^ and 1 =FALSE do   end_while;
  
      HwInValue1 := (Handle8Bit )^ or (((Handle4Bit )^ and 16#F) shl 8);//Read Value
  
  
      HandleSetStart^:= 16#FF;
      // Wait for Ready Bits
      while HandleReady^ and 2#10 do   end_while;
      while HandleReady^ and 1 =FALSE do   end_while;
  
      HwInValue2 := (Handle8Bit )^ or (((Handle4Bit )^ and 16#F) shl 8);//Read Value
      CallInputs();
      return;
    end_if;
  
    // No Intelligent Master or Varan
    if UpdateType = 0 | b_VaranAvailable = TRUE then    
      // Active Mover 
      if sd_VaranType = 2  then
  
        //Channel 0
        HwInValue1 := (HandleReady )^ or (((HandleReady1 )^ and 16#F) shl 8);//Read Value       
        AIChannel := 0;
        CallInputs();
  
        // Channel 1 
        HwInValue1 := (Handle8Bit)^ or (((Handle4Bit)^ and 16#F) shl 8);
        AIChannel := 1;
        CallInputs();
      else
        // No Mover
        if counter > 5 then
          ssw := 0;
          counter := 0;
        end_if;
        
        case SSW of
          0:// Select Channel
            if AIChannel = 1 then
              if b_VaranAvailable = FALSE then
                (HandleCallStart1 + _IOSegment)$^USINT^ := DMSINGLE; 
                AIChannel := 0;
              else
                
                if b_PayloadSupport then
                  b_DOIsRunningHandleCallStart1.StartRequest := true;
                else
                  MasterConnect.ResetDO(p_data_object:=HandleCallStart1$^DINT, us_state:=VARAN_DO_SINGLE_RUN, ud_bytes:=1);
                end_if;
                
                AIChannel := 0;
              end_if;
            elsif AIChannel =0 then
              if b_VaranAvailable = FALSE then
                (HandleCallStart + _IOSegment)$^USINT^ := DMSINGLE; 
                AIChannel := 1;
              else
                
                if b_PayloadSupport then
                  b_DOIsRunningHandleCallStart.StartRequest := true;
                else
                  MasterConnect.ResetDO(p_data_object:=HandleCallStart$^DINT, us_state:=VARAN_DO_SINGLE_RUN, ud_bytes:=1);
                end_if;
                
                AIChannel := 1;
              end_if; 
            end_if;
            Counter := 0;
            SSW += 1;
            if b_VaranAvailable = FALSE then
              (HandleCallReady + _IOSegment)$^USINT^ := DMSINGLE;
            else
              
              if b_PayloadSupport then
                b_DOIsRunningHandleCallReady.StartRequest := true;
              else
                MasterConnect.ResetDO(p_data_object:=HandleCallReady$^DINT, us_state:=VARAN_DO_SINGLE_RUN, ud_bytes:=1);
              end_if;
              
            end_if;

          1://Read Status ADC
            if HandleReady^ and 2#10 then //Read the Status byte (Bit1 must be zero)
              Counter += 1;
            else
              Counter := 0;
              SSW += 1;
            end_if;
            
            if b_VaranAvailable = FALSE then
              (HandleCallReady + _IOSegment)$^USINT^ := DMSINGLE;
            else
              
              if b_PayloadSupport then
                b_DOIsRunningHandleCallReady.StartRequest := true;
              else
                MasterConnect.ResetDO(p_data_object:=HandleCallReady$^DINT, us_state:=VARAN_DO_SINGLE_RUN, ud_bytes:=1);
              end_if;
              
            end_if;

          2://Read Status Value
            if HandleReady^ and 2#01 then  //Read the status Byte (Bit0 must be 1)
              Counter := 0;
              ssw +=1;
              if b_VaranAvailable = FALSE then
                (HandleCallAI + _IOSegment)$^USINT^ := DMSINGLE;
              else
	
                if b_PayloadSupport then
                  b_DOIsRunningHandleCallAI.StartRequest := true;
                  b_DOIsRunningHandleCallAI1.StartRequest := true;
                else
                  MasterConnect.ResetDO(p_data_object:=HandleCallAI$^DINT, us_state:=VARAN_DO_SINGLE_RUN, ud_bytes:=3);
                  MasterConnect.ResetDO(p_data_object:=HandleCallAI1$^DINT, us_state:=VARAN_DO_SINGLE_RUN, ud_bytes:=3);
                end_if;
                
              end_if;
            else
              counter +=1;
              if b_VaranAvailable = FALSE then
                (HandleCallReady + _IOSegment)$^USINT^ := DMSINGLE;
              else
              
                if b_PayloadSupport then
                  b_DOIsRunningHandleCallReady.StartRequest := true;
                else
                  MasterConnect.ResetDO(p_data_object:=HandleCallReady$^DINT, us_state:=VARAN_DO_SINGLE_RUN, ud_bytes:=1);                
                end_if;
                
              end_if;
            end_if;

          3:// Read Value
            HwInValue1 :=(Handle8Bit )^ or (((Handle4Bit )^ and 16#F) shl 8);//Read Value
            ssw := 0;
            CallInputs();

        end_case;
      end_if;    
    end_if;
  
    // Call Singlerun Statemaschines
    if b_PayloadSupport & 
        sd_VaranType = 1 then
  
      SingleRunSM(p_DOhandle      := #(HandleCallStart1$UDINT)
                , p_b_DOIsRunning := #b_DOIsRunningHandleCallStart1);
                
      SingleRunSM(p_DOhandle      := #(HandleCallStart$UDINT)
                , p_b_DOIsRunning := #b_DOIsRunningHandleCallStart);
      
      SingleRunSM(p_DOhandle      := #(HandleCallReady$UDINT)
                , p_b_DOIsRunning := #b_DOIsRunningHandleCallReady);
                
      SingleRunSM(p_DOhandle      := #(HandleCallAI$UDINT)
                , p_b_DOIsRunning := #b_DOIsRunningHandleCallAI);

      SingleRunSM(p_DOhandle      := #(HandleCallAI1$UDINT)
                , p_b_DOIsRunning := #b_DOIsRunningHandleCallAI1);
  
    end_if;
  
  end_if;
		
//============================ Profiler start======================================================
#ifdef  DM_Profiler								
  StopTimeMeasurement(DMTIME_RT);
#endif	
//============================ Profiler end======================================================== 
   
END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::UpDataCY
	VAR_INPUT
		Handle 	: UDINT;
	END_VAR
  VAR
    newInputs   :DINT;
    InputMask   :USINT;
    pInPutSrv   :^DINT;
    Volbits     :UINT;
  END_VAR

//============================ Profiler start======================================================
#ifdef  DM_Profiler								
  StartTimeMeasurement(DMTIME_CY);
#endif	
//============================ Profiler end======================================================== 

  if b_VaranAvailable then
    CallOutput();
  end_if;
  if HandleCallCy = Handle$DINT | b_VaranAvailable then
    if RtCyOutputs = 0 & OutputBits <> OutputBitsOld then
      OutputBitsOld := Outputbits;
      Output_Byte := OutputBits;
      Handle8BitWrite^ := OutputBits xor InvertOut;
    end_if;
      //Update Digital Inputs
    if RtCyInputs = 0 | b_VaranAvailable then
	
      newInputs := Handle8bitRead^ xor InvertIn;//get Data from Controller and Invert it in Case of the Invert bit is set
      InputMask := OldInputsCY xor newInputs$USINT;//old Input xor new Input (to see changes)
      OldInputsCY := newInputs$USINT;
      if InputMask <> 0 then
        Input_Byte := newInputs$UDINT; 
        pInputSrv :=#Input1.Ddata;

        repeat
	
          if inputMask and 1 then       
            pInputSrv^ := newInputs and 1;      
          end_if;
	
          inputMask := inputMask shr 1;   
          newInputs := newInputs shr 1; 
          pInputSrv += sizeof(SvrCh);     
  
        until inputMask = 0 end_repeat; 
          
      end_if; 
    end_if;
    
      //Update VoltageOKBits
    if b_VaranAvailable = FALSE  | ScanMode <> DmCy then
      VolBits := HandleReadVok^;
      
      if VolBits and 1 then
        VoltageOkV1 := 1;
      else
        VoltageOkV1 := 0;
      end_if;
      if Volbits and 2#10 then
        VoltageOkV2 := 1;
      else
        VoltageOkV2 := 0;
      end_if;
    end_if;
  end_if;
  
  if Handle = HandleCallAI$UDINT | b_VaranAvailable = TRUE then
  // Update Analog Inputs IM
    if AnalogMode = FALSE & b_VaranAvailable = FALSE then
      if UpdateType = 1 then
        if counter > 5 then
          counter := 0;
          SSW := 0;
        end_if;
        
        case SSW of
          0:  
            Counter := 0;
            (HandleSetStart +(AIChannel xor 1))^ := 16#FF;
            SSW += 1;
            return;
          1:
            if HandleReady^ and 2#10 then
              Counter += 1;
            else

              Counter := 0;
              (HandleSetStart +(AIChannel xor 1))^ := 16#FF;
              SSW += 1;
              return;
            end_if;
          2:
            if HandleReady^ and 2#01 then
              HwInValue1 :=(Handle8Bit)^ or (((Handle4Bit)^ and 16#F) shl 8)  ;
  
              SSW := 0;
              AIChannel := AIChannel xor 1;
              CallInputs();
              return;
            else
              Counter +=1;
            end_if;
  
        end_case;

      end_if;

    elsif AnalogMode = TRUE then  // FAST MODE
  
  
      (HandleSetStart)^:= 16#FF;
  
      while HandleReady^ and 2#10 <> 1 do
        (HandleSetStart)^:= 16#FF;
      end_while;
  
//       Wait for Ready Bits   
      while HandleReady^ and 2#01 = 0 do   end_while;
  
      HwInValue2 := (Handle8Bit )^ or (((Handle4Bit )^ and 16#F) shl 8);//Read Value
  
  
  
      (HandleSetStart+1)^:= 16#FF;
      while HandleReady^ and 2#10 <> 1  do
        (HandleSetStart+1)^:= 16#FF;
      end_while;
  
      // Wait for Ready Bits   
      while HandleReady^ and 2#01 <> 1 do   end_while;
      
      HwInValue1 := (Handle8Bit )^ or (((Handle4Bit )^ and 16#F) shl 8);//Read Value     
      
      CallInputs();
      return;
    end_if;
    // No Intelligent Master or Varan
    if UpdateType = 0 | b_VaranAvailable = TRUE then    
      // Active Mover 
      if sd_VaranType = 2  then
      
        //Channel 0
        HwInValue1 := (HandleReady )^ or (((HandleReady1 )^ and 16#F) shl 8);//Read Value       
        AIChannel := 0;
        CallInputs();
        
        // Channel 1 
        HwInValue1 := (Handle8Bit)^ or (((Handle4Bit)^ and 16#F) shl 8);
        AIChannel := 1;
        CallInputs();
      elsif sd_VaranType = 1 | UpdateType =0 then
        // No Mover
        if counter > 5 then
          ssw := 0;
          counter := 0;
        end_if;
        case SSW of
          0:// Select Channel
            if AIChannel = 1 then
              if b_VaranAvailable = FALSE then
                (HandleCallStart1 + _IOSegment)$^USINT^ := DMSINGLE; 
                AIChannel := 0;
              else
                
                if b_PayloadSupport then
                  b_DOIsRunningHandleCallStart1.StartRequest := true;
                else
                  MasterConnect.ResetDO(p_data_object:=HandleCallStart1$^DINT, us_state:=VARAN_DO_SINGLE_RUN, ud_bytes:=1);
                end_if;
                
                AIChannel := 0;
              end_if;
            elsif AIChannel =0 then
              if b_VaranAvailable = FALSE then
                (HandleCallStart + _IOSegment)$^USINT^ := DMSINGLE; 
                AIChannel := 1;
              else
              
                if b_PayloadSupport then
                  b_DOIsRunningHandleCallStart.StartRequest := true;
                else
                  MasterConnect.ResetDO(p_data_object:=HandleCallStart$^DINT, us_state:=VARAN_DO_SINGLE_RUN, ud_bytes:=1);
                end_if;
                
                AIChannel := 1;
              end_if; 
            end_if;
            Counter := 0;
            SSW += 1;
            if b_VaranAvailable = FALSE then
              (HandleCallReady + _IOSegment)$^USINT^ := DMSINGLE;
            else
              
              if b_PayloadSupport then
                b_DOIsRunningHandleCallReady.StartRequest := true;
              else
                MasterConnect.ResetDO(p_data_object:=HandleCallReady$^DINT, us_state:=VARAN_DO_SINGLE_RUN, ud_bytes:=1);
              end_if;
              
            end_if;
          
          1://Read Status ADC
            if HandleReady^ and 2#10 then //Read the Status byte (Bit1 must be zero)
              Counter += 1;
            else
              Counter := 0;
              SSW += 1;
            end_if;
            
            if b_VaranAvailable = FALSE then
              (HandleCallReady + _IOSegment)$^USINT^ := DMSINGLE;
            else
            
              if b_PayloadSupport then
                b_DOIsRunningHandleCallReady.StartRequest := true;
              else
                MasterConnect.ResetDO(p_data_object:=HandleCallReady$^DINT, us_state:=VARAN_DO_SINGLE_RUN, ud_bytes:=1);
              end_if;
              
            end_if;

          2://Read Status Value
            if HandleReady^ and 1 then  //Read the status Byte (Bit0 must be 1)
              Counter := 0;
              ssw +=1;
              if b_VaranAvailable = FALSE then
                (HandleCallAI + _IOSegment)$^USINT^ := DMSINGLE;
              else
              
                if b_PayloadSupport then
                  b_DOIsRunningHandleCallAI.StartRequest := true;
                  b_DOIsRunningHandleCallAI1.StartRequest := true;
                else
                  MasterConnect.ResetDO(p_data_object:=HandleCallAI$^DINT, us_state:=VARAN_DO_SINGLE_RUN, ud_bytes:=3);
                  MasterConnect.ResetDO(p_data_object:=HandleCallAI1$^DINT, us_state:=VARAN_DO_SINGLE_RUN, ud_bytes:=3);                
                end_if;

              end_if;
            else
              counter +=1;
              if b_VaranAvailable = FALSE then
                (HandleCallReady + _IOSegment)$^USINT^ := DMSINGLE;
              else
                if b_PayloadSupport then
                  b_DOIsRunningHandleCallReady.StartRequest := true;
                else
                  MasterConnect.ResetDO(p_data_object:=HandleCallReady$^DINT, us_state:=VARAN_DO_SINGLE_RUN, ud_bytes:=1);
                end_if;
	
              end_if;
            end_if;

          3:// Read Value
            HwInValue1 :=(Handle8Bit )^ or (((Handle4Bit )^ and 16#F) shl 8);//Read Value
            ssw := 0;
            CallInputs();
        end_case;
      end_if;
    end_if;
	
        // Call Singlerun Statemaschines
    if b_PayloadSupport & 
        sd_VaranType = 1 then
    
      SingleRunSM(p_DOhandle      := #(HandleCallStart1$UDINT)
                , p_b_DOIsRunning := #b_DOIsRunningHandleCallStart1);
                
      SingleRunSM(p_DOhandle      := #(HandleCallStart$UDINT)
                , p_b_DOIsRunning := #b_DOIsRunningHandleCallStart);
      
      SingleRunSM(p_DOhandle      := #(HandleCallReady$UDINT)
                , p_b_DOIsRunning := #b_DOIsRunningHandleCallReady);
                
      SingleRunSM(p_DOhandle      := #(HandleCallAI$UDINT)
                , p_b_DOIsRunning := #b_DOIsRunningHandleCallAI);

      SingleRunSM(p_DOhandle      := #(HandleCallAI1$UDINT)
                , p_b_DOIsRunning := #b_DOIsRunningHandleCallAI1);  

    end_if;
  
  end_if;
		
  //============================ Profiler start======================================================
#ifdef  DM_Profiler								
  StopTimeMeasurement(DMTIME_CY);
#endif	
//============================ Profiler end======================================================== 
END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::UpdateRtPostScan
	VAR_INPUT
		handle 	: UDINT;
	END_VAR

//============================ Profiler start======================================================
#ifdef  DM_Profiler								
  StartTimeMeasurement(DMTIME_RTPOSTSCAN);
#endif	
//============================ Profiler end======================================================== 
  
  if State.uiIO_Flags = FALSE then
    if HandleCallAO = Handle$DINT | b_VaranAvailable then
      // Update AO
      CallOutput();
    end_if;
    if HandleCall = Handle$DINT | b_VaranAvailable then
      // Update DO
      if RtCyOutputs <> 0 & OutputBits <> OutputBitsOld then
        OutputBitsOld := Outputbits;
        Output_Byte := OutputBits;
        (Handle8BitWrite)^ := OutputBits xor InvertOut;
      end_if;
    end_if;
  end_if;

//============================ Profiler start======================================================
#ifdef  DM_Profiler								
  StopTimeMeasurement(DMTIME_RTPOSTSCAN);
#endif	
//============================ Profiler end======================================================== 
END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::CheckVariante
	VAR_OUTPUT
		ok 	: BOOL;
	END_VAR
  
  ok := true;
  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::GetEEState
	VAR_OUTPUT
		State 	: DINT;
	END_VAR

	State := firstscan = 0;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::CallOutput

  UpdateAOs();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::CallInputs

  UpdateAIs();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::UpdateAIs

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::UpdateAOs

END_FUNCTION

#ifdef HWK_SHOW_PRAGMA_MESSAGES   
#pragma message(" FucHer am 14.08.2013 18:30 Parameter in Registern muss entfernt werden ?")
#endif

FUNCTION VIRTUAL GLOBAL CIO0xx::Output1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Output1 := OutputBits.1 := 1;
  else
    result := Output1 := OutputBits.1 := 0;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::Output2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Output2 := OutputBits.2 := true;
  else
    result := Output2 := OutputBits.2 := false;
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::Output3::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Output3 := OutputBits.3 := true;
  else
    result := Output3 := OutputBits.3 := false;
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::Output4::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Output4 := OutputBits.4 := true;
  else
    result := Output4 := OutputBits.4 := false;
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::Output5::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Output5 := OutputBits.5 := true;
  else
    result := Output5 := OutputBits.5 := false;
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::Output6::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Output6 := OutputBits.6 := true;
  else
    result := Output6 := OutputBits.6 := false;
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::Output7::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Output7 := OutputBits.7 := true;
  else
    result := Output7 := OutputBits.7 := false;
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::Output8::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Output8 := OutputBits.8 := true;
  else
    result := Output8 := OutputBits.8 := false;
  end_if;  

END_FUNCTION

#ifdef HWK_SHOW_PRAGMA_MESSAGES   
#pragma message(" FucHer am 14.08.2013 18:30 Parameter in Registern muss entfernt werden ?")
#endif

FUNCTION VIRTUAL GLOBAL CIO0xx::Output_Byte::Write
	VAR_INPUT
		input (EAX) 	: HDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: HDINT;
	END_VAR

  result := Output_Byte := input := input and 16#FF;
  
  OutputBits := to_usint(input);
  Output1 := (input and 2#1)$DINT;
  Output2 := (input and 2#10)$DINT shr 1;
  Output3 := (input and 2#100)$DINT shr 2;
  Output4 := (input and 2#1000)$DINT shr 3;
  Output5 := (input and 2#10000)$DINT shr 4;
  Output6 := (input and 2#100000)$DINT shr 5;
  Output7 := (input and 2#1000000)$DINT shr 6;
  Output8 := (input and 2#10000000)$DINT shr 7;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIO0xx::ReCallFactory

END_FUNCTION


FUNCTION CIO0xx::AddPayloadDOstoVaranMover
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  
  //DO anlegen
  sd_retval := AddWrPayloadDO( ud_dol_type     := ScanMode$UDINT
                            , p_ud_handle     := ( #HandleCall )$^UDINT
                            , ud_offset_write := Myplace
                            , ud_length_write := 1
                            , p_ud_data_write := ( #Handle8BitWrite )$^UDINT
                            , ud_type         := 1 
                            );
  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  //DO anlegen
  sd_retval := AddRdPayloadDO(ud_dol_type     := ScanMode$UDINT
                            , p_ud_handle     := ( #HandleCall )$^UDINT
                            , ud_offset_read  := Myplace + 1
                            , ud_length_read  := 1
                            , p_ud_data_read  := ( #Handle8BitRead )$^UDINT
                            , ud_type         := 1
                            );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  //DO anlegen
  sd_retval := AddRdPayloadDO(ud_dol_type     := ScanMode$UDINT
                            , p_ud_handle     := ( #HandleCall )$^UDINT
                            , ud_offset_read  := Myplace + 3
                            , ud_length_read  := 1
                            , p_ud_data_read  := ( #HandleReadVok )$^UDINT
                            , ud_type         := 1
                            );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  if ( CounterMode1and2 ) then
  
    //DO anlegen
    sd_retval := AddRdPayloadDO(ud_dol_type     := ScanMode$UDINT
                              , p_ud_handle     := ( #HandleCall )$^UDINT
                              , ud_offset_read  := Myplace + 8
                              , ud_length_read  := 2
                              , p_ud_data_read  := ( #HandleCounter1 )$^UDINT
                              , ud_type         := 1
                              );
                             
    //look for an error
    if ( sd_retval <> 0 ) then
      return;
    end_if;

    if ( CounterMode1and2 = 1 ) then
      //DO anlegen
      sd_retval := AddRdPayloadDO(ud_dol_type     := ScanMode$UDINT
                                , p_ud_handle     := ( #HandleCall )$^UDINT
                                , ud_offset_read  := Myplace + 10
                                , ud_length_read  := 2
                                , p_ud_data_read  := ( #HandleCounter2 )$^UDINT
                                , ud_type         := 1
                                );

      //look for an error
      if ( sd_retval <> 0 ) then
        return;
      end_if;
    end_if;
  end_if;			

  //DO anlegen
  sd_retval := AddWrPayloadDO(ud_dol_type     := ScanMode$UDINT
                            , p_ud_handle     := ( #HandleCallStart )$^UDINT
                            , ud_offset_write := Myplace + 16#10
                            , ud_length_write := 1
                            , p_ud_data_write := ( #HandleSetStart )$^UDINT
                            , ud_type         := 1
                            );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  ( HandleSetStart$^USINT )^ := 16#FF;

  //DO anlegen
  MasterConnect.AddWait	( RTCY 		:= ScanMode
              , Time_uSec	:= 15
              );

  //DO anlegen  
  sd_retval := AddRdPayloadDO(ud_dol_type     := ScanMode$UDINT
                            , p_ud_handle     := ( #HandleCallAI )$^UDINT
                            , ud_offset_read  := Myplace + 16#10
                            , ud_length_read  := 1
                            , p_ud_data_read  := ( #Handle8Bit )$^UDINT
                            , ud_type         := 1
                            );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  //DO anlegen
  sd_retval := AddRdPayloadDO(ud_dol_type     := ScanMode$UDINT
                            , p_ud_handle     := ( #HandleCallAI )$^UDINT
                            , ud_offset_read  := Myplace + 16#12
                            , ud_length_read  := 1
                            , p_ud_data_read  := ( #Handle4Bit )$^UDINT
                            , ud_type         := 1
                            );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  //DO anlegen
  sd_retval := AddWrPayloadDO(ud_dol_type     := ScanMode$UDINT
                            , p_ud_handle     := ( #HandleCallStart1 )$^UDINT
                            , ud_offset_write := Myplace + 16#11
                            , ud_length_write := 1
                            , p_ud_data_write := ( #HandleSetStart1 )$^UDINT
                            , ud_type         := 1
                            );
                             
  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  ( HandleSetStart1$^USINT )^ := 16#FF;

  //DO anlegen
  MasterConnect.AddWait	( RTCY 		:= ScanMode
              , Time_uSec	:= 15
              );

  //DO anlegen
  sd_retval := AddRdPayloadDO(ud_dol_type     := ScanMode$UDINT
                            , p_ud_handle     := ( #HandleCallReady )$^UDINT
                            , ud_offset_read  := Myplace + 16#10
                            , ud_length_read  := 1
                            , p_ud_data_read  := ( #HandleReady )$^UDINT
                            , ud_type         := 1
                            );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  //DO anlegen
  sd_retval := AddRdPayloadDO(ud_dol_type     := ScanMode$UDINT
                            , p_ud_handle     := ( #HandleCallReady )$^UDINT
                            , ud_offset_read  := Myplace + 16#12
                            , ud_length_read  := 1
                            , p_ud_data_read  := ( #HandleReady1 )$^UDINT
                            , ud_type         := 1
                            );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  //DO anlegen
  sd_retval := AddWrPayloadDO(ud_dol_type     :=  ScanMode$UDINT
                            , p_ud_handle     := ( #LastCall )$^UDINT
                            , ud_offset_write := Myplace + 16#14
                            , ud_length_write := 2
                            , p_ud_data_write := ( #HandleAO )$^UDINT
                            , ud_type         := 1
                            );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

END_FUNCTION


FUNCTION CIO0xx::AddDOstoVaranMover
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  
  //DO anlegen
  sd_retval := MasterConnect.AddWrDO( ud_dol_type := ScanMode$UDINT
                                    , p_ud_handle := ( #HandleCall )$^UDINT
                                    , ud_address  := Myplace
                                    , ud_length   := 1
                                    , p_ud_data   := ( #Handle8BitWrite )$^UDINT
                                    , ud_type     := 1
                                    );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  //DO anlegen
  sd_retval := MasterConnect.AddRdDO( ud_dol_type := ScanMode$UDINT
                                    , p_ud_handle := ( #HandleCall )$^UDINT
                                    , ud_address  := Myplace + 1
                                    , ud_length   := 1
                                    , p_ud_data   := ( #Handle8BitRead )$^UDINT
                                    , ud_type     := 1
                                    );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  //DO anlegen
  sd_retval := MasterConnect.AddRdDO( ud_dol_type := ScanMode$UDINT
                                    , p_ud_handle := ( #HandleCall )$^UDINT
                                    , ud_address  := Myplace + 3
                                    , ud_length   := 1
                                    , p_ud_data   := ( #HandleReadVok )$^UDINT
                                    , ud_type     := 1
                                    );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  if ( CounterMode1and2 ) then
  
    //DO anlegen
    sd_retval := MasterConnect.AddRdDO( ud_dol_type := ScanMode$UDINT
                                      , p_ud_handle := ( #HandleCall )$^UDINT
                                      , ud_address  := Myplace + 8
                                      , ud_length   := 2
                                      , p_ud_data   := ( #HandleCounter1 )$^UDINT
                                      , ud_type     := 1
                                      );

    //look for an error
    if ( sd_retval <> 0 ) then
      return;
    end_if;

    if ( CounterMode1and2 = 1 ) then
      //DO anlegen
      sd_retval := MasterConnect.AddRdDO( ud_dol_type := ScanMode$UDINT
                                        , p_ud_handle := ( #HandleCall )$^UDINT
                                        , ud_address  := Myplace + 10
                                        , ud_length   := 2
                                        , p_ud_data   := ( #HandleCounter2 )$^UDINT
                                        , ud_type     := 1
                                        );

      //look for an error
      if ( sd_retval <> 0 ) then
        return;
      end_if;
    end_if;
  end_if;			

  //DO anlegen
  sd_retval := MasterConnect.AddWrDO	( ud_dol_type := ScanMode$UDINT
                                      , p_ud_handle := ( #HandleCallStart )$^UDINT
                                      , ud_address  := myplace + 16#10
                                      , ud_length   := 1
                                      , p_ud_data   := ( #HandleSetStart )$^UDINT
                                      , ud_type     := 1
                                      );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  ( HandleSetStart$^USINT )^ := 16#FF;

  //DO anlegen
  MasterConnect.AddWait	( RTCY 		:= ScanMode
              , Time_uSec	:= 15
              );

  //DO anlegen
  sd_retval := MasterConnect.AddRdDO	( ud_dol_type := ScanMode$UDINT
                                      , p_ud_handle := ( #HandleCallAI )$^UDINT
                                      , ud_address  := myplace + 16#10
                                      , ud_length   := 1
                                      , p_ud_data   := ( #Handle8Bit )$^UDINT
                                      , ud_type     := 1
                                      );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  //DO anlegen
  sd_retval := MasterConnect.AddRdDO	( ud_dol_type := ScanMode$UDINT
                                      , p_ud_handle := ( #HandleCallAI )$^UDINT
                                      , ud_address  := myplace + 16#12
                                      , ud_length   := 1
                                      , p_ud_data   := ( #Handle4Bit )$^UDINT
                                      , ud_type     := 1
                                      );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  //DO anlegen
  sd_retval := MasterConnect.AddWrDO	( ud_dol_type := ScanMode$UDINT
                                      , p_ud_handle := ( #HandleCallStart1 )$^UDINT
                                      , ud_address  := myplace + 16#11
                                      , ud_length   := 1
                                      , p_ud_data   := ( #HandleSetStart1 )$^UDINT
                                      , ud_type     := 1
                                      );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  ( HandleSetStart1$^USINT )^ := 16#FF;

  //DO anlegen
  MasterConnect.AddWait	( RTCY 		:= ScanMode
              , Time_uSec	:= 15
              );

  //DO anlegen
  sd_retval := MasterConnect.AddRdDO	( ud_dol_type := ScanMode$UDINT
                                      , p_ud_handle := ( #HandleCallReady )$^UDINT
                                      , ud_address  := myplace + 16#10
                                      , ud_length   := 1
                                      , p_ud_data   := ( #HandleReady )$^UDINT
                                      , ud_type     := 1
                                      );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  //DO anlegen
  sd_retval := MasterConnect.AddRdDO	( ud_dol_type := ScanMode$UDINT
                                      , p_ud_handle := ( #HandleCallReady )$^UDINT
                                      , ud_address  := myplace + 16#12
                                      , ud_length   := 1
                                      , p_ud_data   := ( #HandleReady1 )$^UDINT
                                      , ud_type     := 1
                                      );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;


  //DO anlegen
  sd_retval := MasterConnect.AddWrDO	( ud_dol_type := ScanMode$UDINT
                                      , p_ud_handle := ( #LastCall )$^UDINT
                                      , ud_address  := myplace + 16#14
                                      , ud_length   := 2
                                      , p_ud_data   := ( #HandleAO )$^UDINT
                                      , ud_type     := 1
                                      );

  //look for an error
  if ( sd_retval <> 0 ) then
    return;
  end_if;

  
END_FUNCTION
