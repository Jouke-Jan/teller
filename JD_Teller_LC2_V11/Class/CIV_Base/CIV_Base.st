//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "CIV_Base"
	Revision           = "2.61"
	GUID               = "{83CA454E-6ACF-4502-A0E7-AA2704FC256A}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server
			Name           = "Control"
			Initialize     = "false"
			Visualized     = "true"
			WriteProtected = "true">
		</Server>
		<Client Name="To_StdLib" Required="false" Internal="false"/>
		<Client Name="VaranIn" Required="true" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\lsl_st_varantocdias.h" Include="false"/>
			<File Path=".\Class\VaranManager_Base\VaranManager_Base.h" Include="false"/>
			<File Path=".\lsl_st_varan.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="renste"/>
		<Dokumentation Revision="2.61" Date="05.05.2014" Author="LanSte" Company="Sigmatek" Description="Minimized the interface request via CILGET by useing private pointers to reduce time in init."/>
		<Dokumentation Revision="2.60" Date="05.12.2013" Author="LanSte" Company="Sigmatek" Description="Added Payload Support&#13;&#10;Added support to pass on NewInst commands to the Varanmanager"/>
		<Dokumentation Revision="2.50" Date="18.07.2013" Author="ZoePat&#13;&#10;ZoePat" Company="Sigmatek" Description="Added function GetModuleInfo() to get the pointer of a hwclass by place.&#13;&#10;Added possibility to move data on CDIAS behind DataMover."/>
		<Dokumentation Revision="2.40" Date="06.03.2013" Author="RamAnd" Company="Sigmatek" Description="If connected CDIAS modules are required but not available, the user now gets informed via UserAction client."/>
		<Dokumentation Revision="2.30" Date="05.11.2012" Author="RamAnd" Company="Sigmatek" Description="Corrected FlexHub Plug&apos;n&apos;Play functionality for modules with CDIAS Interface"/>
		<Dokumentation Revision="2.19" Date="19.07.2012" Author="ObeChr" Company="Sigmatek" Description="Reduction of PCI Accesses in Methode GetRetryTimeout()"/>
		<Dokumentation Revision="2.18" Date="19.01.2012" Author="ZoePat" Company="Sigmatek" Description="Corrected handling of RequiredError (In some cases it could have happened, that an error has been generated even if the module has been connected)"/>
		<Dokumentation Revision="2.17" Date="30.11.2011" Author="RamAnd" Company="Sigmatek" Description="If the CIV is transparent, some methods didn&apos;t work properly."/>
		<Dokumentation Revision="2.16" Date="27.06.2011" Author="RamAnd" Company="Sigmatek" Description="Support of sorting VARAN commands by priority added (needed for communication between safety-modules)."/>
		<Dokumentation Revision="2.15" Date="07.09.2011" Author="RamAnd" Company="Sigmatek" Description="Prevented crash, if a connected CDIAS module has a wrong placenumber (not between 0 and 7)"/>
		<Dokumentation Revision="2.14" Date="05.01.2011" Author="BleErn" Company="Sigmatek" Description="Added Client Transparent that allows to disable a VARAN-HW-Class"/>
		<Dokumentation Revision="2.13" Date="10.12.2010" Author="RamAnd" Company="Sigmatek" Description="Corrected RetryCounter handling and removed it for the internal move command."/>
		<Dokumentation Revision="2.12" Date="17.11.2010" Author="WocPet" Company="Sigmatek" Description="Initialisation has been adapted for CDIAS modules, which can now cause a required error."/>
		<Dokumentation Revision="2.11" Date="15.10.2010" Author="RamAnd" Company="Sigmatek" Description="Added method AddMovDO for the move command in the VM."/>
		<Dokumentation Revision="2.10" Date="24.08.2010" Author="BleErn" Company="Sigmatek" Description="a misused global pointer let the system crash"/>
		<Dokumentation Revision="2.9" Date="22.07.2010" Author="WocPet" Company="Sigmatek" Description="Functionality for required error handling added"/>
		<Dokumentation Revision="2.8" Date="08.02.2010" Author="BleErn" Company="Sigmatek" Description="New virtual method UpdateRtPostScan&#13;&#10;Constructor crashed on CCL722"/>
		<Dokumentation Revision="2.7" Date="02.09.2009" Author="RamAnd" Company="Sigmatek" Description="Added functions for safety and hardwaretree."/>
		<Dokumentation Revision="2.6" Date="05.08.2009" Author="ObeChr" Company="Sigmatek" Description="Set State in methods for direct access (Wr8Bit, Wr16Bit) if something fails&#13;&#10;Required was ignored by setting StatusBits, now using SetRunState in VaranBase"/>
		<Dokumentation Revision="2.5" Date="20.04.2009" Author="ObeChr" Company="Sigmatek" Description="add CIV_INIT in ResetDO. Starting a application with a CIO behind a CIV without connecting them, caused a failure"/>
		<Dokumentation Revision="2.4" Date="27.03.2009" Author="wocpet" Company="Sigmatek" Description="intialized check by retrytimeout, cause invalid pointer is possible"/>
		<Dokumentation Revision="2.3" Date="04.09.2008" Author="U.L." Company="Sigmatek" Description="remove function CIV_Init in ResetDO&#13;&#10;- correct methode CIV_Init cause of plug and play - errors"/>
	</RevDoku>
	<Network Name="CIV_Base">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{E115AF7E-0326-4100-9985-8D4C157DEE8A}"
				Class      = "DiasMaster"
				Position   = "(270,150)"
				Visualized = "true"
				RealTime   = "1 ms">
				<Channels>
					<Server Name="Control"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Control" Destination="_base.Control" Vertices="(742,210),(570,240),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using DiasMaster

CIV_Base : CLASS
: DiasMaster
	TYPE
#pragma pack(push, 1)
	  t_OneCDIASAccess : STRUCT
	    us_CallNumber : USINT;
	    us_Handle : USINT;
	    us_RtCy : USINT;
	    p_HandleDO : ^LSL_VARANFRAME;
	    p_This : DINT;
	    b_DOIsRunning : t_SingleRunState;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_CDIAS : STRUCT
	    us_HandleCounter : USINT;
	    us_LastMode : USINT;
	    ui_CDIASCounter : UINT;
	    ui_MaxCDIAS : UINT;
	    p_CDIASAccesses : ^t_OneCDIASAccess;
	  END_STRUCT;
#pragma pack(pop)
	  t_CDiasAccesses10 : ARRAY [0..9] OF t_OneCDIASAccess;
	  t_CDIASCallback : STRUCT
	    ud_CallBackFunction : UDINT;
	    ud_Thisp : UDINT;
	    ud_Flags : BDINT
	    [
	    ];
	    ud_Reserved : UDINT;
	  END_STRUCT;
#pragma pack(push, 1)
	  t_CDIASPrioTask : STRUCT
	    us_Priority : USINT;
	    us_Place : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_VARANFrame : STRUCT
	    pHandle : ^LSL_VARANFRAME;
	    us_OldRetryCounter : USINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_HandleArray : ARRAY [0..7] OF t_VARANFrame;
	  t_HandleDO : STRUCT
	    ui_Number : UINT;
	    ui_MaxNumber : UINT;
	    p_Handles : ^t_HandleArray;
	  END_STRUCT;
	END_TYPE
  //Servers:
  //Clients:
	VaranIn 	: CltChCmd_Varan_Base;
	To_StdLib 	: CltChCmd__StdLib;
  //Variables:
		ud_VaranManagerNr 	: UDINT;
		ud_DeviceAddress 	: UDINT;
		ud_HandleModule 	: UDINT;
		pVaran 	: ^LSL_VARAN;
		pMultiVaran 	: ^LSL_MULTI_VARAN;
		pVaranToCDIAS 	: ^LSL_VARANTOCDIAS;
		p_NodeInfo 	: ^LSL_VARANNODEINFO;
		p_NodeString 	: ^USINT;
		b_Initialized 	: BOOL;
		sd_Required 	: DINT;
		a_CdiasCallBacks : ARRAY [0..7] OF t_CDIASCallback;

		s_CDIAS 	: t_CDIAS;
		p_CdiasClassRt 	: pHwBaseCDIAS;
		p_CdiasClassCy 	: pHwBaseCDIAS;
		p_Accesses 	: ^t_CDiasAccesses10;
		s_HandleDOs 	: t_HandleDO;
		a_TasksRT : ARRAY [0..7] OF t_CDIASPrioTask;

		us_cntPrioTasksRT 	: USINT;
		a_TasksCY : ARRAY [0..7] OF t_CDIASPrioTask;

		us_cntPrioTasksCY 	: USINT;
		us_initcounter 	: USINT;
		b_HWRtPostScan 	: BOOL;
		a_TasksRTPostScan : ARRAY [0..7] OF t_CDIASPrioTask;

		us_cntPrioTasksRTPostScan 	: USINT;
		ud_ResponseTimeMax 	: UDINT;
		s_ModuleInfo : ARRAY [0..7] OF t_s_ModulInfo;

		b_PayloadSupport 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ***************************************************************&#13;&#10;   This Function is Called by PostScan from DiasMasterPostScan&#13;&#10; ***************************************************************&#13;&#10;" Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to activate single calls&#13;&#10;=================================================================================================&#13;&#10;" Name="RtWork"/>
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION CIV_Base
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION AWL VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get Pll time of master&#13;&#10;=================================================================================================&#13;&#10;" Name="GetPllTime"/>
	FUNCTION VIRTUAL GLOBAL GetPllTime
		VAR_OUTPUT
			PllTime 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a 8Bit write access&#13;&#10;=================================================================================================&#13;&#10;" Name="AddWr8Bit"/>
	FUNCTION VIRTUAL GLOBAL AddWr8Bit
		VAR_INPUT
			adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			data 	: USINT;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a 16Bit write access&#13;&#10;=================================================================================================&#13;&#10;" Name="AddWr16Bit"/>
	FUNCTION VIRTUAL GLOBAL AddWr16Bit
		VAR_INPUT
			Adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			data 	: UINT;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a 16Bit read access&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRd16Bit"/>
	FUNCTION VIRTUAL GLOBAL AddRd16Bit
		VAR_INPUT
			Adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function read id out of eeprom&#13;&#10;=================================================================================================&#13;&#10;[&lt;Kennund]id of cdias module&#13;&#10;" Name="GetKennung"/>
	FUNCTION VIRTUAL GLOBAL GetKennung
		VAR_INPUT
			Place 	: UDINT;			//! <Variable Comment="place of cdias module" Name="GetKennung.Place"/>
		END_VAR
		VAR_OUTPUT
			Kennung 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to install a varan task&#13;&#10;=================================================================================================&#13;&#10;" Name="AddCall2Main"/>
	FUNCTION VIRTUAL GLOBAL AddCall2Main
		VAR_INPUT
			Mode 	: UINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to make a 16 Bit read access (direct access)&#13;&#10;=================================================================================================&#13;&#10;" Name="Rd16Bit"/>
	FUNCTION VIRTUAL GLOBAL Rd16Bit
		VAR_INPUT
			Adress 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Data 	: DINT;
		END_VAR;
				//! <Function Comment="==================================================================================================&#13;&#10;==================================================================================================&#13;&#10;== || ||           || ||           ==&#13;&#10;==  \\|| ||// Old DiasMaster functions    \\|| ||//          ==&#13;&#10;== \\  //           \\  //           ==&#13;&#10;==   \/             \/           ==&#13;&#10;==================================================================================================&#13;&#10;==================================================================================================&#13;&#10;[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to make a 8 Bit read access (direct access)&#13;&#10;=================================================================================================&#13;&#10;" Name="Rd8Bit"/>
	FUNCTION VIRTUAL GLOBAL Rd8Bit
		VAR_INPUT
			Adress 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Data 	: DINT;			//! <Variable Comment="readed data" Name="Rd8Bit.Data"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to make a 8 Bit write access (direct access)&#13;&#10;=================================================================================================&#13;&#10;" Name="Wr8Bit"/>
	FUNCTION VIRTUAL GLOBAL Wr8Bit
		VAR_INPUT
			Adress 	: UDINT;
			Data 	: USINT;			//! <Variable Comment="data which should be written" Name="Wr8Bit.Data"/>
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to make a 16 Bit write access (direct access)&#13;&#10;=================================================================================================&#13;&#10;" Name="Wr16Bit"/>
	FUNCTION VIRTUAL GLOBAL Wr16Bit
		VAR_INPUT
			Adress 	: UDINT;
			Data 	: UINT;
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a 8Bit read access&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRd8Bit"/>
	FUNCTION VIRTUAL GLOBAL AddRd8Bit
		VAR_INPUT
			Adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get EEprom state&#13;&#10;=================================================================================================&#13;&#10;" Name="GetEEState"/>
	FUNCTION VIRTUAL GLOBAL GetEEState
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get whole EEprom data&#13;&#10;=================================================================================================&#13;&#10;" Name="ReadEEData"/>
	FUNCTION VIRTUAL GLOBAL ReadEEData
		VAR_INPUT
			Adress 	: UDINT;			//! <Variable Comment="adress of access" Name="ReadEEData.Adress"/>
			pData 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function that CDIAS - class knows that we are a CIV&#13;&#10;=================================================================================================&#13;&#10;" Name="GetConnection"/>
	FUNCTION VIRTUAL GLOBAL GetConnection
		VAR_OUTPUT
			CType 	: DINT;			//! <Variable Comment=" connection type (0=DiasMaster,1=CIC/CIV)" Name="GetConnection.CType"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function get CDIAS EEProm data over VARAN bus&#13;&#10;=================================================================================================&#13;&#10;read one Byte from C-DIAS bus on Board&#13;&#10;" Name="I2CReadOneByte"/>
	FUNCTION VIRTUAL GLOBAL I2CReadOneByte
		VAR_INPUT
			AdressCDIAS 	: UINT;
			pData 	: ^USINT;			//! <Variable Comment="pointer to data" Name="I2CReadOneByte.pData"/>
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddCall2List
		VAR_INPUT
			Mode 	: UINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function that CDIAS - class knows that we are a VaranMaster&#13;&#10;=================================================================================================&#13;&#10;" Name="GetMasterType"/>
	FUNCTION VIRTUAL GLOBAL GetMasterType
		VAR_OUTPUT
			MasterType 	: UDINT;			//! <Variable Comment=" connection type (1=normal Master,2=intelligent Master/VaranMaster)" Name="GetMasterType.MasterType"/>
		END_VAR;
				//! <Function Comment="[#DEUTSCH]&#13;&#10;" Name="AddCDiasIRQ"/>
	FUNCTION VIRTUAL GLOBAL AddCDiasIRQ
		VAR_INPUT
			irqnr 	: USINT;			//! <Variable Comment="0..IRQ I/O (IRQ PIN C3) | 1..IRQ Comunication (GP2 PIN A10)" Name="AddCDiasIRQ.irqnr"/>
			ActionPtr 	: pVoid;
			thisp 	: pVoid;
		END_VAR
		VAR_OUTPUT
			ok 	: USINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function call function of VaranMaster to add a read data object to varan master and install a varan task&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRdDO"/>
	FUNCTION VIRTUAL GLOBAL AddRdDO
		VAR_INPUT
			ud_dol_type 	: UDINT;			//! <Variable Comment=" type of DOL list( Realtime = 3, cyclic = 4 )" Name="AddRdDO.ud_dol_type"/>
			p_ud_handle 	: ^UDINT;			//! <Variable Comment=" pointer to variable to set right handle" Name="AddRdDO.p_ud_handle"/>
			ud_address 	: UDINT;			//! <Variable Comment="address of do" Name="AddRdDO.ud_address"/>
			ud_length 	: UDINT;			//! <Variable Comment="length of data should read" Name="AddRdDO.ud_length"/>
			p_ud_data 	: ^UDINT;			//! <Variable Comment="variable to get pointer to readed data" Name="AddRdDO.p_ud_data"/>
			ud_type 	: UDINT;			//! <Variable Comment="0=control area, 1=memory area" Name="AddRdDO.ud_type"/>
			p_ud_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddRdDO.p_ud_DataAddr"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;			//! <Variable Comment=" 0=OK, negative=error (look lsl_st_varan.h)" Name="AddRdDO.sd_retval"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function call function of VaranMaster to add a write data object to varan master and install a varan task&#13;&#10;=================================================================================================&#13;&#10;" Name="AddWrDO"/>
	FUNCTION VIRTUAL GLOBAL AddWrDO
		VAR_INPUT
			ud_dol_type 	: UDINT;
			p_ud_handle 	: ^UDINT;
			ud_address 	: UDINT;
			ud_length 	: UDINT;
			p_ud_data 	: ^UDINT;
			ud_type 	: UDINT;
			p_ud_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddWrDO.p_ud_DataAddr"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function call function of VaranMaster to add a read/write data object to varan master and install a varan task&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRdWrDO"/>
	FUNCTION VIRTUAL GLOBAL AddRdWrDO
		VAR_INPUT
			ud_dol_type 	: UDINT;
			p_ud_handle 	: ^UDINT;
			ud_address_read 	: UDINT;			//! <Variable Comment="read address of do" Name="AddRdWrDO.ud_address_read"/>
			ud_length_read 	: UDINT;			//! <Variable Comment=" Length of read data object" Name="AddRdWrDO.ud_length_read"/>
			p_ud_data_read 	: ^UDINT;			//! <Variable Comment=" pointer to variable to get pointer to data" Name="AddRdWrDO.p_ud_data_read"/>
			ud_address_write 	: UDINT;			//! <Variable Comment="write address of do" Name="AddRdWrDO.ud_address_write"/>
			ud_length_write 	: UDINT;			//! <Variable Comment=" Length of write data object" Name="AddRdWrDO.ud_length_write"/>
			p_ud_data_write 	: ^UDINT;			//! <Variable Comment=" pointer to variable to get pointer to data" Name="AddRdWrDO.p_ud_data_write"/>
			ud_type 	: UDINT;
			p_ud_DataAddr_read 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the read data is given back" Name="AddRdWrDO.p_ud_DataAddr_read"/>
			p_ud_DataAddr_write 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the write data is given back" Name="AddRdWrDO.p_ud_DataAddr_write"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION AWL VIRTUAL GLOBAL AddMovDO
		VAR_INPUT
			ud_dol_type 	: UDINT;
			p_ud_handle 	: ^UDINT;
			p_ud_MovSettings 	: ^UDINT;
			ud_type 	: UDINT;			//! <Variable Comment="access type is always memory, but we may want to have some priority for this access" Name="AddMovDO.ud_type"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to read a direct access data object&#13;&#10;=================================================================================================&#13;&#10;" Name="RdDO"/>
	FUNCTION VIRTUAL GLOBAL RdDO
		VAR_INPUT
			ud_address 	: UDINT;
			ud_length 	: UDINT;
			p_ud_data 	: pVoid;
			ud_type 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to write a direct access data object&#13;&#10;=================================================================================================&#13;&#10;" Name="WrDO"/>
	FUNCTION VIRTUAL GLOBAL WrDO
		VAR_INPUT
			ud_address 	: UDINT;
			ud_length 	: UDINT;
			p_ud_data 	: pVoid;
			ud_type 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to install a callback function for hot plug and play&#13;&#10;=================================================================================================&#13;&#10;" Name="SetObjectCallback"/>
	FUNCTION VIRTUAL GLOBAL SetObjectCallback
		VAR_INPUT
			us_place 	: USINT;			//! <Variable Comment="place of cdias module" Name="SetObjectCallback.us_place"/>
			ud_action_ptr 	: UDINT;			//! <Variable Comment="pointer to position info( first byte is length)" Name="SetObjectCallback.ud_action_ptr"/>
			ud_thisp 	: UDINT;			//! <Variable Comment="thispointer of object" Name="SetObjectCallback.ud_thisp"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to install a varan task&#13;&#10;=================================================================================================&#13;&#10;" Name="AddVaranTask"/>
	FUNCTION VIRTUAL GLOBAL AddVaranTask
		VAR_INPUT
			ud_dol_type 	: UDINT;
			p_this 	: ^void;			//! <Variable Comment=" Thispointer of connected varan class" Name="AddVaranTask.p_this"/>
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to reset a data object&#13;&#10;=================================================================================================&#13;&#10;" Name="ResetDO"/>
	FUNCTION VIRTUAL GLOBAL ResetDO
		VAR_INPUT
			p_data_object 	: ^DINT;			//! <Variable Comment="pointer to varan data object header" Name="ResetDO.p_data_object"/>
			us_state 	: USINT;			//! <Variable Comment="state of data object" Name="ResetDO.us_state"/>
			ud_bytes 	: UDINT;			//! <Variable Comment="number of bytes" Name="ResetDO.ud_bytes"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to find out if varan is available&#13;&#10;=================================================================================================&#13;&#10;" Name="IsVaranAvailable"/>
	FUNCTION VIRTUAL GLOBAL IsVaranAvailable
		VAR_OUTPUT
			sd_varan 	: DINT;			//! <Variable Comment="0=varan not available, 1=varan available" Name="IsVaranAvailable.sd_varan"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="SetNewDOAddressRd"/>
	FUNCTION VIRTUAL GLOBAL SetNewDOAddressRd
		VAR_INPUT
			p_data 	: ^DINT;			//! <Variable Comment="pointer to varan write data" Name="SetNewDOAddressRd.p_data"/>
			ud_address 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="SetNewDOAddressWr"/>
	FUNCTION VIRTUAL GLOBAL SetNewDOAddressWr
		VAR_INPUT
			p_data 	: ^DINT;
			ud_address 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="SetNewDOAddressRdWr"/>
	FUNCTION VIRTUAL GLOBAL SetNewDOAddressRdWr
		VAR_INPUT
			p_data 	: ^DINT;
			ud_address_read 	: UDINT;
			ud_address_write 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to write one Byte in CDIAS - EEprom over varan bus&#13;&#10;=================================================================================================&#13;&#10;" Name="I2CWriteOneByte"/>
	FUNCTION VIRTUAL GLOBAL I2CWriteOneByte
		VAR_INPUT
			AdressCDIAS 	: UINT;
			pData 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to write a CDIAS - EEprom over varan bus (Offset 16#B0 - 16#FF)&#13;&#10;=================================================================================================&#13;&#10;" Name="WriteEEData"/>
	FUNCTION VIRTUAL GLOBAL WriteEEData
		VAR_INPUT
			Adress 	: UDINT;
			pData 	: ^USINT;
			ui_length 	: UINT;
			ui_offset 	: UINT;
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get pointer to node string&#13;&#10;=================================================================================================&#13;&#10;" Name="GetPointer2NodeString"/>
	FUNCTION VIRTUAL GLOBAL GetPointer2NodeString
		VAR_OUTPUT
			p_us_node 	: ^USINT;			//! <Variable Comment="pointer to node string" Name="GetPointer2NodeString.p_us_node"/>
		END_VAR;
				//! <Function Comment="returns the object path" Name="GetObjectPath"/>
	FUNCTION VIRTUAL GLOBAL GetObjectPath
		VAR_INPUT
			p_us_ObjectPath 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="function to save this-pointer of object in dependence of object path" Name="SetObjectThisp"/>
	FUNCTION VIRTUAL GLOBAL SetObjectThisp
		VAR_INPUT
			p_us_ObjectPath 	: ^USINT;
			ud_thisp 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="change the order of update-calls" Name="SetTaskPriority"/>
	FUNCTION VIRTUAL GLOBAL SetTaskPriority
		VAR_INPUT
			us_place 	: USINT;
			us_priority 	: USINT;
			ud_dol_type 	: UDINT;
		END_VAR;
				//! <Function Comment="function to get this-pointer of an object with a specific object path" Name="GetObjectThisp"/>
	FUNCTION VIRTUAL GLOBAL GetObjectThisp
		VAR_INPUT
			p_us_ObjectPath 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			ud_Thisp 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddRequiredObject
		VAR_INPUT
			thisp 	: ^void;
		END_VAR;
	
	FUNCTION VIRTUAL CheckforRequiredError;
	
	FUNCTION VIRTUAL GLOBAL GetModuleInfo
		VAR_INPUT
			us_place 	: USINT;
		END_VAR
		VAR_OUTPUT
			p_ModuleInfo 	: ^t_s_ModulInfo;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to Initialize CIV component&#13;&#10;=================================================================================================&#13;&#10;" Name="CIV_Init"/>
	FUNCTION GLOBAL CIV_Init
		VAR_OUTPUT
			sd_cdias_state 	: DINT;			//! <Variable Comment="state of CDIAS class" Name="CIV_Init.sd_cdias_state"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function is called if a callback happens&#13;&#10;=================================================================================================&#13;&#10;" Name="Cdias_CallBack"/>
	FUNCTION GLOBAL Cdias_CallBack
		VAR_INPUT
			ud_reason 	: UDINT;			//! <Variable Comment="reason of callback" Name="Cdias_CallBack.ud_reason"/>
			ud_data 	: UDINT;			//! <Variable Comment="data of callback" Name="Cdias_CallBack.ud_data"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to set memory error an set master off&#13;&#10;=================================================================================================&#13;&#10;" Name="Error_ToManyCDIASAccesses"/>
	FUNCTION Error_ToManyCDIASAccesses;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to read a CDIAS - EEprom over varan bus&#13;&#10;=================================================================================================&#13;&#10;" Name="ReadCDIASEEPromCIV"/>
	FUNCTION ReadCDIASEEPromCIV
		VAR_INPUT
			us_cdias_place 	: USINT;			//! <Variable Comment="Place of cdias module" Name="ReadCDIASEEPromCIV.us_cdias_place"/>
			us_offset 	: USINT;			//! <Variable Comment="offset in eeprom" Name="ReadCDIASEEPromCIV.us_offset"/>
			ui_length 	: UINT;			//! <Variable Comment="length of data" Name="ReadCDIASEEPromCIV.ui_length"/>
			p_us_data 	: ^USINT;			//! <Variable Comment="pointer to data" Name="ReadCDIASEEPromCIV.p_us_data"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get retry timeout for cdias access&#13;&#10;=================================================================================================&#13;&#10;" Name="GetRetryTimeout"/>
	FUNCTION GetRetryTimeout
		VAR_INPUT
			ud_bytes 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ud_timeout 	: UDINT;			//! <Variable Comment="timeout for data object" Name="GetRetryTimeout.ud_timeout"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to write a CDIAS - EEprom over varan bus&#13;&#10;=================================================================================================&#13;&#10;" Name="WriteCDIASEEPromCIV"/>
	FUNCTION WriteCDIASEEPromCIV
		VAR_INPUT
			us_cdias_place 	: USINT;
			us_offset 	: USINT;
			ui_length 	: UINT;
			p_us_data 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetRetryCounter
		VAR_OUTPUT
			ud_retries 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL CIV_ReInit;
	
	FUNCTION VIRTUAL AddPayloadDO
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL AddMovePayloadDO
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Control::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _StdLib
#pragma usingLtd Varan_Base


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB CIV_Base::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_CIV_BASE
2$UINT, 61$UINT, (SIZEOF(::CIV_Base))$UINT, 
0$UINT, 2$UINT, 0$UINT, 
TO_UDINT(2756859380), "CIV_Base", //Class
TO_UDINT(2647887450), "DiasMaster", 2$UINT, 30$UINT, //Baseclass
//Servers:
//Clients:
(::CIV_Base.VaranIn.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2999796184), "VaranIn", TO_UDINT(862125188), "Varan_Base", 2$UINT, 2$UINT, 
(::CIV_Base.To_StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2139173287), "To_StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_CIV_Base 65

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_CIV_Base] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION CIV_Base::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= DiasMaster::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= DiasMaster::Control.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, DiasMaster::Control.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_CIV_Base;
	vmt.CmdTable.NewInstr		:= #Control::NewInst();
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #GetPllTime();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddWr8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #AddWr16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #AddRd16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #GetKennung();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #AddCall2Main();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Rd16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #Rd8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #Wr8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #Wr16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #AddRd8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #GetEEState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #ReadEEData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #GetConnection();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #I2CReadOneByte();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #AddCall2List();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #GetMasterType();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #AddCDiasIRQ();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #AddRdDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[37]		:= #AddWrDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[38]		:= #AddRdWrDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[39]		:= #AddMovDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #RdDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[41]		:= #WrDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[42]		:= #SetObjectCallback();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[43]		:= #AddVaranTask();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[44]		:= #ResetDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #IsVaranAvailable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[46]		:= #SetNewDOAddressRd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[47]		:= #SetNewDOAddressWr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[48]		:= #SetNewDOAddressRdWr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[49]		:= #I2CWriteOneByte();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[50]		:= #WriteEEData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[51]		:= #GetPointer2NodeString();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[53]		:= #GetObjectPath();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[54]		:= #SetObjectThisp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[55]		:= #SetTaskPriority();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[56]		:= #GetObjectThisp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[59]		:= #AddRequiredObject();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[60]		:= #CheckforRequiredError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[62]		:= #GetModuleInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[63]		:= #AddPayloadDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[64]		:= #AddMovePayloadDO();

#pragma warning (default : 74)
	DiasMaster::Control.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DiasMaster::Control.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= CIV_Base();

END_FUNCTION

#pragma usingLtd HwBaseCDIAS

//{{LSL_IMPLEMENTATION
#pragma using HwBaseCDIAS
#pragma usingLtd Hub_Base

(************************************************************************************
*
*	Baseclass for CIV
*	Created : Sigmatek	/	SR	/	March-April 2006
*	Changes : 
*
*
*     FOR NEWER CHANGES SEE REVISION DOCUMENTATION IN CLASS PROPERTIES
*
*
*   2.2 => 2.3  / 04.09.2008
*     - [DB 936]: - remove function CIV_Init in ResetDO
*                 - correct methode CIV_Init cause of plug and play - errors
*   2.1 => 2.2  / 28.07.2008
*     - [DB 920]: optimize call function for CDIAS - classes (no mult in AWL code)
*   2.0 => 2.1  / 09.06.2008
*     - [DB 867]: new initcounter for civ_init to control that it's first called in init
*		1.9 => 2.0  / 26.02.2008
*			- [DB 792]: remove setting state in function GetKennung
*		1.8 => 1.9	/	04.12.2007
*			- [DB 713]: add Funciton prototype for CIV to get node string
*		1.7 => 1.8	/	31.10.2007
*			- [DB 705]: replace AWL - code with ST - code
*		1.6 => 1.7	/	16.10.2007
*			- [DB 707]: remove offset restriction in function WriteEEOffset
*		1.5 => 1.6	/	11.07.2007
*			- [DB 620]:	Insert function to update module retry counters
*		1.4 => 1.5	/	16.03.2007
*			- [DB 421]: add Plug & Play function to CDIAS - classes
*			- [DB 528]: insert functions to write to cdias eeprom
*		1.3 => 1.4	/	14.12.2006
*			- [DB 441]: if no module is on rack and read ID you get always 2 -> now similar to Dias (value = 255)
*			- set error in CIV class if an eeprom error (except read ID) occures
*		1.2 => 1.3	/	13.12.2006
*			- [DB 439]: mask out not valid bytes in Function Rd8Bit and Rd16Bit
*		1.1 => 1.2	/	04.12.2006
*			- [DB 420]: check return values of VaranManager in functions AddxxxxBit for CDIAS - Modules
*		1.0 => 1.1	/ 	28.11.2006
*			first library version
*		0.2 => 1.0	/	10.10.2006
*			initial version
*		0.1 => 0.2	/	13.06.2006
*			second testversion 
*		0.0	=> 0.1	/	10.04.2006
*			first testversion for fair in Hannover
*
************************************************************************************)

VAR_PRIVATE

  // Private pointers to interface to avoid multiple OS_CILGet calls.
  pMultiVaranFetch    : ^LSL_MULTI_VARAN;   
    
END_VAR

FUNCTION F_LoadFunction1
VAR_INPUT
  ud_reason	: UDINT;
END_VAR;
#define LoadFunction1( a )  	p_Function $ F_LoadFunction1( a )

//[#ENGLISH]
//=================================================================================================
//Constructor of class
//=================================================================================================
FUNCTION  CIV_Base::CIV_Base
VAR_OUTPUT
  ret_code		: CONFSTATES;
END_VAR

  ret_code	:= C_OK;

  //mark class as not initialized
  Control := _NotInitialized;
  
  pMultiVaranFetch := nil;

  //get pointer to cdias eeprom functions
  if ( OS_CILGet( INTERFACE_VARANTOCDIAS, #pVaranToCDIAS ) ) then
    pVaranToCDIAS 	:= NIL;
    Control			:= _NoCDIASInterface;
    //VaranIn.SetState( sd_error := _NoCDIASInterface );
    TRACE( "CIV: No Varan CDIAS Interface, a newer OS is required!" );
  end_if;

  //get memory for handles of DO
  s_HandleDOs.p_Handles$^void := To_StdLib.Malloc( size := 8 * sizeof( t_VARANFrame ) );
  s_HandleDOs.ui_MaxNumber := 8;
  
  //look for an error
  if ( s_HandleDOs.p_Handles = NIL ) then
    Control := _MemoryFault;
    return;
  end_if;

  //get memory for CDIAS accesses
  s_CDIAS.ui_MaxCDIAS := CIV_CDIAS_HANDLES;
  s_CDIAS.p_CDIASAccesses$^void 	:= To_StdLib.Malloc( size := s_CDIAS.ui_MaxCDIAS * sizeof( t_OneCDIASAccess ) );

  //look for an error
  if ( s_CDIAS.p_CDIASAccesses = NIL ) then
    Control := _MemoryFault;
    return;
  end_if;

END_FUNCTION //  CIV_Base::CIV_Base
//[#ENGLISH]
//=================================================================================================
//Function to Initialize CIV component
//=================================================================================================
//[<sd_cdias_state]state of CDIAS class
FUNCTION GLOBAL CIV_Base::CIV_Init
  VAR_OUTPUT
  sd_cdias_state	: DINT;
  END_VAR
  VAR
      // For NewInst command 
    _Para 	            : CmdStruct;  
    _Result 	          : Results;    
    paraGetModuleHandel : t_VM_CMD_GetModuleHandle; 
  END_VAR


  //is civ alreaady initialized
  if ( b_Initialized = FALSE ) then
//BLEERN001 start
  b_HWRtPostScan := 1;
//BLEERN001 end          
    //mark class as valid
    Control := _ClassOk;
    
    // LanSte 11.04.2013 15:35    
    // Check if Payload is supported by the VM
    _Para.uiCmd := VM_CMD_IS_PAYLOAD_SUPPORTED;
    _Result.aData[0]$BOOL := 0;   // Set to 0 in case the NewInst Method is not Implemented
    VaranIn.VaranIn.NewInst(#_Para, #_Result);
    b_PayloadSupport := _Result.aData[0]$BOOL;

    //get varan manager number and varan pointer
    ud_VaranManagerNr := ( VaranIn.VaranIn.GetManagerNumber( p_varan := #pVaran ) )$UDINT;

    //look for an error
    if ( pVaran = NIL ) &
       ( b_PayloadSupport = false) then   // pVaran is alwaly nil with payload support 
      Control 	:= _NoVaranInterface;
      return;
    end_if;
    
    //get required setting
    sd_Required := VaranIn.Required.read();

    //get right varan position
    p_NodeString := VaranIn.GetPointer2NodeString();
    
    //look if component is ok
    if ( p_NodeString = NIL ) then
      Control 	:= _RootError;
      return;
    end_if;
    
     // Get Module Handle if supported
    if b_PayloadSupport then
    
      if pMultiVaranFetch = nil then
    
        // Get the pointer for the Payload inteface
        if ( OS_CILGet( INTERFACE_MULTIVARANMANAGER, #pMultiVaranFetch ) <> SYS_ERR_NONE) then
          // Should be impossible b_PayloadSupport is only set when this interface was already called succesfully
          TRACE( "CIV_Base::CIV_Init No Multi_Varan Interface found" );        
          return;
        end_if;
        
      end_if;
      
      pMultiVaran := pMultiVaranFetch;
    
      _Para.uiCmd := VM_CMD_GET_MODULE_HANDLE;
      
      paraGetModuleHandel.p_us_position_info := p_NodeString;
      paraGetModuleHandel.p_ud_module_handle := #ud_HandleModule;
      
      _Para.aPara[0]  := (#paraGetModuleHandel)$DINT;
      
      VaranIn.NewInst(#_Para, #_Result);
      if _result.aData[0]$DINT <> VM_CMD_OK then
        Control := _RootError;
        return;
      end_if;

    end_if;
    
    //not in first init because it can be possible that we are not initialized
    if ( Initcounter = 0 ) then
      return;
    end_if;
    
    //get varan node info
    p_NodeInfo := VaranIn.GetPointer2NodeInfo();	

    //look for right Node pointer
    if ( p_NodeInfo = NIL ) then
      Control := _NoHardware;
      return;
    end_if;

    //get right device id (look if device is there)
    ud_DeviceAddress := VaranIn.GetDeviceAddress( );
                            
    //look if component is ok
    if ( ud_DeviceAddress = 0 ) then
      Control 	:= _NoHardware;
      return;
    end_if;

    To_StdLib.MemSet( dest 	:= s_CDIAS.p_CDIASAccesses
                    , value := 0
                    , size 	:= s_CDIAS.ui_MaxCDIAS * sizeof( t_OneCDIASAccess ) 
                    );	
   

    //init is finished and executed
    b_Initialized 	:= TRUE;
    
  end_if;

  sd_cdias_state := Control;
  
END_FUNCTION //VIRTUAL GLOBAL CIV_Base::CIV_Init
//[#ENGLISH]
//=================================================================================================
//Function that CDIAS - class knows that we are a CIV
//=================================================================================================
//[<CType] connection type (0=DiasMaster,1=CIC/CIV)
FUNCTION VIRTUAL GLOBAL CIV_Base::GetConnection
VAR_OUTPUT
  CType		: DINT;
END_VAR

  CType := 1;		//2;		//connect to a civ

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::GetConnection
//[#ENGLISH]
//=================================================================================================
//Function that CDIAS - class knows that we are a VaranMaster
//=================================================================================================
//[<MasterType] connection type (1=normal Master,2=intelligent Master/VaranMaster)
FUNCTION VIRTUAL GLOBAL CIV_Base::GetMasterType
VAR_OUTPUT
  MasterType		: UDINT;
END_VAR

  MasterType := 2;		//3;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::GetMasterType
//[#ENGLISH]
//=================================================================================================
//Function call function of VaranMaster to add a read data object to varan master and install a varan task
//=================================================================================================
//[>ud_dol_type] pointer to variable to set right handle
//[>p_ud_handle]pointer to variable to set right handle
//[>ud_address] Address of data object
//[>ud_length] Length of data object
//[>p_ud_data] pointer to variable to get pointer to data
//[>ud_type]0=control area, 1=memory area
//[<sd_retval] 0=OK, negative=error (look lsl_st_varan.h)
FUNCTION VIRTUAL GLOBAL CIV_Base::AddRdDO
  VAR_INPUT
    ud_dol_type 	: UDINT;
    p_ud_handle 	: ^UDINT;
    ud_address 	: UDINT;
    ud_length 	: UDINT;
    p_ud_data 	: ^UDINT;
    ud_type 	: UDINT;
    p_ud_DataAddr 	: ^HDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval 	: DINT;
  END_VAR
VAR
  pTemp         : ^t_VARANFrame;	
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    sd_retval := _NotInitialized;
    return;
  END_IF;
#endif

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
//	if ( Control = 0 ) then

#ifdef VM_DEBUG_PAYLOAD
     // Payload not supported
    if b_PayloadSupport then
    // This method is not supporded with Payload support
      TRACE( "CIV_Base Method not supported with Varan Payload support" );
      ((0)$^USINT)^ := 0; 
  end_if;
#endif     

    sd_retval := VaranIn.VaranIn.AddRdDO( p_us_position_info:= p_NodeString			//Node string
                                        , ud_dol_type 		  := ud_dol_type
                                        , p_ud_handle 		  := p_ud_handle
                                        , ud_address		    := ud_DeviceAddress + ud_address
                                        , ud_length			    := ud_length
                                        , p_ud_data			    := p_ud_data
                                        , ud_type			      := ud_type
                                        );

    //save handle in structure
    if ( s_HandleDOs.ui_Number = s_HandleDOs.ui_MaxNumber ) then
      s_HandleDOs.p_Handles$^void := To_StdLib.ReAlloc	( mptr		:= s_HandleDOs.p_Handles
                                                        , newsize	:= ( s_HandleDOs.ui_MaxNumber + 8 ) * sizeof( t_VARANFrame ) 
                                                        );

      //look for an error
      if ( s_HandleDOs.p_Handles = NIL ) then
        Control := _MemoryFault;
        VaranIn.SetState( sd_error := _MemoryFault );
        return;
      end_if;
      s_HandleDOs.ui_MaxNumber += 8;
    end_if;

    pTemp := s_HandleDOs.p_Handles + s_HandleDOs.ui_Number * sizeof( t_VARANFrame );
    pTemp^.pHandle := (p_ud_handle^)$^LSL_VARANFRAME;
    pTemp^.us_OldRetryCounter := 0;
    s_HandleDOs.ui_Number += 1;


//	else
//		sd_retval := Control;	
//	end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::AddRdDO
//[#ENGLISH]
//=================================================================================================
//Function call function of VaranMaster to add a write data object to varan master and install a varan task
//=================================================================================================
//[>ud_dol_type] pointer to variable to set right handle
//[>p_ud_handle]pointer to variable to set right handle
//[>ud_address] Address of data object
//[>ud_length] Length of data object
//[>p_ud_data] pointer to variable to get pointer to data
//[>ud_type]0=control area, 1=memory area
//[<sd_retval] 0=OK, negative=error (look lsl_st_varan.h)
FUNCTION VIRTUAL GLOBAL CIV_Base::AddWrDO
  VAR_INPUT
    ud_dol_type 	: UDINT;
    p_ud_handle 	: ^UDINT;
    ud_address 	: UDINT;
    ud_length 	: UDINT;
    p_ud_data 	: ^UDINT;
    ud_type 	: UDINT;
    p_ud_DataAddr 	: ^HDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval 	: DINT;
  END_VAR
VAR
  pTemp         : ^t_VARANFrame;	
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    sd_retval := _NotInitialized;
    return;
  END_IF;
#endif

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
//	if ( Control = 0 ) then
    
#ifdef VM_DEBUG_PAYLOAD
    // Payload not supported
    if b_PayloadSupport then
    // This method is not supporded with Payload support
      TRACE( "CIV_Base Method not supported with Varan Payload support" );
    ((0)$^USINT)^ := 0; 
  end_if;
#endif    
    
    //add write DO
    sd_retval := VaranIn.VaranIn.AddWrDO( p_us_position_info:= p_NodeString			//Node string
                                        , ud_dol_type		    := ud_dol_type
                                        , p_ud_handle		    := p_ud_handle
                                        , ud_address		    := ud_DeviceAddress + ud_address
                                        , ud_length			    := ud_length
                                        , p_ud_data			    := p_ud_data
                                        , ud_type			      := ud_type
                                        );

    //save handle in structure
    if ( s_HandleDOs.ui_Number = s_HandleDOs.ui_MaxNumber ) then
      s_HandleDOs.p_Handles$^void := To_StdLib.ReAlloc	( mptr		:= s_HandleDOs.p_Handles
                                                        , newsize	:= ( s_HandleDOs.ui_MaxNumber + 8 ) * sizeof( t_VARANFrame ) 
                                                        );

      //look for an error
      if ( s_HandleDOs.p_Handles = NIL ) then
        Control := _MemoryFault;
        VaranIn.SetState( sd_error := _MemoryFault );
        return;
      end_if;
      s_HandleDOs.ui_MaxNumber += 8;
    end_if;

    pTemp := s_HandleDOs.p_Handles + s_HandleDOs.ui_Number * sizeof( t_VARANFrame );
    pTemp^.pHandle := (p_ud_handle^)$^LSL_VARANFRAME;
    pTemp^.us_OldRetryCounter := 0;
    s_HandleDOs.ui_Number += 1;


//	else
//		sd_retval := Control;	
//	end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::AddWrDO
//[#ENGLISH]
//=================================================================================================
//Function call function of VaranMaster to add a read/write data object to varan master and install a varan task
//=================================================================================================
//[>ud_dol_type] type of DOL list( 1=direct access, 2=IRQ, 3=realtime, 4=cyclic )
//[>p_ud_handle] pointer to variable to set right handle
//[>ud_address_read] Address of read data object
//[>ud_length_read] Length of read data object
//[>p_ud_data_read] pointer to variable to get pointer to data
//[>ud_address_write] Address of write data object
//[>ud_length_write] Length of write data object
//[>p_ud_data_write] pointer to variable to get pointer to data
//[>ud_type]0=control area, 1=memory area
//[<sd_retval] 0=OK, negative=error (look lsl_st_varan.h)
FUNCTION VIRTUAL GLOBAL CIV_Base::AddRdWrDO
  VAR_INPUT
    ud_dol_type 	: UDINT;
    p_ud_handle 	: ^UDINT;
    ud_address_read 	: UDINT;
    ud_length_read 	: UDINT;
    p_ud_data_read 	: ^UDINT;
    ud_address_write 	: UDINT;
    ud_length_write 	: UDINT;
    p_ud_data_write 	: ^UDINT;
    ud_type 	: UDINT;
    p_ud_DataAddr_read 	: ^HDINT;
    p_ud_DataAddr_write 	: ^HDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval 	: DINT;
  END_VAR
VAR
  pTemp         : ^t_VARANFrame;	
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    sd_retval := _NotInitialized;
    return;
  END_IF;
#endif

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
//	if ( Control = 0 ) then

#ifdef VM_DEBUG_PAYLOAD
    // Payload not supported
    if b_PayloadSupport then
    // This method is not supporded with Payload support
      TRACE( "CIV_Base Method not supported with Varan Payload support" );
      ((0)$^USINT)^ := 0; 
  end_if;
#endif  
    
    //add a read/write DO
    sd_retval := VaranIn.VaranIn.AddRdWrDO	( p_us_position_info:= p_NodeString	//Node string
                                            , ud_dol_type		    := ud_dol_type
                                            , p_ud_handle		    := p_ud_handle
                                            , ud_address_read	  := ud_DeviceAddress + ud_address_read
                                            , ud_length_read	  := ud_length_read
                                            , p_ud_data_read	  := p_ud_data_read
                                            , ud_address_write	:= ud_DeviceAddress + ud_address_write
                                            , ud_length_write	  := ud_length_write
                                            , p_ud_data_write	  := p_ud_data_write
                                            , ud_type			      := ud_type
                                            );    

    //save handle in structure
    if ( s_HandleDOs.ui_Number = s_HandleDOs.ui_MaxNumber ) then
      s_HandleDOs.p_Handles$^void := To_StdLib.ReAlloc	( mptr		:= s_HandleDOs.p_Handles
                                                        , newsize	:= ( s_HandleDOs.ui_MaxNumber + 8 ) * sizeof( t_VARANFrame ) 
                                                        );

      //look for an error
      if ( s_HandleDOs.p_Handles = NIL ) then
        Control := _MemoryFault;
        VaranIn.SetState( sd_error := _MemoryFault );
        return;
      end_if;
      s_HandleDOs.ui_MaxNumber += 8;
    end_if;

    pTemp := s_HandleDOs.p_Handles + s_HandleDOs.ui_Number * sizeof( t_VARANFrame );
    pTemp^.pHandle := (p_ud_handle^)$^LSL_VARANFRAME;
    pTemp^.us_OldRetryCounter := 0;
    s_HandleDOs.ui_Number += 1;

//	else
//		sd_retval := Control;	
//	end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::AddRdWrDO

//[#ENGLISH]
//=================================================================================================
//Function to write a direct access data object
//=================================================================================================
//[>ud_address]address to write
//[>ud_length]length of data should be written
//[>p_ud_data]pointer to data should be written
//[>ud_type]0=control area, 1=memory area
FUNCTION VIRTUAL GLOBAL CIV_Base::WrDO
VAR_INPUT
  ud_address		: UDINT;
  ud_length		: UDINT;
  p_ud_data		: pVoid;
  ud_type			: UDINT;
END_VAR
VAR_OUTPUT
  sd_retval		: DINT;
END_VAR
VAR
  ud_Command  : UDINT;
END_VAR


#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    sd_retval := _NotInitialized;
    return;
  END_IF;
#endif

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;
  
  //look if class is ok
  if ( Control = 0 ) then
    
    // Payload Support
    if b_PayloadSupport then
      
    if ( ud_type ) then
        ud_Command := VARAN_CMD_MEMORY_WRITE;
      else
        ud_Command := VARAN_CMD_CONTROL_WRITE;
      end_if;
      
      sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                    , udCommand   := ud_Command
                                                    , udOffset    := ud_address
                                                    , udLength    := ud_length
                                                    , pusData     := (p_ud_data)$^USINT
                                                    , pudErrorInfo:= NIL);
    
    else
      if ( ud_type ) then
      //make direct memory access
      sd_retval := VARAN_iWriteMemoryDA ( uiManager     := ud_VaranManagerNr
                                        , uiAddress     := ud_DeviceAddress + ud_address
                                        , uiLen         := ud_length
                                        , uiRetryTimeout:= GetRetryTimeout( ud_bytes := ud_length$UINT )
                                        , pvData        := p_ud_data
                                        , puiError      := NIL
                                        );
    else
      //make direct control access
      sd_retval := VARAN_iWriteControlDA( uiManager     := ud_VaranManagerNr
                                        , uiAddress     := ud_DeviceAddress + ud_address
                                        , uiLen         := ud_length
                                        , uiRetryTimeout:= GetRetryTimeout( ud_bytes := ud_length$UINT )
                                        , pvData        := p_ud_data
                                        , puiError      := NIL
                                        );
      end_if;
    end_if;
    
  else  // if ( Control = 0 ) then
    sd_retval := Control;	
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::WrDO
//[#ENGLISH]
//=================================================================================================
//Function to read a direct access data object
//=================================================================================================
//[>ud_address]address to read
//[>ud_length]length of data should read
//[>p_ud_data]variable to get pointer to readed data
//[>ud_type]0=control area, 1=memory area
FUNCTION VIRTUAL GLOBAL CIV_Base::RdDO
VAR_INPUT
  ud_address		: UDINT;
  ud_length		: UDINT;
  p_ud_data		: pVoid;
  ud_type			: UDINT;
END_VAR
VAR_OUTPUT
  sd_retval		: DINT;
END_VAR
VAR
  ud_Command  : UDINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    sd_retval := _NotInitialized;
    return;
  END_IF;
#endif

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
  if ( Control = 0 ) then
    
    // payload Support
    if b_PayloadSupport then
      if ( ud_type ) then
        ud_Command := VARAN_CMD_MEMORY_READ;
      else
        ud_Command := VARAN_CMD_CONTROL_READ;
      end_if;
      
      sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                    , udCommand   := ud_Command
                                                    , udOffset    := ud_address
                                                    , udLength    := ud_length
                                                    , pusData     := (p_ud_data)$^USINT
                                                    , pudErrorInfo:= NIL);      
    else
    
      if ( ud_type ) then
      //make direct memory access
      sd_retval := VARAN_iReadMemoryDA( uiManager     := ud_VaranManagerNr
                                      , uiAddress     := ud_DeviceAddress + ud_address
                                      , uiLen         := ud_length
                                      , uiRetryTimeout:= GetRetryTimeout( ud_bytes := ud_length$UINT )
                                      , pvData        := p_ud_data
                                      , puiError      := NIL
                                      );
      else
        //make direct control access
        sd_retval := VARAN_iReadControlDA(  uiManager     := ud_VaranManagerNr
                                          , uiAddress     := ud_DeviceAddress + ud_address
                                          , uiLen         := ud_length
                                          , uiRetryTimeout:= GetRetryTimeout( ud_bytes := ud_length$UINT )
                                          , pvData        := p_ud_data
                                          , puiError      := NIL
                                          );
      end_if;
    end_if;
    
  else
    sd_retval := Control;	
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::RdDO
//[#ENGLISH]
//=================================================================================================
//Function get CDIAS EEProm data over VARAN bus
//=================================================================================================
//read one Byte from C-DIAS bus on Board
FUNCTION VIRTUAL GLOBAL CIV_Base::I2CReadOneByte
VAR_INPUT
  AdressCDIAS		: UINT;
  pData			: ^USINT;
END_VAR
VAR_OUTPUT
  result			: DINT;
END_VAR

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
  if ( Control = 0 ) then

    //read one byte of CDIAS - EEPROM
    result := ReadCDIASEEpromCIV( us_cdias_place	:= ( AdressCDIAS shr 8 )$USINT
                  , us_offset			:= AdressCDIAS$USINT
                  , ui_length			:= 1
                  , p_us_data			:= pData
                  );		

    //check for errors
    if ( result <> VARANMANAGER_OK ) then
      pData^	:= 255;
      Control := result;
//			b_EEPromError := TRUE;
      VaranIn.SetState( sd_error := _EEPromError );
    end_if;	

  else
    result	:= Control;
    pData^	:= 255;	
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::I2CReadOneByte
//[#ENGLISH]
//=================================================================================================
//Function to get EEprom state
//=================================================================================================
FUNCTION VIRTUAL GLOBAL CIV_Base::GetEEState
VAR_OUTPUT
  State		: DINT;
END_VAR
  State := 2;
END_FUNCTION //VIRTUAL GLOBAL CIV_Base::GetEEState
//[#ENGLISH]
//=================================================================================================
//Function to get whole EEprom data
//=================================================================================================
//[>Adress]cdias place
//[>pData]pointer to data
FUNCTION VIRTUAL GLOBAL CIV_Base::ReadEEData
VAR_INPUT
  Adress		: UDINT;
  pData		: ^USINT;
END_VAR
VAR_OUTPUT
  retval		: DINT;
END_VAR
VAR
  i			: UINT;
END_VAR
      
  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
  if ( Control = 0 ) then

    //get whole EEPROM data
    retval := ReadCDIASEEpromCIV	( us_cdias_place	:= Adress$USINT
                    , us_offset			:= 0
                    , ui_length			:= 256
                    , p_us_data			:= pData
                    );

    //look for an error
    //check for errors
    if ( retval <> VARANMANAGER_OK ) then
      Control := retval;
//			b_EEPromError := TRUE;
      VaranIn.SetState( sd_error := _EEPromError );

      //to prevent division error
      for i := 0 to 255 do
        ( pData + i )^ := 255;
      end_for;
    end_if;	

  else
    retval := Control;	
  end_if;	

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::ReadEEData
//[#ENGLISH]
//=================================================================================================
//Function to install a callback function for hot plug and play
//=================================================================================================
//[>us_place]place of cdias module
//[>ud_action_ptr]pointer to position info( first byte is length)
//[>ud_thisp]thispointer of object
FUNCTION VIRTUAL GLOBAL CIV_Base::SetObjectCallback
VAR_INPUT
  us_place		: USINT;
  ud_action_ptr	: UDINT;
  ud_thisp		: UDINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    return;
  END_IF;
#endif

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //install callback pointer for cdias modules
  if us_place <= 7 then
    a_CdiasCallBacks[ us_place ].ud_CallbackFunction	:= ud_action_ptr;
    a_CdiasCallBacks[ us_place ].ud_Thisp				:= ud_thisp;  
    
    s_ModuleInfo[us_place].p_This := ud_thisp$pVoid;
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::SetObjectCallback
//[#ENGLISH]
//=================================================================================================
//Function to install a varan task
//=================================================================================================
//[>ud_dol_type] type of DOL list( Realtime = 3, cyclic = 4 )
//[>p_this] Thispointer of connected varan class
FUNCTION VIRTUAL GLOBAL CIV_Base::AddVaranTask
  VAR_INPUT
    ud_dol_type 	: UDINT;
    p_this 	: ^void;
    callOptions 	: USINT;
  END_VAR
VAR
  i		: UINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    return;
  END_IF;
#endif

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;
    
  //search right place
  for i := 0 to 7 do
    
    //look if we have thispointer
    if ( a_CdiasCallBacks[ i ].ud_Thisp = p_this$UDINT ) then
      
      //save flags in array
      if ( ud_dol_type = VARAN_DOL_ISO ) then
        IF callOptions AND CALL_OPTION_RT_PRESCAN THEN
          a_CdiasCallBacks[ i ].ud_Flags.1 := 1;
        END_IF;
        IF callOptions AND CALL_OPTION_RT_POSTSCAN THEN
          a_CdiasCallBacks[ i ].ud_Flags.5 := 1;
        END_IF;
      else
        a_CdiasCallBacks[ i ].ud_Flags.2 := 1;
      end_if;
      i := 8;
    end_if;
  end_for;

  //look if class is ok
//	if ( Control = 0 ) then

(*		//install a varan task
    VaranIn.VaranIn.AddVaranTask( ud_dol_type	:= ud_dol_type
                  , p_this		:= p_this

                  );
//	end_if;
*)
END_FUNCTION //VIRTUAL GLOBAL CIV_Base::AddVaranTask
//[#ENGLISH]
//=================================================================================================
//Function is called if a callback happens
//=================================================================================================
//[>ud_reason]reason of callback
//[>ud_data]data of callback
FUNCTION GLOBAL CIV_Base::Cdias_CallBack
VAR_INPUT
  ud_reason		: UDINT;
  ud_data			: UDINT;
END_VAR
VAR
  i				: DINT;
  p_this			: UDINT;
  p_Function	: pVoid;
END_VAR

  //if a disconnect or fault IRQ we must reinit class with next connect IRQ
  if ( ud_reason <> VARANMANAGER_CB_CONNECT ) then
    b_Initialized := FALSE;
  else
    CIV_Init();
  end_if;
  
  //look if class is ok
  if ( Control = 0 ) then
    //call cdias callback functions
    for i := 0 to 7 do

      //if we have a callback function
      if ( a_CdiasCallBacks[ i ].ud_CallBackFunction <> NIL ) then

        p_Function$UDINT := a_CDiasCallBacks[ i ].ud_CallBackFunction;
        p_this := this$UDINT;
        this$UDINT := a_CDiasCallBacks[ i ].ud_Thisp;
        LoadFunction1( ud_reason );
        this$UDINT := p_this;
        
      end_if;
    end_for;
  end_if;

END_FUNCTION //GLOBAL CIV_Base::Cdias_CallBack
//[#ENGLISH]
//=================================================================================================
//Function to reset a data object
//=================================================================================================
//[>p_data_object]pointer to varan data object header
//[>us_state]state of data object
//[>ud_bytes]bytes of cdias accesses
FUNCTION VIRTUAL GLOBAL CIV_Base::ResetDO
  VAR_INPUT
  p_data_object	: ^DINT;
  us_state		: USINT;
  ud_bytes		: UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval 	: DINT;
  END_VAR
VAR
  p_help			:^LSL_VARANFRAME;
  s_PropertyValuePair : LSL_PROPERTY_VALUE_PAIR;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN 
    sd_retval := VARANMANAGER_OK;
    return;
  END_IF;
#endif

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
  if ( Control = 0 ) then

    // Start/Stop DO Depending on passesd state
    if b_PayloadSupport then
    
      case us_state of
        
        VARAN_DO_CONT_RUN : // Start the DO and recalcualte the retry timeout ***************************************************************
          sd_retval := VaranIn.EnableDO( ud_DOHandle := (p_data_object)$UDINT );
        
          if sd_retval <> VARANMANAGER_OK then
            return;
          end_if; 
        
        VARAN_DO_NO_RUN : // Stop the DO *****************************************************************************************************
          sd_retval := VaranIn.DisableDO(ud_DOHandle := (p_data_object)$UDINT );
        
          if sd_retval <> VARANMANAGER_OK then
            return;
          end_if;
        
//        VARAN_DO_SINGLE_RUN :  
//          // Not supported in payload
//          // This single run is not directly supported replace with enable/disable          

#ifdef VM_DEBUG_PAYLOAD        
        else
          // Not supported in payload those it even exist? Check in detail why we get this case
          // This single run is not directly supported replace with enable/disable
  
          // This method is not supporded with Payload support
          // Use  HwBaseCDIAS::AddRdPayloadDO       
          TRACE( "CIV_Base  Method not supported with Varan Payload support" );
          ((0)$^USINT)^ := 0;   
#endif  
      
      end_case;
      
      // Calculate and set the retry timeout 
      if ud_bytes then  // Only if bytes where passed
        // Set the retry timeout of the CDIAS DO
        s_PropertyValuePair.udPropertyId    := DO_PROP_RETRY_TIMEOUT;
        s_PropertyValuePair.udPropertyValue := GetRetryTimeout(ud_bytes := ud_bytes);
        
        if s_PropertyValuePair.udPropertyValue = 0 then
          sd_retval := VM_CMD_ERROR_INVALID_TIMEOUT;
          return;
        end_if;
        
        // Set Timeout
        sd_retval := MULTI_VARAN_iSetDoProperties((p_data_object)$UDINT, 1, #s_PropertyValuePair);
        if sd_retval <> VARANMANAGER_OK then    
          return;
        end_if;              

      end_if;

    
    else  // No Payload support
      
      //Reset Data Object with settings
      VaranIn.ResetDataObject	( p_handleDO	:= p_data_object$^LSL_VARANFRAME
                  , us_state		:= us_state
                  , ud_bytes		:= ud_bytes
                  );
      
      //add to timeout tim cdias access time
      p_help := p_data_object$^LSL_VARANFRAME;

      p_help^.uiRetryTimeout += ( ud_bytes * VM_TIMEOUT_ONE_CDIAS );
        
      sd_retval := VARANMANAGER_OK;
    end_if;
    
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::ResetDO
//[#ENGLISH]
//=================================================================================================
//Function to find out if varan is available
//=================================================================================================
//[<sd_varan]0=varan not available, 1=varan available
FUNCTION VIRTUAL GLOBAL CIV_Base::IsVaranAvailable
VAR_OUTPUT
  sd_varan		: DINT;
END_VAR
  
  sd_varan := 1;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::IsVaranAvailable
//==================================================================================================
//==================================================================================================
//==	||	||											||	||									  ==
//==  \\||	||//	Old DiasMaster functions		  \\||	||//								  ==
//==	\\  //											\\  //									  ==
//==	  \/											  \/									  ==
//==================================================================================================
//==================================================================================================

//[#ENGLISH]
//=================================================================================================
//Function to make a 8 Bit read access (direct access)
//=================================================================================================
//[>Adress]Address for read access
//[<Data]readed data
FUNCTION VIRTUAL GLOBAL CIV_Base::Rd8Bit
VAR_INPUT
  Adress		: UDINT;
END_VAR
VAR_OUTPUT
  Data		: DINT;
END_VAR
VAR
  sd_retval	: DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    Data := 16#8000_0000$DINT;
    return;
  END_IF;
#endif

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
  if ( Control = 0 ) then
    
    // Payload Support
    if b_PayloadSupport then
    //make a direct access with one byte
      sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                    , udCommand   := VARAN_CMD_MEMORY_READ
                                                    , udOffset    := Adress
                                                    , udLength    := 1
                                                    , pusData     := (#Data)$^USINT
                                                    , pudErrorInfo:= NIL); 
    else
      //make a direct access with one byte
      sd_retval := VARAN_iReadMemoryDA( uiManager     := ud_VaranManagerNr
                                      , uiAddress     := ud_DeviceAddress + Adress
                                      , uiLen         := 1
                                      , uiRetryTimeout:= GetRetryTimeout( ud_bytes := 1 )
                                      , pvData        := #Data
                                      , puiError      := NIL
                                      );
    end_if;
    
  end_if;

  //only one byte valid
  Data := Data and 16#FF;

  //look for an error
  if ( sd_retval <> VARANMANAGER_OK ) then
    Data$UDINT := 16#8000_0000;
    return;
  end_if;
    
END_FUNCTION //VIRTUAL GLOBAL CIV_Base::Rd8Bit
//[#ENGLISH]
//=================================================================================================
//Function to make a 16 Bit read access (direct access)
//=================================================================================================
//[>Adress]Address for read access
//[<Data]readed data
FUNCTION VIRTUAL GLOBAL CIV_Base::Rd16Bit
VAR_INPUT
  Adress		: UDINT;
END_VAR
VAR_OUTPUT
  Data		: DINT;
END_VAR
VAR
  sd_retval	: DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    Data := 16#8000_0000$DINT;
    return;
  END_IF;
#endif

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
  if ( Control = 0 ) then
    
    // Payload Support
    if b_PayloadSupport then
      //make a direct access with two bytes
      sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                    , udCommand   := VARAN_CMD_MEMORY_READ
                                                    , udOffset    := Adress
                                                    , udLength    := 2
                                                    , pusData     := (#Data)$^USINT
                                                    , pudErrorInfo:= NIL);       
    else
      //make a direct access with two bytes
      sd_retval := VARAN_iReadMemoryDA( uiManager     := ud_VaranManagerNr
                                      , uiAddress     := ud_DeviceAddress + Adress
                                      , uiLen         := 2
                                      , uiRetryTimeout:= GetRetryTimeout( ud_bytes := 2 )
                                      , pvData        := #Data
                                      , puiError      := NIL
                                      );
      end_if;		
    
  end_if;

  //only one word valid
  Data := Data and 16#FFFF;

  //look for an error
  if ( sd_retval <> VARANMANAGER_OK ) then
    Data$UDINT := 16#8000_0000;
    return;
  end_if;
    
END_FUNCTION //VIRTUAL GLOBAL CIV_Base::Rd16Bit
//[#ENGLISH]
//=================================================================================================
//Function to make a 8 Bit write access (direct access)
//=================================================================================================
//[>Adress]Address for read access
//[>Data]data which should be written
FUNCTION VIRTUAL GLOBAL CIV_Base::Wr8Bit
VAR_INPUT
  Adress		: UDINT;
  Data		: USINT;
END_VAR
VAR_OUTPUT
  State		: DINT;
END_VAR
VAR
  sd_retval	: DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    State := 16#8000_0000$DINT;
    return;
  END_IF;
#endif

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
  if ( Control = 0 ) then
    
    // Payload Support
    if b_PayloadSupport then
    //write data with direct access
      sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                    , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                    , udOffset    := Adress
                                                    , udLength    := 1
                                                    , pusData     := (#Data)$^USINT
                                                    , pudErrorInfo:= NIL);       
    else
      //write data with direct access
      sd_retval := VARAN_iWriteMemoryDA(  uiManager     := ud_VaranManagerNr
                                        , uiAddress     := ud_DeviceAddress + Adress
                                        , uiLen         := 1
                                        , uiRetryTimeout:= GetRetryTimeout( ud_bytes := 1 )
                                        , pvData        := #Data
                                        , puiError      := NIL
                                          );    
    end_if;
                      
    //look for an error
    if ( sd_retval <> VARANMANAGER_OK ) then
      State$UDINT := 16#8000_0000;
      return;
    else
      State := sd_retval;
    end_if;
  
  else
    State := Control;  
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::Wr8Bit
//[#ENGLISH]
//=================================================================================================
//Function to make a 16 Bit write access (direct access)
//=================================================================================================
//[>Adress]Address for read access
//[>Data]data which should be written
FUNCTION VIRTUAL GLOBAL CIV_Base::Wr16Bit
VAR_INPUT
  Adress		: UDINT;
  Data		: UINT;
END_VAR
VAR_OUTPUT
  State		: DINT;
END_VAR
VAR
  sd_retval	: DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    State := 16#8000_0000$DINT;
    return;
  END_IF;
#endif

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
  if ( Control = 0 ) then
    
    // Payload Support
    if b_PayloadSupport then
    //write data with direct access
      sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                    , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                    , udOffset    := Adress
                                                    , udLength    := 2
                                                    , pusData     := (#Data)$^USINT
                                                    , pudErrorInfo:= NIL);    
    else
      //write data with direct access
      sd_retval := VARAN_iWriteMemoryDA(  uiManager     := ud_VaranManagerNr
                                        , uiAddress     := ud_DeviceAddress + Adress
                                        , uiLen         := 2
                                        , uiRetryTimeout:= GetRetryTimeout( ud_bytes := 2 )
                                        , pvData        := #Data
                                        , puiError      := NIL
                                        );
    end_if;
    
    //look for an error
    if ( sd_retval <> VARANMANAGER_OK ) then
      State$UDINT := 16#8000_0000;
      return;
    else
      State := sd_retval;
    end_if;
  
  else
    State := Control;
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::Wr16Bit
//[#ENGLISH]
//=================================================================================================
//Function to install a varan task
//=================================================================================================
//[>Mode]mode of call (single,always,stop)
//[>RTCY]cyclic or realtime
//[>thisp]thispointer of object
//[<Handle]Handle to change run status
FUNCTION VIRTUAL GLOBAL CIV_Base::AddCall2Main
  VAR_INPUT
    Mode 	: UINT;
    RTCY 	: DINT;
    thisp 	: ^void;
    callOptions 	: USINT;
  END_VAR
  VAR_OUTPUT
    Handle 	: DINT;
  END_VAR

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if CDIAS list is full
  if ( s_CDIAS.ui_CDIASCounter = s_CDIAS.ui_MaxCDIAS ) then

    Error_ToManyCDIASAccesses();
  end_if;

  //increas CDIAS counter to get right list position
  s_CDIAS.us_HandleCounter += 1;

  //look if we have realtime or cyclic
  if ( RTCY = 0 ) then
    RTCY := VARAN_DOL_ASY;
  else
    RTCY := VARAN_DOL_ISO;
  end_if;

  //get right pointer to handle in CDIAS list and manipulate it to be compatible
  Handle := ( #s_CDIAS.p_CDIASAccesses^.us_Handle + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) - _IOSegment )$DINT;
  
  //store right mode in cdias structure
  s_CDIAS.us_LastMode := Mode$USINT;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::AddCall2Main
//[#ENGLISH]
//=================================================================================================
//Function to add a 8Bit read access
//=================================================================================================
//[>Adress]adress of access
//[>RTCY]cyclic or realtime
//[>thisp]thispointer of object
//[<Handle]pointer to data
FUNCTION VIRTUAL GLOBAL CIV_Base::AddRd8Bit
  VAR_INPUT
    Adress 	: HINT;
    RTCY 	: DINT;
    thisp 	: ^void;
    callOptions 	: USINT;
  END_VAR
  VAR_OUTPUT
    Handle 	: DINT;
  END_VAR
VAR
  us_varan_mode	: USINT;
  sd_retval		: DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    Handle := 0;
    return;
  END_IF;
#endif

  

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;
  
#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    TRACE( "CIV_Base Method not supported with Varan Payload support" );
    ((0)$^USINT)^ := 0; 
  end_if;
#endif  

  //look if class is ok
  if ( Control = 0 ) then

    //look if cdias list is full
    if ( s_CDIAS.ui_CDIASCounter = s_CDIAS.ui_MaxCDIAS ) then

      Error_ToManyCDIASAccesses();
    end_if;

    //look which type we have
    if ( RTCY = 0 ) then
      RTCY := VARAN_DOL_ASY;
    else
      RTCY := 0;
      IF callOptions AND CALL_OPTION_RT_PRESCAN THEN
        RTCY := VARAN_DOL_ISO;
      END_IF;
      
      IF callOptions AND CALL_OPTION_RT_POSTSCAN THEN
        RTCY := RTCY OR CALL_OPTION_RT_POSTSCAN;
      END_IF;
    end_if;

    //add write data object
    sd_retval := VaranIn.VaranIn.AddRdDO( p_us_position_info:= p_NodeString
                                        , ud_dol_type       := RTCY$UDINT
                                        , p_ud_handle       := ( #s_CDIAS.p_CDIASAccesses^.p_HandleDO + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^UDINT
                                        , ud_address        := ud_DeviceAddress + Adress
                                        , ud_length         := 1
                                        , p_ud_data         := ( #Handle )$^UDINT
                                        , ud_type           := VM_MEMORY_ACCESS
                                        );	

    //look for an error
    if ( sd_retval <> VARANMANAGER_OK ) then
      Handle := 0;
      Control := sd_retval;
      return;
    end_if;
    
    //get right varan mode
    if ( s_CDIAS.us_LastMode = 1 ) then			
      us_varan_mode := VaranIn.SetRunStatus(VARAN_DO_CONT_RUN);
    elsif ( s_CDIAS.us_LastMode = 2 ) then			
      us_varan_mode := VaranIn.SetRunStatus(VARAN_DO_SINGLE_RUN);
    else
      us_varan_mode := VaranIn.SetRunStatus(VARAN_DO_NO_RUN);
    end_if;

    //reset data object an set state
    ResetDO	( p_data_object		:= ( ( #s_CDIAS.p_CDIASAccesses^.p_HandleDO + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )^ )$^DINT
        , us_state			:= us_varan_mode
        , ud_bytes			:= 1
        );

    //return right pointer to data
    Handle := ( Handle$UDINT - _IOSegment )$DINT;

    //save right handle counter
    ( ( #s_CDIAS.p_CDIASAccesses^.us_CallNumber + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^USINT )^ := s_CDIAS.us_HandleCounter;
  
    //save right mode of cdias access
    ( ( #s_CDIAS.p_CDIASAccesses^.us_Handle + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^USINT )^ := s_CDIAS.us_LastMode;

    //set right call number to know which access belong to the same call
    ( ( #s_CDIAS.p_CDIASAccesses^.us_RtCy + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^USINT )^ := RTCY$USINT;

    //save thispointer of call
    ( ( #s_CDIAS.p_CDIASAccesses^.p_This + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^DINT )^ := thisp$DINT;

    //increase cdias counter
    s_CDIAS.ui_CDIASCounter += 1;

  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::AddRd8Bit
//[#ENGLISH]
//=================================================================================================
//Function to add a 16Bit read access
//=================================================================================================
//[>Adress]adress of access
//[>RTCY]cyclic or realtime
//[>thisp]thispointer of object
//[<Handle]pointer to data
FUNCTION VIRTUAL GLOBAL CIV_Base::AddRd16Bit
  VAR_INPUT
    Adress 	: HINT;
    RTCY 	: DINT;
    thisp 	: ^void;
    callOptions 	: USINT;
  END_VAR
  VAR_OUTPUT
    Handle 	: DINT;
  END_VAR
VAR
  us_varan_mode	: USINT;
  sd_retval		: DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    Handle := 0;
    return;
  END_IF;
#endif

#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    TRACE( "CIV_Base  Method not supported with Varan Payload support" );
    ((0)$^USINT)^ := 0; 
  end_if;
#endif  

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
  if ( Control = 0 ) then

    //look if cdias list is full
    if ( s_CDIAS.ui_CDIASCounter = s_CDIAS.ui_MaxCDIAS ) then

      Error_ToManyCDIASAccesses();
    end_if;

    //look which typ we have
    if ( RTCY = 0 ) then
      RTCY := VARAN_DOL_ASY;
    else
      RTCY := 0;
      IF callOptions AND CALL_OPTION_RT_PRESCAN THEN
        RTCY := VARAN_DOL_ISO;
      END_IF;
      
      IF callOptions AND CALL_OPTION_RT_POSTSCAN THEN
        RTCY := RTCY OR CALL_OPTION_RT_POSTSCAN;
      END_IF;
    end_if;

    //add read data object
    sd_retval := VaranIn.VaranIn.AddRdDO( p_us_position_info:= p_NodeString
                                        , ud_dol_type       := RTCY$UDINT
                                        , p_ud_handle       := ( #s_CDIAS.p_CDIASAccesses^.p_HandleDO + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^UDINT
                                        , ud_address        := ud_DeviceAddress + Adress
                                        , ud_length         := 2
                                        , p_ud_data         := ( #Handle )$^UDINT
                                        , ud_type           := VM_MEMORY_ACCESS
                                        );	

    //look for an error
    if ( sd_retval <> VARANMANAGER_OK ) then
      Handle := 0;
      Control := sd_retval;
      return;
    end_if;

    //get right varan mode
    if ( s_CDIAS.us_LastMode = 1 ) then			
      us_varan_mode := VaranIn.SetRunStatus(VARAN_DO_CONT_RUN);
    elsif ( s_CDIAS.us_LastMode = 2 ) then			
      us_varan_mode := VaranIn.SetRunStatus(VARAN_DO_SINGLE_RUN);
    else
      us_varan_mode := VaranIn.SetRunStatus(VARAN_DO_NO_RUN);
    end_if;
    
    //reset data object and set right mode (single,continue, stop)
    ResetDO	( p_data_object		:= ( ( #s_CDIAS.p_CDIASAccesses^.p_HandleDO + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )^ )$^DINT
        , us_state			:= us_varan_mode
        , ud_bytes			:= 2
        );

    //return value is pointer to data
    Handle := ( Handle$UDINT - _IOSegment )$DINT;

    //set right call number to know which access belong to the same call
    ( ( #s_CDIAS.p_CDIASAccesses^.us_CallNumber + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^USINT )^ := s_CDIAS.us_HandleCounter;

    //save right mode of cdias access
    ( ( #s_CDIAS.p_CDIASAccesses^.us_Handle + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^USINT )^ := s_CDIAS.us_LastMode;
  
    //set right call number to know which access belong to the same call
    ( ( #s_CDIAS.p_CDIASAccesses^.us_RtCy + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^USINT )^ := RTCY$USINT;

    //save thispointer of call
    ( ( #s_CDIAS.p_CDIASAccesses^.p_This + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^DINT )^ := thisp$DINT;

    //increas cdias counter
    s_CDIAS.ui_CDIASCounter += 1;
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::AddRd16Bit
//[#ENGLISH]
//=================================================================================================
//Function to add a 8Bit write access
//=================================================================================================
//[>Adress]adress of access
//[>RTCY]cyclic or realtime
//[>thisp]thispointer of object
//[>data]data of first access
//[<Handle]pointer to data
FUNCTION VIRTUAL GLOBAL CIV_Base::AddWr8Bit
  VAR_INPUT
    adress 	: HINT;
    RTCY 	: DINT;
    thisp 	: ^void;
    data 	: USINT;
    callOptions 	: USINT;
  END_VAR
  VAR_OUTPUT
    Handle 	: DINT;
  END_VAR
VAR
  us_varan_mode	: USINT;
  sd_retval		: DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    Handle := 0;
    return;
  END_IF;
#endif

#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    TRACE( "CIV_Base  Method not supported with Varan Payload support" );
    ((0)$^USINT)^ := 0; 
  end_if;
#endif  

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
  if ( Control = 0 ) then

    //look if cdias list is full
    if ( s_CDIAS.ui_CDIASCounter = s_CDIAS.ui_MaxCDIAS ) then

      Error_ToManyCDIASAccesses();
    end_if;

    //look which type we have
    if ( RTCY = 0 ) then
      RTCY := VARAN_DOL_ASY;
    else
      RTCY := 0;
      IF callOptions AND CALL_OPTION_RT_PRESCAN THEN
        RTCY := VARAN_DOL_ISO;
      END_IF;
      
      IF callOptions AND CALL_OPTION_RT_POSTSCAN THEN
        RTCY := RTCY OR CALL_OPTION_RT_POSTSCAN;
      END_IF;
    end_if;

    //add read data object
    sd_retval := VaranIn.VaranIn.AddWrDO( p_us_position_info:= p_NodeString
                                        , ud_dol_type       := RTCY$UDINT
                                        , p_ud_handle       := ( #s_CDIAS.p_CDIASAccesses^.p_HandleDO + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^UDINT
                                        , ud_address        := ud_DeviceAddress + Adress
                                        , ud_length         := 1
                                        , p_ud_data         := ( #Handle )$^UDINT
                                        , ud_type           := VM_MEMORY_ACCESS
                                        );	

    //look for an error
    if ( sd_retval <> VARANMANAGER_OK ) then
      Handle := 0;
      Control := sd_retval;
      return;
    end_if;

    //get right varan mode
    if ( s_CDIAS.us_LastMode = 1 ) then			
      us_varan_mode := VaranIn.SetRunStatus(VARAN_DO_CONT_RUN);
    elsif ( s_CDIAS.us_LastMode = 2 ) then			
      us_varan_mode := VaranIn.SetRunStatus(VARAN_DO_SINGLE_RUN);
    else
      us_varan_mode := VaranIn.SetRunStatus(VARAN_DO_NO_RUN);
    end_if;
  
    //reset data object an set state
    ResetDO	( p_data_object		:= ( ( #s_CDIAS.p_CDIASAccesses^.p_HandleDO + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )^ )$^DINT
        , us_state			:= us_varan_mode
        , ud_bytes			:= 1
        );

    //set data for first execution
    ( Handle$^USINT )^ := data;

    //return right pointer to data
    Handle := ( Handle$UDINT - _IOSegment )$DINT;

    //save right handle counter
    ( ( #s_CDIAS.p_CDIASAccesses^.us_CallNumber + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^USINT )^ := s_CDIAS.us_HandleCounter;

    //save right mode of cdias access
    ( ( #s_CDIAS.p_CDIASAccesses^.us_Handle + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^USINT )^ := s_CDIAS.us_LastMode;

    //set right call number to know which access belong to the same call
    ( ( #s_CDIAS.p_CDIASAccesses^.us_RtCy + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^USINT )^ := RTCY$USINT;

    //save thispointer of call
    ( ( #s_CDIAS.p_CDIASAccesses^.p_This + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^DINT )^ := thisp$DINT;

    //increase cdias counter
    s_CDIAS.ui_CDIASCounter += 1;
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::AddWr8Bit
//[#ENGLISH]
//=================================================================================================
//Function to add a 16Bit write access
//=================================================================================================
//[>Adress]adress of access
//[>RTCY]cyclic or realtime
//[>thisp]thispointer of object
//[>data]data of first access
//[<Handle]pointer to data
FUNCTION VIRTUAL GLOBAL CIV_Base::AddWr16Bit
  VAR_INPUT
    Adress 	: HINT;
    RTCY 	: DINT;
    thisp 	: ^void;
    data 	: UINT;
    callOptions 	: USINT;
  END_VAR
  VAR_OUTPUT
    Handle 	: DINT;
  END_VAR
VAR
  us_varan_mode	: USINT;
  sd_retval		: DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    Handle := 0;
    return;
  END_IF;
#endif

#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    TRACE( "CIV_Base Method not supported with Varan Payload support" );
    ((0)$^USINT)^ := 0; 
  end_if;
#endif    

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
  if ( Control = 0 ) then

    //look if cdias list is full
    if ( s_CDIAS.ui_CDIASCounter = s_CDIAS.ui_MaxCDIAS ) then

      Error_ToManyCDIASAccesses();
    end_if;

    //look which type we have
    if ( RTCY = 0 ) then
      RTCY := VARAN_DOL_ASY;
    else
      RTCY := 0;
      IF callOptions AND CALL_OPTION_RT_PRESCAN THEN
        RTCY := VARAN_DOL_ISO;
      END_IF;
      
      IF callOptions AND CALL_OPTION_RT_POSTSCAN THEN
        RTCY := RTCY OR CALL_OPTION_RT_POSTSCAN;
      END_IF;
    end_if;
                      
    //add write data object
    sd_retval := VaranIn.VaranIn.AddWrDO( p_us_position_info:= p_NodeString
                                        , ud_dol_type       := RTCY$UDINT
                                        , p_ud_handle       := ( #s_CDIAS.p_CDIASAccesses^.p_HandleDO + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^UDINT
                                        , ud_address        := ud_DeviceAddress + Adress
                                        , ud_length         := 2
                                        , p_ud_data         := ( #Handle )$^UDINT
                                        , ud_type           := VM_MEMORY_ACCESS
                                        );	
  
    //look for an error
    if ( sd_retval <> VARANMANAGER_OK ) then
      Handle := 0;
      Control := sd_retval;
      return;
    end_if;

    //get right varan mode
    if ( s_CDIAS.us_LastMode = 1 ) then			
      us_varan_mode := VaranIn.SetRunStatus(VARAN_DO_CONT_RUN);
    elsif ( s_CDIAS.us_LastMode = 2 ) then			
      us_varan_mode := VaranIn.SetRunStatus(VARAN_DO_SINGLE_RUN);
    else
      us_varan_mode := VaranIn.SetRunStatus(VARAN_DO_NO_RUN);
    end_if;

    //reset data object an set state
    ResetDO	( p_data_object		:= ( ( #s_CDIAS.p_CDIASAccesses^.p_HandleDO + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )^ )$^DINT
        , us_state			:= us_varan_mode
        , ud_bytes			:= 2
        );

    //set data for first execution
    ( Handle$^UINT )^ := data;

    //return right pointer to data
    Handle := ( Handle$UDINT - _IOSegment )$DINT;

    //save right handle counter
    ( ( #s_CDIAS.p_CDIASAccesses^.us_CallNumber + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^USINT )^ := s_CDIAS.us_HandleCounter;

    //save right mode of cdias access
    ( ( #s_CDIAS.p_CDIASAccesses^.us_Handle + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^USINT )^ := s_CDIAS.us_LastMode;

    //set right call number to know which access belong to the same call
    ( ( #s_CDIAS.p_CDIASAccesses^.us_RtCy + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^USINT )^ := RTCY$USINT;
  
    //save thispointer of call
    ( ( #s_CDIAS.p_CDIASAccesses^.p_This + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^DINT )^ := thisp$DINT;

    //increase cdias counter
    s_CDIAS.ui_CDIASCounter += 1;
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::AddWr16Bit
//[#ENGLISH]
//=================================================================================================
//Function read id out of eeprom
//=================================================================================================
//[<Kennund]id of cdias module
//[>Place]place of cdias module
FUNCTION VIRTUAL GLOBAL CIV_Base::GetKennung
VAR_INPUT
  Place		: UDINT;
END_VAR
VAR_OUTPUT
  Kennung		: UDINT;
END_VAR
VAR
  sd_retval : DINT;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    Kennung := 255;
    return;
  END_IF;
#endif

  //read one byte out of eeprom
(*	sd_retval := I2CReadOneByte	( AdressCDIAS 	:= ( Place * 16#100 )$UINT + 2
                , pData			:= ( #Kennung )$^USINT
                );
  
  //we only need one byte
  Kennung := Kennung and 16#FF;

  //look for an error
  if ( sd_retval <> VARANMANAGER_OK & b_EEPromError = TRUE ) then
    b_EEPromError := FALSE;
    Control := 0;
    VaranIn.SetState( sd_error := _ClassOk );
  end_if;
*)

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if class is ok
  if ( Control = 0 ) then

    //read one byte of CDIAS - EEPROM
    sd_retval := ReadCDIASEEpromCIV(  us_cdias_place	:= ((( Place * 16#100 )$UINT + 2) shr 8 )$USINT
                    , us_offset			:= (( Place * 16#100 )$UINT + 2)$USINT
                    , ui_length			:= 1
                    , p_us_data			:= ( #Kennung )$^USINT
                    );		

  
    //check for errors
    if ( sd_retval <> VARANMANAGER_OK ) then
      Kennung	:= 255;
    else
      //we only need one byte
      Kennung := Kennung and 16#FF;
    end_if;	

  else
    Kennung	:= 255;	
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::GetKennung

//[#ENGLISH]
//=================================================================================================
//Function to activate single calls
//=================================================================================================
FUNCTION VIRTUAL GLOBAL CIV_Base::RtWork
VAR_INPUT
  EAX		: UDINT;
END_VAR
VAR_OUTPUT
  state		: UDINT;
END_VAR
VAR
  i				: UDINT;
  us_act_number	: USINT;
  p_one_cdias		: ^t_OneCDIASAccess;
  us_act_call		: USINT;
  us_act_call_old	: USINT;
  p_cdias			: ^HwBaseCDIAS;
  p_CdiasCallback	: ^t_CDIASCallback;
END_VAR

  //if class is ok
  if ( Control = 0 ) then

    //call update methods with defined priority (in differently order according to the place number)
    if ( us_cntPrioTasksRT > 0 ) then

      for i := 0 to us_cntPrioTasksRT - 1 do 
      
        p_CdiasCallback := #a_CdiasCallBacks[ a_TasksRT[ i ].us_Place ];
        if ( p_CdiasCallback^.ud_Flags.3 = 1 ) then
          p_cdias := p_CdiasCallback^.ud_Thisp$^HwBaseCDIAS;

          //call class
          p_cdias^.UpdateRt( 0 );
        end_if;

      end_for;

    end_if;
    
    //check if we have a new class to call
    for i := 0 to 7 do
      
      p_CdiasCallback := #a_CdiasCallBacks[ i ];
      if ( p_CdiasCallback^.ud_Flags.1 = 1 ) then
        p_cdias := p_CdiasCallback^.ud_Thisp$^HwBaseCDIAS;

        //call class
        p_cdias^.UpdateRt( 0 );
      end_if;
    end_for;
    
    
    //if we have no handle return
    if ( s_CDIAS.us_HandleCounter = 0 ) then
      return;
    end_if;

    //set act number to invalid
    us_act_number 	:= 16#FF;
    us_act_call_old := 16#FF;	
    
    //we must search in all handles
    for i := 0 to ( s_CDIAS.ui_CDIASCounter - 1 ) do

      //get one cdias strcture
      p_one_cdias := s_CDIAS.p_CDIASAccesses + ( sizeof( t_OneCDIASAccess ) * i );
    
      //look if it is in realtime
      if ( (p_one_cdias^.us_RTCY) AND VARAN_DOL_ISO = VARAN_DOL_ISO ) then
      
        //save handle number
        us_act_call := p_one_cdias^.us_CallNumber;

        //every call number is called one time
        if ( us_act_call <> us_act_call_old ) then
          us_act_call_old := us_act_call;
          p_CdiasClassRt$DINT := p_one_cdias^.p_This;

          p_CdiasClassRt^.UpDateRt( ( #p_one_cdias^.us_Handle - _IOSegment )$UDINT );
        end_if;

        //look if it is a single call (and is activated)
        if ( p_one_cdias^.us_Handle = Dmsingle ) then
      
          //reset single call
          p_one_cdias^.us_Handle := 0;
          //save handle number
          us_act_number := p_one_cdias^.us_CallNumber;

        end_if;

        //if handle number is same as call number change state of DO to single run
        if ( p_one_cdias^.us_CallNumber = us_act_number ) then
          if b_PayloadSupport then
            p_one_cdias^.b_DOIsRunning.StartRequest := true;
          else
          p_one_cdias^.p_HandleDO^.ucCtrlStat := VaranIn.SetRunStatus(VARAN_DO_SINGLE_RUN);
        end_if;
          
      end_if;
        
        if b_PayloadSupport then
      
          // p_one_cdias xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
          case p_one_cdias^.b_DOIsRunning of
          
            SR_STATE_ENABLE_ME :  // DO is not running and start request is set ----------------------------------------
              VaranIn.EnableDO(ud_DOHandle := p_one_cdias^.p_HandleDO$UDINT);        
              p_one_cdias^.b_DOIsRunning  := SR_STATE_DISABLE_ME;
              
            SR_STATE_DISABLE_ME : // DO is running and start request is not set ----------------------------------------
              VaranIn.DisableDO(ud_DOHandle:= p_one_cdias^.p_HandleDO$UDINT);
              p_one_cdias^.b_DOIsRunning := SR_STATE_NOTHING;
              
            SR_STATE_LEAVE_ME_ENABLED : // DO is running and another start request is set ------------------------------
              p_one_cdias^.b_DOIsRunning := SR_STATE_DISABLE_ME;
              
          end_case;        
        end_if;
        
      end_if;
    end_for;
  end_if;

  state:= READY;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::RtWork
//[#ENGLISH]
// ***************************************************************
//   This Function is Called by PostScan from DiasMasterPostScan
// ***************************************************************
FUNCTION VIRTUAL GLOBAL CIV_Base::CyWork
VAR_INPUT
  EAX		: UDINT;
END_VAR
VAR_OUTPUT
  state		: UDINT;
END_VAR
VAR
  i				: UDINT;
  us_act_number	: USINT;
  p_one_cdias		: ^t_OneCDIASAccess;
  us_act_call		: USINT;
  us_act_call_old	: USINT;
  p_cdias			: ^HwBaseCDIAS;
  p_CdiasCallback	: ^t_CDIASCallback;
END_VAR

  //if class is ok
  if ( Control = 0 ) then

    //first check if we have a new class to call
    for i := 0 to 7 do
      
      p_CdiasCallback	:= #a_CdiasCallBacks[ i ];

      if ( p_CdiasCallback^.ud_Flags.2 = 1 ) then
        p_cdias := p_CdiasCallback^.ud_Thisp$^HwBaseCDIAS;

        //call class
        p_cdias^.UpdataCy( 0 );
      end_if;
    end_for;

    //if we have no handle return
    if ( s_CDIAS.us_HandleCounter = 0 ) then
      return;
    end_if;
    
    //set act number to invalid
    us_act_number 	:= 16#FF;	
    us_act_call_old	:= 16#FF;
    
    //we must search in all handles
    for i := 0 to ( s_CDIAS.ui_CDIASCounter - 1 ) do

      //get one cdias strcture
      p_one_cdias := s_CDIAS.p_CDIASAccesses + ( sizeof( t_OneCDIASAccess ) * i );
    
      //look if it is in cyclic
      if ( p_one_cdias^.us_RTCY = VARAN_DOL_ASY ) then
      
        //save handle number
        us_act_call := p_one_cdias^.us_CallNumber;

        //every call number is called one time
        if ( us_act_call <> us_act_call_old ) then
          us_act_call_old := us_act_call;
          p_CdiasClassCy$DINT := p_one_cdias^.p_This;

          p_CdiasClassCy^.UpDataCy( ( #p_one_cdias^.us_Handle - _IOSegment )$UDINT );
        end_if;

        //look if it is a single call (and is activated)
        if ( p_one_cdias^.us_Handle = Dmsingle) then
      
          //reset single call
          p_one_cdias^.us_Handle := 0;
          //save handle number
          us_act_number := p_one_cdias^.us_CallNumber;

        end_if;

        //if handle number is same as call number change state of DO to single run
        if ( p_one_cdias^.us_CallNumber = us_act_number ) then
          if b_PayloadSupport then
            p_one_cdias^.b_DOIsRunning.StartRequest := true;
          else
          p_one_cdias^.p_HandleDO^.ucCtrlStat := VaranIn.SetRunStatus(VARAN_DO_SINGLE_RUN);
          end_if;					
        end_if;
        
        if b_PayloadSupport then
      
          // p_one_cdias xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
          case p_one_cdias^.b_DOIsRunning of
          
            SR_STATE_ENABLE_ME :  // DO is not running and start request is set ----------------------------------------
              VaranIn.EnableDO(ud_DOHandle := p_one_cdias^.p_HandleDO$UDINT);        
              p_one_cdias^.b_DOIsRunning  := SR_STATE_DISABLE_ME;
              
            SR_STATE_DISABLE_ME : // DO is running and start request is not set ----------------------------------------
              VaranIn.DisableDO(ud_DOHandle:= p_one_cdias^.p_HandleDO$UDINT);
              p_one_cdias^.b_DOIsRunning := SR_STATE_NOTHING;
              
            SR_STATE_LEAVE_ME_ENABLED : // DO is running and another start request is set ------------------------------
              p_one_cdias^.b_DOIsRunning := SR_STATE_DISABLE_ME;
              
          end_case;        
      end_if;
        
      end_if;
    end_for;
  end_if;

  state:= READY;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::CyWork
//[#ENGLISH]
//=================================================================================================
//Function to get Pll time of master
//=================================================================================================
FUNCTION VIRTUAL GLOBAL CIV_Base::GetPllTime
VAR_OUTPUT
  PllTime		: DINT;
END_VAR

  PllTime := ( VaranIn.VaranIn.GetVaranTime() / 1000000 )$DINT;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::GetPllTime
//[#ENGLISH]
//=================================================================================================
//Function to set memory error an set master off
//=================================================================================================
FUNCTION  CIV_Base::Error_ToManyCDIASAccesses

  if ( Control = 0 ) then
    Control := _MemoryFault;
    TRACE( "CIV_Base: To many CDIAS Accesses for CIV module!" );
    VaranIn.SetState( sd_error := _MemoryFault );
    VaranIn.VaranIn.SetManagerOff( e_error := Control$t_e_VaranErrors );
  end_if;

END_FUNCTION // CIV_Base::Error_ToManyCDIASAccesses
//[#ENGLISH]
//=================================================================================================
//Function to read a CDIAS - EEprom over varan bus
//=================================================================================================
//[>us_cdias_place]Place of cdias module
//[>us_offset]offset in eeprom
//[>ui_length]length of data
//[>p_us_data]pointer to data
FUNCTION  CIV_Base::ReadCDIASEEPromCIV
VAR_INPUT
  us_cdias_place		: USINT;
  us_offset			: USINT;
  ui_length			: UINT;
  p_us_data			: ^USINT;
END_VAR
VAR_OUTPUT
  sd_retval			: DINT;
END_VAR

  //init EEProm
  sd_retval := VARANTOCDIAS_iInitI2C	( uiMaster	:= ud_VaranManagerNr
                    , pucNode	:= p_NodeString
                    );
  
  if ( sd_retval <> VARANMANAGER_OK ) then
    return;
  end_if; 

  //call OS - function to get eeprom data		
  sd_retval := VARANTOCDIAS_iReadI2C( uiMaster  := ud_VaranManagerNr
                                    , pucNode   := p_NodeString
                                    , uiStation := us_cdias_place
                                    , uiOffset  := us_offset
                                    , uiLen     := ui_length
                                    , pucData   := p_us_data
                                  );

  if ( sd_retval <> VARANMANAGER_OK ) then
    return;
  end_if; 

  sd_retval := VARANTOCDIAS_iExitI2C	( uiMaster	:= ud_VaranManagerNr
                    , pucNode	:= p_NodeString
                    );

END_FUNCTION // CIV_Base::ReadCDIASEEPromCIV
//[#ENGLISH]
//=================================================================================================
//Function to get retry timeout for cdias access
//=================================================================================================
//[>ud_bytes]number of bytes
//[<ud_timeout]timeout for data object
FUNCTION  CIV_Base::GetRetryTimeout
VAR_INPUT
  ud_bytes		: UDINT;
END_VAR
VAR_OUTPUT
  ud_timeout		: UDINT;
END_VAR

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //Already got response time?
  if ud_ResponseTimeMax = 0 then
    if p_NodeInfo then
      ud_ResponseTimeMax := p_NodeInfo^.uiResponseTimeMax;
      else  // Case is possible because CIV_Init(); may fail. For example if the civ has no power supply
        ud_timeout := 0;  // Return value must be checked for 0!
        return;
    end_if;
    
  end_if;

  //check if Initialized is well done, else call init (cause otherwise pointer could be invalid)
  ud_timeout := ud_ResponseTimeMax + ud_bytes * VM_TIMEOUT_ONE_BYTE + ud_bytes * VM_TIMEOUT_ONE_CDIAS + VM_RETRY_TIMEOUT_STD_OFFSET;


END_FUNCTION // CIV_Base::GetRetryTimeout

FUNCTION VIRTUAL GLOBAL CIV_Base::AddCall2List
  VAR_INPUT
    Mode 	: UINT;
    RTCY 	: DINT;
    thisp 	: ^void;
    callOptions 	: USINT;
  END_VAR
  VAR_OUTPUT
    Handle 	: DINT;
  END_VAR

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

  //look if CDIAS list is full
  if ( s_CDIAS.ui_CDIASCounter = s_CDIAS.ui_MaxCDIAS ) then

    Error_ToManyCDIASAccesses();
  end_if;

  //increas CDIAS counter to get right list position
  s_CDIAS.us_HandleCounter += 1;

  //look if we have realtime or cyclic
  if ( RTCY = 0 ) then
    RTCY := VARAN_DOL_ASY;
  else
    RTCY := 0;
    IF callOptions AND CALL_OPTION_RT_PRESCAN THEN
      RTCY := VARAN_DOL_ISO;
    END_IF;
    
    IF callOptions AND CALL_OPTION_RT_POSTSCAN THEN
      RTCY := RTCY OR CALL_OPTION_RT_POSTSCAN;
    END_IF;
  end_if;

  //get right pointer to handle in CDIAS list and manipulate it to be compatible
  Handle := ( #s_CDIAS.p_CDIASAccesses^.us_Handle + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) - _IOSegment )$DINT;
  
  //save right handle counter
  ( ( #s_CDIAS.p_CDIASAccesses^.us_CallNumber + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^USINT )^ := s_CDIAS.us_HandleCounter;
  
  //set right call number to know which access belong to the same call
  ( ( #s_CDIAS.p_CDIASAccesses^.us_RtCy + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^USINT )^ := RTCY$USINT;

  //save thispointer of call
  ( ( #s_CDIAS.p_CDIASAccesses^.p_This + ( s_CDIAS.ui_CDIASCounter * sizeof( t_OneCDIASAccess ) ) )$^DINT )^ := thisp$DINT;

  //increase cdias counter
  s_CDIAS.ui_CDIASCounter += 1;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::AddCall2List
//[#ENGLISH]
//[>p_data]pointer to varan write data
//[>ud_address]address of do
FUNCTION VIRTUAL GLOBAL CIV_Base::SetNewDOAddressRd
VAR_INPUT
  p_data			: ^DINT;
  ud_address		: UDINT;
END_VAR
VAR
  p_addressRd		: ^t_VaranDOSettingsRd;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    return;
  END_IF;
#endif

#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    ((0)$^USINT)^ := 0;    
  end_if;  
#endif  

  p_addressRd := p_data - VM_DO_OFFSET_RD;
  p_addressRd^.ud_Address := ud_address + ud_DeviceAddress;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::SetNewDOAddressRd
//[#ENGLISH]
//[>p_data]pointer to varan write data
//[>ud_address]address of do
FUNCTION VIRTUAL GLOBAL CIV_Base::SetNewDOAddressWr
VAR_INPUT
  p_data		: ^DINT;
  ud_address	: UDINT;
END_VAR
VAR
  p_addressWr		: ^t_VaranDOSettingsWr;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    return;
  END_IF;
#endif

#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    TRACE( "CIV_Base  Method not supported with Varan Payload support" );
    ((0)$^USINT)^ := 0; 
  end_if;  
#endif   

  p_addressWr := p_data - VM_DO_OFFSET_WR;
  p_addressWr^.ud_Address := ud_address + ud_DeviceAddress;
  
END_FUNCTION //VIRTUAL GLOBAL CIV_Base::SetNewDOAddressWr
//[#ENGLISH]
//[>p_data]pointer to varan write data
//[>ud_address_read]read address of do
//[>ud_address_write]write address of do
FUNCTION VIRTUAL GLOBAL CIV_Base::SetNewDOAddressRdWr
VAR_INPUT
  p_data				: ^DINT;
  ud_address_read		: UDINT;
  ud_address_write	: UDINT;
END_VAR
VAR
  p_addressRdWr		: ^t_VaranDOSettingsRdWr;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    return;
  END_IF;
#endif

#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    TRACE( "CIV_Base Method not supported with Varan Payload support" );
    ((0)$^USINT)^ := 0; 
  end_if;  
#endif   

  p_addressRdWr := p_data - VM_DO_OFFSET_RDWR;
  p_addressRdWr^.ud_AddressRd := ud_address_read + ud_DeviceAddress;
  p_addressRdWr^.ud_AddressWr := ud_address_write + ud_DeviceAddress;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::SetNewDOAddressRdWr
#pragma warning( disable: 73 )

//[#DEUTSCH]
//[>irqnr]0..IRQ I/O (IRQ PIN C3) | 1..IRQ Comunication (GP2 PIN A10)
FUNCTION VIRTUAL GLOBAL CIV_Base::AddCDiasIRQ
VAR_INPUT
  irqnr		: USINT;
  ActionPtr		: pVoid;
  thisp		: pVoid;
END_VAR
VAR_OUTPUT
  ok		: USINT;
END_VAR

  Trace( "Interupts on Varanbus are not supported !!! Configurationerror in object:");
  ok := 0; // only till os gives right value back

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::AddCDiasIRQ
#pragma warning( default: 73 )

//[#ENGLISH]
//=================================================================================================
//Function to write a CDIAS - EEprom over varan bus (Offset 16#B0 - 16#FF)
//=================================================================================================
FUNCTION VIRTUAL GLOBAL CIV_Base::WriteEEData
VAR_INPUT
  Adress		: UDINT;
  pData		: ^USINT;
  ui_length	: UINT;
  ui_offset	: UINT;
END_VAR
VAR_OUTPUT
  retval		: DINT;
END_VAR

  if ( _RTOSVersion >= 16#1199 ) then
    //look if class is already initialized
    if ( b_Initialized = FALSE ) then
      CIV_Init();
    end_if;

    //look for length
    if ( ui_length + ui_offset > 16#100 ) then
      retval := -2;
      return;
    end_if;
    
    //look for length
    if ( ui_offset > 16#FF ) then		//(Offset restriction from 16#80 to 16#FF is in OS )
      retval := -3;
      return;
    end_if;

    //look if class is ok
    if ( Control = 0 ) then

      //get whole EEPROM data
      retval := WriteCDIASEEpromCIV	( us_cdias_place	:= Adress$USINT
                      , us_offset			:= ui_offset$USINT
                      , ui_length			:= ui_length
                      , p_us_data			:= pData
                      );

      //look for an error
      //check for errors
      if ( retval <> VARANMANAGER_OK ) then
        Control := retval;
//				b_EEPromError := TRUE;
        VaranIn.SetState( sd_error := _EEPromError );
      end_if;	

    else
      retval := Control;	
    end_if;	
  else
    retval := -1;
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::WriteEEData
//[#ENGLISH]
//=================================================================================================
//Function to write one Byte in CDIAS - EEprom over varan bus
//=================================================================================================
FUNCTION VIRTUAL GLOBAL CIV_Base::I2CWriteOneByte
VAR_INPUT
  AdressCDIAS		: UINT;
  pData		: ^USINT;
END_VAR
VAR_OUTPUT
  result		: DINT;
END_VAR

  if ( _RTOSVersion >= 16#1199 ) then
    //look if class is already initialized
    if ( b_Initialized = FALSE ) then
      CIV_Init();
    end_if;

    //look if class is ok
    if ( Control = 0 ) then

      //read one byte of CDIAS - EEPROM
      result := WriteCDIASEEpromCIV	( us_cdias_place	:= ( AdressCDIAS shr 8 )$USINT
                      , us_offset			:= AdressCDIAS$USINT
                      , ui_length			:= 1
                      , p_us_data			:= pData
                      );		

      //check for errors
      if ( result <> VARANMANAGER_OK ) then
        Control := result;
//				b_EEPromError := TRUE;
        VaranIn.SetState( sd_error := _EEPromError );
      end_if;	

    else
      result	:= Control;
    end_if;
  else
    result := -1;
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::I2CWriteOneByte
//[#ENGLISH]
//=================================================================================================
//Function to write a CDIAS - EEprom over varan bus
//=================================================================================================
//[>us_cdias_place]Place of cdias module
//[>us_offset]offset in eeprom
//[>ui_length]length of data
//[>p_us_data]pointer to data
FUNCTION  CIV_Base::WriteCDIASEEPromCIV
VAR_INPUT
  us_cdias_place		: USINT;
  us_offset			: USINT;
  ui_length			: UINT;
  p_us_data			: ^USINT;
END_VAR
VAR_OUTPUT
  sd_retval			: DINT;
END_VAR

  if ( _RTOSVersion >= 16#1199 ) then
    //init EEProm
    sd_retval := VARANTOCDIAS_iInitI2C	( uiMaster	:= ud_VaranManagerNr
                      , pucNode	:= p_NodeString
                      );
  
    if ( sd_retval <> VARANMANAGER_OK ) then
      return;
    end_if; 

    //call OS - function to get eeprom data		
    sd_retval := VARANTOCDIAS_iWriteI2C(uiMaster  := ud_VaranManagerNr
                                      , pucNode   := p_NodeString
                                      , uiStation := us_cdias_place
                                      , uiOffset  := us_offset
                                      , uiLen     := ui_length
                                      , pucData   := p_us_data
                                    );

    if ( sd_retval <> VARANMANAGER_OK ) then
      return;
    end_if; 

    sd_retval := VARANTOCDIAS_iExitI2C	( uiMaster	:= ud_VaranManagerNr
                      , pucNode	:= p_NodeString
                      );
  else
    sd_retval := -1;
  end_if;

END_FUNCTION // CIV_Base::WriteCDIASEEPromCIV

FUNCTION GLOBAL CIV_Base::GetRetryCounter
VAR_OUTPUT
  ud_retries		: UDINT;
END_VAR
VAR
  i		: UINT;
  p_DO	: ^t_VARANFrame;
  TempRetryCounter  : USINT;
END_VAR

  ud_retries := 0;

  //check if we have a handle
  if ( s_HandleDOs.ui_Number = 0 ) then
    return;
  end_if;
  
  //search handles for Retry
  for i := 0 to s_HandleDOs.ui_Number - 1 do
    p_DO := ( s_HandleDOs.p_Handles + i * sizeof( t_VARANFrame ) );
    
    // TempRetryCounter := p_DO^.pHandle^.ucRetryCounter;
    
    TempRetryCounter := VaranIn.GetRetryCounter(ud_DOHandle:=p_DO^.pHandle$UDINT );
    ud_retries += TempRetryCounter - p_DO^.us_OldRetryCounter;
    p_DO^.us_OldRetryCounter := TempRetryCounter;
  end_for;

END_FUNCTION //GLOBAL CIV_Base::GetRetryCounter
//[#ENGLISH]
//=================================================================================================
//Function to get pointer to node string
//=================================================================================================
//[<p_us_node]pointer to node string
FUNCTION VIRTUAL GLOBAL CIV_Base::GetPointer2NodeString
VAR_OUTPUT
  p_us_node		: ^USINT;
END_VAR

  p_us_node := VaranIn.GetPointer2NodeString();

END_FUNCTION //VIRTUAL GLOBAL CIV_Base::GetPointer2NodeString


FUNCTION VIRTUAL GLOBAL CIV_Base::GetObjectPath
  VAR_INPUT
    p_us_ObjectPath : ^USINT;
  END_VAR
  VAR_OUTPUT
    sd_retval 	    : DINT;
  END_VAR
  VAR
    p_us_VaranPos		: ^USINT;
  END_VAR
  
#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    sd_retval := -4;
    return;
  END_IF;
#endif
  
  if ( p_us_ObjectPath <> NIL ) then
  
    p_us_VaranPos := VaranIn.GetPointer2ObjectPath();
    
    if ( p_us_VaranPos = NIL ) then
      
      sd_retval := -3;
      return;
      
    end_if;
    
    To_StdLib.MemCpy( dest 		:= p_us_ObjectPath
                    , source	:= p_us_VaranPos
                    , size		:= p_us_VaranPos^ + 1
                    );
   
    //if max length is reached
    if ( p_us_ObjectPath^ >= VARAN_MAX_DEPTH ) then
      
      sd_retval := -1;
    
    else
    
      //increase length
      p_us_ObjectPath^ += 1;
      
      //add escape-sequence for starting of Dias bus
      ( p_us_ObjectPath + p_us_ObjectPath^ )^ := HWT_ESCAPE_CDIAS;
  
      sd_retval := 0;
    
    end_if;	

  else
    
    sd_retval := -2;
  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIV_Base::SetTaskPriority
  VAR_INPUT
    us_place 	    : USINT;
    us_priority 	: USINT;
    ud_dol_type 	: UDINT;
  END_VAR
  VAR
    i1            : USINT;
    i2            : USINT;
  END_VAR

  //add task to task priority list to define the order of update tasks unaffected by the C-DIAS place
  if ( ud_dol_type = VARAN_DOL_ISO ) then
  
    //isochronous task
    if ( a_CdiasCallBacks [ us_place ].ud_Flags.1 = TRUE ) then
    
      a_CdiasCallBacks[ us_place ].ud_Flags.3 := TRUE;
      a_CdiasCallBacks[ us_place ].ud_Flags.1 := FALSE;
      
      for i1 := 0 to 7 do 
        
        //found empty entry
        if ( a_TasksRT[ i1 ].us_Priority = 0 ) then
        
          a_TasksRT[ i1 ].us_Place    := us_place;
          a_TasksRT[ i1 ].us_Priority := us_priority;
          
          us_cntPrioTasksRT += 1;
          
          exit;
        
        //found entry with lower priority (higher value) 
        elsif ( a_TasksRT[ i1 ].us_Priority > us_priority ) then
        
          //move actual and following elements backwards to get free element
          for i2 := us_cntPrioTasksRT - 1 to i1 do 
          
            a_TasksRT [ i2 + 1 ] := a_TasksRT [ i2 ];
          
          end_for;
          
          a_TasksRT[ i1 ].us_Place    := us_place;
          a_TasksRT[ i1 ].us_Priority := us_priority;
          
          us_cntPrioTasksRT += 1;
          
          exit;
          
        end_if;
      
      end_for;
      
    end_if;

    //isochronous task
    if ( a_CdiasCallBacks [ us_place ].ud_Flags.5 = TRUE ) then
    
      a_CdiasCallBacks[ us_place ].ud_Flags.6 := TRUE;
      a_CdiasCallBacks[ us_place ].ud_Flags.5 := FALSE;
      
      for i1 := 0 to 7 do 
        
        //found empty entry
        if ( a_TasksRTPostScan[ i1 ].us_Priority = 0 ) then
        
          a_TasksRTPostScan[ i1 ].us_Place    := us_place;
          a_TasksRTPostScan[ i1 ].us_Priority := us_priority;
          
          us_cntPrioTasksRTPostScan += 1;
          
          exit;
        
        //found entry with lower priority (higher value) 
        elsif ( a_TasksRTPostScan[ i1 ].us_Priority > us_priority ) then
        
          //move actual and following elements backwards to get free element
          for i2 := us_cntPrioTasksRTPostScan - 1 to i1 do 
          
            a_TasksRTPostScan [ i2 + 1 ] := a_TasksRTPostScan [ i2 ];
          
          end_for;
          
          a_TasksRTPostScan[ i1 ].us_Place    := us_place;
          a_TasksRTPostScan[ i1 ].us_Priority := us_priority;
          
          us_cntPrioTasksRTPostScan += 1;
          
          exit;
          
        end_if;
      
      end_for;
      
    end_if;    
    
  else
  
    //asynchronous task
    if ( a_CdiasCallBacks [ us_place ].ud_Flags.2 = TRUE ) then
    
      a_CdiasCallBacks[ us_place ].ud_Flags.4 := TRUE;
      a_CdiasCallBacks[ us_place ].ud_Flags.2 := FALSE;
      
      for i1 := 0 to 7 do 
        
        //found empty entry
        if ( a_TasksCY[ i1 ].us_Priority = 0 ) then
        
          a_TasksCY[ i1 ].us_Place    := us_place;
          a_TasksCY[ i1 ].us_Priority := us_priority;
          
          us_cntPrioTasksCY += 1;
          
          exit;
        
        //found entry with lower priority (higher value) 
        elsif ( a_TasksCY[ i1 ].us_Priority > us_priority ) then
        
          //move actual and following elements backwards to get free element
          for i2 := us_cntPrioTasksCY - 1 to i1 do 
          
            a_TasksCY [ i2 + 1 ] := a_TasksCY [ i2 ];
          
          end_for;
          
          a_TasksCY[ i1 ].us_Place    := us_place;
          a_TasksCY[ i1 ].us_Priority := us_priority;
          
          us_cntPrioTasksCY += 1;
          
          exit;
          
        end_if;
      
      end_for;
      
    end_if;
  
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIV_Base::SetObjectThisp
  VAR_INPUT
    p_us_ObjectPath 	: ^USINT;
    ud_thisp 	: UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval 	: DINT;
  END_VAR
  
#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    sd_retval := -1;
    return;
  END_IF;
#endif

  sd_retval := VaranIn.SetObjectThisp( p_us_ObjectPath := p_us_ObjectPath
                                     , ud_thisp        := ud_thisp
                                     );
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIV_Base::GetObjectThisp
  VAR_INPUT
    p_us_ObjectPath 	: ^USINT;
  END_VAR
  VAR_OUTPUT
    ud_Thisp 	: UDINT;
  END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    ud_Thisp := 0;
    return;
  END_IF;
#endif

  ud_Thisp := VaranIn.GetObjectThisp(p_us_ObjectPath := p_us_ObjectPath);
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIV_Base::Init

  Initcounter += 1;
  
  //check for required in 11th init run
  if Initcounter = 11 then
    CheckforRequiredError();
  end_if;
  

END_FUNCTION

//BLEERN001 start
FUNCTION VIRTUAL GLOBAL CIV_Base::UpdateRtPostScan
VAR
  i				: UDINT;
  us_act_number	: USINT;
  p_one_cdias		: ^t_OneCDIASAccess;
  us_act_call		: USINT;
  us_act_call_old	: USINT;
  p_cdias			: ^HwBaseCDIAS;
  p_CdiasCallback	: ^t_CDIASCallback;
END_VAR

  //if class is ok
  if ( Control = 0 ) then

    //call update methods with defined priority (in differently order according to the place number)
    if ( us_cntPrioTasksRTPostScan > 0 ) then

      for i := 0 to us_cntPrioTasksRTPostScan - 1 do 
      
        p_CdiasCallback := #a_CdiasCallBacks[ a_TasksRTPostScan[ i ].us_Place ];
        if ( p_CdiasCallback^.ud_Flags.6 = 1 ) then
          p_cdias := p_CdiasCallback^.ud_Thisp$^HwBaseCDIAS;

          //call class
          p_cdias^.UpdateRtPostScan();
        end_if;

      end_for;

    end_if;
    
    //check if we have a new class to call
    for i := 0 to 7 do
      
      p_CdiasCallback := #a_CdiasCallBacks[ i ];
      if ( p_CdiasCallback^.ud_Flags.5 = 1 ) then
        p_cdias := p_CdiasCallback^.ud_Thisp$^HwBaseCDIAS;

        //call class
        p_cdias^.UpdateRtPostScan();
      end_if;
    end_for;
    
    
    //if we have no handle return
    if ( s_CDIAS.us_HandleCounter = 0 ) then
      return;
    end_if;

    //set act number to invalid
    us_act_number 	:= 16#FF;
    us_act_call_old := 16#FF;	
    
    //we must search in all handles
    for i := 0 to ( s_CDIAS.ui_CDIASCounter - 1 ) do

      //get one cdias strcture
      p_one_cdias := s_CDIAS.p_CDIASAccesses + ( sizeof( t_OneCDIASAccess ) * i );
    
      //look if it is in realtime
      if ( (p_one_cdias^.us_RTCY) AND CALL_OPTION_RT_POSTSCAN = CALL_OPTION_RT_POSTSCAN ) then
      
        //save handle number
        us_act_call := p_one_cdias^.us_CallNumber;

        //every call number is called one time
        if ( us_act_call <> us_act_call_old ) then
          us_act_call_old := us_act_call;
          p_CdiasClassRt$DINT := p_one_cdias^.p_This;

          p_CdiasClassRt^.UpdateRtPostScan( ( #p_one_cdias^.us_Handle - _IOSegment )$UDINT );
        end_if;

        //look if it is a single call (and is activated)
        if ( p_one_cdias^.us_Handle = Dmsingle ) then
      
          //reset single call
          p_one_cdias^.us_Handle := 0;
          //save handle number
          us_act_number := p_one_cdias^.us_CallNumber;

        end_if;

        //if handle number is same as call number change state of DO to single run
        if ( p_one_cdias^.us_CallNumber = us_act_number ) then
          if b_PayloadSupport then
            p_one_cdias^.b_DOIsRunning.StartRequest := true;
          else
          p_one_cdias^.p_HandleDO^.ucCtrlStat := VaranIn.SetRunStatus(VARAN_DO_SINGLE_RUN);
        end_if;
          
      end_if;
        
        if b_PayloadSupport then
      
          // p_one_cdias xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
          case p_one_cdias^.b_DOIsRunning of
          
            SR_STATE_ENABLE_ME :  // DO is not running and start request is set ----------------------------------------
              VaranIn.EnableDO(ud_DOHandle := p_one_cdias^.p_HandleDO$UDINT);        
              p_one_cdias^.b_DOIsRunning  := SR_STATE_DISABLE_ME;
              
            SR_STATE_DISABLE_ME : // DO is running and start request is not set ----------------------------------------
              VaranIn.DisableDO(ud_DOHandle:= p_one_cdias^.p_HandleDO$UDINT);
              p_one_cdias^.b_DOIsRunning := SR_STATE_NOTHING;
              
            SR_STATE_LEAVE_ME_ENABLED : // DO is running and another start request is set ------------------------------
              p_one_cdias^.b_DOIsRunning := SR_STATE_DISABLE_ME;
              
          end_case;        
        end_if;
        
      end_if;
    end_for;
  end_if;

END_FUNCTION
//BLEERN001 end


FUNCTION VIRTUAL GLOBAL CIV_Base::AddRequiredObject
  VAR_INPUT
    thisp 	: ^void;
  END_VAR
  
#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    return;
  END_IF;
#endif

  if b_NotfirstCall = false then
  
    p_RequiredObjects := To_StdLib.Malloc(size:=(8*sizeof(^void))); //max 8 CDIAS Module
    VaranIn.AllowRequiredError();
    
    VaranIn.Required := 1;
  
  end_if;
  
  b_NotfirstCall := true;
  
  if RequiredObjectCounter < 8 then
    (p_RequiredObjects + (RequiredObjectCounter * sizeof(^void)))^$^void := thisp;
    RequiredObjectCounter += 1;
      
  else
    TRACE( "CIV-CDIAS2DataMover: Too many required object classes added");
  end_if;  

END_FUNCTION

#pragma warning(disable:137 )      
FUNCTION VIRTUAL CIV_Base::CheckforRequiredError
  VAR
    i : UINT;
    thisp     : ^virtualbase;
    sz_name	  : array[ 0..255 ] of char;
    MyPara    : CmdStruct;
    MyResult  : results;
    UserActionRet    : DINT;
  END_VAR

  if RequiredObjectCounter > 0 then
    //--- init the newInst command
    MyPara.uiCmd := DM_CHECK_REQUIRED_ERROR;
    for i := 0 to (RequiredObjectCounter -1) do 
      thisp := (p_RequiredObjects + (i * sizeof(^void)))^$^virtualbase;
      //--- init result for next call
      MyResult.aData[0] := 16#FF;
      MyResult.aData[1] := 16#FF;
      if (thisp^.NewInst(#MyPara, #MyResult) = ERROR) then
        //Required Error!
        if MyResult.aData[1] = CDIAS_MODULE then
          UserActionRet := VaranIn.UserAction.Write(input:= VARANMANAGER_CB_CDIAS_ERROR);
        else
          UserActionRet := 1;
        end_if;

        if UserActionRet <> 0 then
          _GetObjName( thisp, #sz_name[ 0 ] );
          if RequiredErrors = 0 then
            Trace ("Required Error triggerd by object(s):");
          end_if;
          Trace (#sz_name[ 0 ] );
          
          RequiredErrors +=1;
        end_if;
      end_if;
      
    end_for;
    
    if RequiredErrors > 0 then
      VaranIn.SetState(_CDIASRequiredError);
    end_if;  
    
    To_StdLib.Free(p_RequiredObjects);
  end_if;  

END_FUNCTION
#pragma warning(Default:137 ) 


FUNCTION VIRTUAL GLOBAL CIV_Base::AddMovDO
  VAR_INPUT
    ud_dol_type 	: UDINT;
    p_ud_handle 	: ^UDINT;
    p_ud_MovSettings 	: ^UDINT;
    ud_type 	: UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval 	: DINT;
  END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    sd_retval := _NotInitialized;
    return;
  END_IF;
#endif

  //look if class is already initialized
  if ( b_Initialized = FALSE ) then
    CIV_Init();
  end_if;

#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    ((0)$^USINT)^ := 0; 
  end_if;  
#endif  
    
  //add a move DO
  sd_retval := VaranIn.VaranIn.AddMovDO(ud_dol_type     :=ud_dol_type
                                      , p_ud_handle     :=p_ud_handle
                                      , p_ud_MovSettings:=p_ud_MovSettings
                                      , ud_type         :=ud_type);
                                      
  // no retrycounter for move-command => don't save it into list

END_FUNCTION


FUNCTION GLOBAL CIV_Base::CIV_ReInit

  // next time the init is called, it will initialize again
  b_Initialized 	:= FALSE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CIV_Base::Control::NewInst
  VAR_INPUT
    pPara 	: ^CmdStruct;
    pResult 	: ^Results;
  END_VAR
  VAR_OUTPUT
    ret_code 	: IprStates;
  END_VAR
  
  ret_code := READY;
  
  case pPara^.uiCmd of
    DM_ADD_PAYLOAD_DO :
        if ( AddPayloadDO(pPara:=pPara, pResult:=pResult) ) then
          ret_code := ERROR;
  end_if;
        
    DM_ADD_PAYLOAD_MOVE_DO :
        if ( AddMovePayloadDO(pPara:=pPara, pResult:=pResult) ) then
          ret_code := ERROR;
        end_if;

    DM_GET_PAYLOAD_RETRY_TIMEOUT :
        pResult^.aData[0]$UDINT := GetRetryTimeout(pPara^.aPara[0]$UDINT);
        if pResult^.aData[0]$UDINT = 0 then
          ret_code := ERROR;
        end_if;
        
    else
        ret_code := VaranIn.NewInst(pPara, pResult);
  end_case;

  

END_FUNCTION

FUNCTION VIRTUAL CIV_Base::AddPayloadDO
  VAR_INPUT
    pPara 	: ^CmdStruct;
    pResult 	: ^results;
  END_VAR
  VAR_OUTPUT
    sd_retval 	: DINT;
  END_VAR
  VAR    
    pTemp         : ^t_VARANFrame;	
    
    // For NewInst command 
    _Para 	            : CmdStruct;
    s_paraAddDO   : t_VM_CMD_AddDO;
    s_paraGetPointers     : t_VM_CMD_GetDataPointers;
    s_PropertyValuePair : LSL_PROPERTY_VALUE_PAIR;
  END_VAR
  
  sd_retval := 0;
  
  if ud_HandleModule then
    
    // Add DO to DOL 
    _Para.uiCmd := VM_CMD_ADD_DO;
    
    // Set the Module Handle to the CIV 
    s_paraAddDO.ud_ModuleHandle                 := ud_HandleModule;
    
    // Copy over the relevant parameters
    s_paraAddDO.ud_Command                      := pPara^.aPara[0]$^t_DM_CMD_AddDO^.ud_Command;
    s_paraAddDO.p_ud_DoHandle                   := pPara^.aPara[0]$^t_DM_CMD_AddDO^.p_ud_DoHandle;
    s_paraAddDO.ud_b_DoRequired                 := pPara^.aPara[0]$^t_DM_CMD_AddDO^.ud_b_DoRequired;
    s_paraAddDO.ud_DolType                      := pPara^.aPara[0]$^t_DM_CMD_AddDO^.ud_DolType;
    s_paraAddDO.ud_OffsetRead                   := pPara^.aPara[0]$^t_DM_CMD_AddDO^.ud_OffsetRead;
    s_paraAddDO.ud_LengthRead                   := pPara^.aPara[0]$^t_DM_CMD_AddDO^.ud_LengthRead;
    s_paraAddDO.ud_OffsetWrite                  := pPara^.aPara[0]$^t_DM_CMD_AddDO^.ud_OffsetWrite;
    s_paraAddDO.ud_LengthWrite                  := pPara^.aPara[0]$^t_DM_CMD_AddDO^.ud_LengthWrite;
    s_paraAddDO.ud_PreScalerCounterThreshold    := pPara^.aPara[0]$^t_DM_CMD_AddDO^.ud_PreScalerCounterThreshold;
    s_paraAddDO.ud_PreScalerCounterStartValue   := pPara^.aPara[0]$^t_DM_CMD_AddDO^.ud_PreScalerCounterStartValue;
    s_paraAddDO.ud_Priority                     := pPara^.aPara[0]$^t_DM_CMD_AddDO^.ud_Priority;
    s_paraAddDO.ud_Filter                       := 0; // Not used by CDIAS
    s_paraAddDO.ud_Slices                       := 0; // Not used by CDIAS
    s_paraAddDO.ud_WritePayloadType             := pPara^.aPara[0]$^t_DM_CMD_AddDO^.ud_WritePayloadType;
//                                                := pPara^.aPara[0]$^t_DM_CMD_AddDO^.p_ud_DataAddr_read    // Not used
//                                                := pPara^.aPara[0]$^t_DM_CMD_AddDO^.p_ud_DataAddr_write  // Not used
    
    _Para.aPara[0]  := (#s_paraAddDO)$DINT;    
    
    VaranIn.VaranIn.NewInst(#_Para, pResult);    
    
    if pResult^.aData[0] <> VM_CMD_OK then
      sd_retval := pResult^.aData[0];
      return;
    end_if;
    
    // Get the Data Poiners 
    _Para.uiCmd := VM_CMD_GET_DATA_POINTERS;
    
    // Set the Module Handle to the CIV 
    s_paraGetPointers.ud_DoHandle    := s_paraAddDO.p_ud_DoHandle^;   
    
    s_paraGetPointers.p_ud_ReadData  := pPara^.aPara[0]$^t_DM_CMD_AddDO^.p_ud_ReadData;
    s_paraGetPointers.p_ud_WriteData := pPara^.aPara[0]$^t_DM_CMD_AddDO^.p_ud_WriteData;
    
    _Para.aPara[0]  := (#s_paraGetPointers)$DINT;    
    
    VaranIn.VaranIn.NewInst(#_Para, pResult);
    
    if pResult^.aData[0] <> VM_CMD_OK then    
      return;
    end_if;
    
    // Set the retry timeout of the CDIAS DO
    s_PropertyValuePair.udPropertyId    := DO_PROP_RETRY_TIMEOUT;
    s_PropertyValuePair.udPropertyValue := GetRetryTimeout(ud_bytes := s_paraAddDO.ud_LengthRead + s_paraAddDO.ud_LengthWrite);
    
    // Check retry timeout value
    if s_PropertyValuePair.udPropertyValue = 0 then
      pResult^.aData[0]$DINT := sd_retval := VM_CMD_ERROR_INVALID_TIMEOUT;
      return;
    end_if;    
    
    // Set Timeout
    _Para.aPara[0] := MULTI_VARAN_iSetDoProperties(s_paraAddDO.p_ud_DoHandle^, 1, #s_PropertyValuePair);
    if pResult^.aData[0]$DINT <> VM_CMD_OK then
      sd_retval := pResult^.aData[0]$DINT;
      return;
    end_if;
    
  else
    pResult^.uiLng := sizeof(DINT);
    pResult^.aData[0]$DINT := VM_CMD_ERROR_MODULE_HANDLE; 
    return;
  end_if;
  
  //save handle in structure
  if ( s_HandleDOs.ui_Number = s_HandleDOs.ui_MaxNumber ) then
    s_HandleDOs.p_Handles$^void := To_StdLib.ReAlloc	( mptr		:= s_HandleDOs.p_Handles
                                                      , newsize	:= ( s_HandleDOs.ui_MaxNumber + 8 ) * sizeof( t_VARANFrame ) 
                                                      );

    //look for an error
    if ( s_HandleDOs.p_Handles = NIL ) then
      Control := _MemoryFault;
      VaranIn.SetState( sd_error := _MemoryFault );
      sd_retval := VARANMANAGER_NO_MEM; // Strictly speaking not a VM error, used to prevent possible overlaps in the error codes
      return;
    end_if;
    s_HandleDOs.ui_MaxNumber += 8;
  end_if;

  pTemp := s_HandleDOs.p_Handles + s_HandleDOs.ui_Number * sizeof( t_VARANFrame );  
  
  pTemp^.pHandle := (s_paraAddDO.p_ud_DoHandle^)$^LSL_VARANFRAME;
  pTemp^.us_OldRetryCounter := 0;
  s_HandleDOs.ui_Number += 1;    
 
END_FUNCTION 

FUNCTION VIRTUAL CIV_Base::AddMovePayloadDO
  VAR_INPUT
    pPara 	: ^CmdStruct;
    pResult 	: ^results;
  END_VAR
  VAR_OUTPUT
    sd_retval 	: DINT;
  END_VAR
  VAR    

    // For NewInst command 
    _Para 	            : CmdStruct;
    s_paraAddMovDO   : t_VM_CMD_AddMovDo;
    
  END_VAR
  
  if ud_HandleModule then
  
    // Add Move DO to DOL 
    _Para.uiCmd := VM_CMD_ADD_MOV_DO;
    
    // Pass on the parameters
    s_paraAddMovDO.p_ud_DoHandle                  := pPara^.aPara[0]$^t_DM_CMD_AddMovDo^.p_ud_DoHandle;    
    s_paraAddMovDO.ud_b_DoRequired                := pPara^.aPara[0]$^t_DM_CMD_AddMovDo^.ud_b_DoRequired;
    s_paraAddMovDO.ud_DolType                     := pPara^.aPara[0]$^t_DM_CMD_AddMovDo^.ud_DolType;
    s_paraAddMovDO.ud_SourceReadDoHandle          := pPara^.aPara[0]$^t_DM_CMD_AddMovDo^.ud_SourceReadDoHandle;
    s_paraAddMovDO.ud_SourceReadOffset            := pPara^.aPara[0]$^t_DM_CMD_AddMovDo^.ud_SourceReadOffset;
    s_paraAddMovDO.ud_DestinationWriteDoHandle    := pPara^.aPara[0]$^t_DM_CMD_AddMovDo^.ud_DestinationWriteDoHandle;
    s_paraAddMovDO.ud_DestinationWriteOffset      := pPara^.aPara[0]$^t_DM_CMD_AddMovDo^.ud_DestinationWriteOffset;
    s_paraAddMovDO.ud_LengthMove                  := pPara^.aPara[0]$^t_DM_CMD_AddMovDo^.ud_LengthMove;
    s_paraAddMovDO.ud_PreScalerCounterThreshold   := pPara^.aPara[0]$^t_DM_CMD_AddMovDo^.ud_PreScalerCounterThreshold;
    s_paraAddMovDO.ud_PreScalerCounterStartValue  := pPara^.aPara[0]$^t_DM_CMD_AddMovDo^.ud_PreScalerCounterStartValue;  
    s_paraAddMovDO.ud_Priority                    := pPara^.aPara[0]$^t_DM_CMD_AddMovDo^.ud_Priority;
  
    _Para.aPara[0]  := (#s_paraAddMovDO)$DINT;    
    
    // new command, but we use the original result structure to get the result of the manager in the calling 
    sd_retval := ( VaranIn.VaranIn.NewInst(#_Para, pResult) )$DINT;
  else
    pResult^.uiLng := sizeof(DINT);
    pResult^.aData[0]$DINT := sd_retval := VM_CMD_ERROR_MODULE_HANDLE; 
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL CIV_Base::GetModuleInfo
  VAR_INPUT
    us_place 	: USINT;
  END_VAR
  VAR_OUTPUT
    p_ModuleInfo 	: ^t_s_ModulInfo;
  END_VAR

  p_ModuleInfo := NIL;
  
  if us_place <= 7 then
    p_ModuleInfo := #s_ModuleInfo[us_place];
    // check if module is placed
    if p_ModuleInfo^.p_This = NIL then
      p_ModuleInfo := NIL;
      return;
    end_if;
    p_ModuleInfo^.Kennung := GetKennung(us_place)$UINT;
  end_if;

END_FUNCTION

