//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_VaranSerLibOS"
	Revision           = "1.20"
	GUID               = "{539F3FBF-B73C-4ADA-A8C0-9DA0B0CADEE2}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "false"
	Objectsize         = "(346,120)">
	<Channels>
		<Server
			Name           = "Com"
			Initialize     = "false"
			Visualized     = "false"
			WriteProtected = "true"
			Comment        = "No. of COM: 1-4">
		</Server>
		<Server
			Name           = "Command"
			Initialize     = "false"
			Visualized     = "false"
			WriteProtected = "true"
			Comment        = "for calling global methods">
		</Server>
		<Client Name="Index" Required="true" Internal="false" Comment="index of serial interface on device"/>
		<Client Name="VaranIn" Required="true" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\lsl_st_serial.h" Include="false"/>
			<File Path=".\Rtos_interfaces.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RenSte"/>
		<Dokumentation Revision="1.20" Date="12.02.2014" Author="PieSte" Company="Sigmatek" Description="Add read Client Index in GetComNr to set value with connected server."/>
		<Dokumentation Revision="1.10" Date="18.07.2013" Author="RamAnd" Company="Sigmatek" Description="Return 1 in GetInterfaceType, so the user can identify the interface as non-standard."/>
		<Dokumentation Revision="1.2" Date="04.01.2011" Author="BleErn" Company="Sigmatek" Description="Added Client Transparent that allows to disable a VARAN-HW-Class"/>
		<Dokumentation Revision="1.1" Date="18.02.2009" Author="RoiRol" Company="Sigmatek" Description="RS485 is now also possible on ETVs"/>
	</RevDoku>
	<Network Name="_VaranSerLibOS">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{558235A0-E245-4CBD-82A8-DFE3537670EE}"
				Class      = "_SerLib"
				Position   = "(270,150)"
				Visualized = "true">
				<Channels>
					<Server Name="Com"/>
					<Server Name="Command"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Command" Destination="_base.Command" Vertices="(742,210),(570,240),"/>
			<Connection Source="this.Com" Destination="_base.Com" Vertices="(742,270),(570,300),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _SerLib

_VaranSerLibOS : CLASS
: _SerLib
  //Servers:
  //Clients:
	VaranIn 	: CltChCmd_Varan_Base;
	Index 	: CltCh_DINT;
  //Variables:
		p_node 	: ^USINT;
  //Functions:
	
	FUNCTION _VaranSerLibOS
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL StartUser
		VAR_INPUT
			Baud 	: DINT;
			wordl 	: DINT;
			Parity 	: DINT;
			StopB 	: DINT;
			FifoOnOff 	: DINT := 1;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL StopUser
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SerSend
		VAR_INPUT
			Buffer 	: pVoid;
			Bufferlength 	: UDINT;
			WrLen 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SerClose;
	
	FUNCTION VIRTUAL GLOBAL SetOnline
		VAR_INPUT
			state 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RecvBlock
		VAR_INPUT
			Buffer 	: pVoid;
			rdlength 	: UDINT;
			rdlen 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RecvChar
		VAR_INPUT
			Buffer 	: pVoid;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetRecvState
		VAR_OUTPUT
			length 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetSendState
		VAR_OUTPUT
			to_send 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetError
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IsInitialized
		VAR_OUTPUT
			Initialization 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetInfo
		VAR_INPUT
			Info 	: ^LSLAPI_SERIALINFO;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SetBufferRecv
		VAR_INPUT
			RecvBuffer 	: pVoid;
			BufferLength 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClearRecvBuffer
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RtsOnOff
		VAR_INPUT
			state 	: BOOL;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL rdRts
		VAR_OUTPUT
			state 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL rdCts
		VAR_OUTPUT
			state 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DtrOnOff
		VAR_INPUT
			state 	: BOOL;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL rdDtr
		VAR_OUTPUT
			state 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL rdDCD
		VAR_OUTPUT
			state 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL rdDSR
		VAR_OUTPUT
			state 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL rdRI
		VAR_OUTPUT
			state 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SetRSMode
		VAR_INPUT
			Mode 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetRSMode
		VAR_OUTPUT
			Mode 	: DINT;
		END_VAR;
				//! <Function Comment="Overwrite this method if you need a user defined interface!" Name="GetInterfaceType"/>
	FUNCTION VIRTUAL GLOBAL GetInterfaceType
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="Contains the interface type.&#13;&#10;0..(default) the interface is the standard &#13;&#10;&lt;&gt;0..user defined" Name="GetInterfaceType.Retcode"/>
		END_VAR;
	
	FUNCTION GetComNr;
	
	FUNCTION VIRTUAL GLOBAL Disconnect;
	
	FUNCTION VIRTUAL GLOBAL Connect;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd Varan_Base


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _VaranSerLibOS::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__VARANSERLIBOS
1$UINT, 20$UINT, (SIZEOF(::_VaranSerLibOS))$UINT, 
0$UINT, 2$UINT, 0$UINT, 
TO_UDINT(3827919523), "_VaranSerLibOS", //Class
TO_UDINT(4078275645), "_SerLib", 1$UINT, 31$UINT, //Baseclass
//Servers:
//Clients:
(::_VaranSerLibOS.VaranIn.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2999796184), "VaranIn", TO_UDINT(862125188), "Varan_Base", 2$UINT, 2$UINT, 
(::_VaranSerLibOS.Index.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1999087025), "Index", 
END_FUNCTION


#define USER_CNT__VaranSerLibOS 31

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__VaranSerLibOS] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _VaranSerLibOS::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _SerLib::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _SerLib::Command.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _SerLib::Command.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__VaranSerLibOS;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #StartUser();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #StopUser();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #SerSend();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #SerClose();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #SetOnline();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #RecvBlock();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #RecvChar();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #GetRecvState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #GetSendState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #GetError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #IsInitialized();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #GetInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #SetBufferRecv();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #ClearRecvBuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #RtsOnOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #rdRts();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #rdCts();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #DtrOnOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #rdDtr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #rdDCD();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #rdDSR();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #rdRI();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #SetRSMode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #GetRSMode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #GetInterfaceType();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #Disconnect();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[30]		:= #Connect();

#pragma warning (default : 74)
	_SerLib::Command.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, EXCLUSIVE);

	IF _SerLib::Command.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= _VaranSerLibOS();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma usingLtd Hub_Base

//*********************Inserted from <.\VaranLib\_VaranSerLibOS\_VaranSerLibOS_00_00.st>*********************



 



(************************************************************************************
*
*	Com OS interface class for Varan Com
*	Created : Sigmatek	/	SR	/	2007
*	Changes : 
*
************************************************************************************)

#define VARAN_COM_OS_VERSION	16#1100 + 227
#define COM_INVALID_VALUE		-2147483393			//16#800000FF


FUNCTION  _VaranSerLibOS::GetComNr
VAR
	ud_master		: UDINT;
	p_varan			: ^LSL_VARAN;
END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF VaranIn.IsTransparent() THEN
    return;
  END_IF;
#endif

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
	
		//get node pointer
		p_node := VaranIn.GetPointer2NodeString();

		//check if we have one
		if ( p_Node = NIL ) then
			return;
		end_if;

		ud_master := VaranIn.VaranIn.GetManagerNumber( #p_varan );
    
    //get client values
    Index := Index.Read();
		
		if ( _RTOSVersion >= VARAN_COM_OS_VERSION ) then
      		Com := SERUSER_GETNRBYPATH( master := ud_master, p_Node, index := Index$UDINT );
		end_if;
	end_if;

END_FUNCTION // _VaranSerLibOS::GetComNr

FUNCTION  _VaranSerLibOS::_VaranSerLibOS
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR

	Com := COM_INVALID_VALUE;

	if ( _RTOSVersion < VARAN_COM_OS_VERSION ) then
		TRACE("OS-Com not available! At least OS 1.1.227 is needed! ");
	end_if;

	ret_code	:= C_OK;

END_FUNCTION //  _VaranSerLibOS::_VaranSerLibOS
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::Connect

	GetComNr();

END_FUNCTION //GLOBAL _VaranSerLibOS::Connect

FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::Disconnect

	Com := COM_INVALID_VALUE;

END_FUNCTION //GLOBAL _VaranSerLibOS::Disconnect
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::StartUser
VAR_INPUT
	Baud			: DINT;
	wordl			: DINT;
	Parity			: DINT;
	StopB			: DINT;
	FifoOnOff		: DINT;
END_VAR
VAR_OUTPUT
	ErrorCode		: DINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	ErrorCode := _SerLib::StartUser( Baud, wordl, Parity, StopB, FifoOnOff );

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::StartUser
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::StopUser
VAR_OUTPUT
	ErrorCode		: DINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	ErrorCode := _SerLib::StopUser();

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::StopUser
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::SerSend
VAR_INPUT
	Buffer			: pVoid;
	Bufferlength	: UDINT;
	WrLen			: ^UDINT;
END_VAR
VAR_OUTPUT
	ErrorCode		: DINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	ErrorCode := _SerLib::SerSend( Buffer, Bufferlength, WrLen );

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::SerSend
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::SerClose

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	_SerLib::SerClose();

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::SerClose
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::SetOnline
VAR_INPUT
	state		: UDINT;
END_VAR
VAR_OUTPUT
	ErrorCode		: DINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	ErrorCode := _SerLib::SetOnline( state );

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::SetOnline
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::RecvBlock
VAR_INPUT
	Buffer			: pVoid;
	rdlength		: UDINT;
	rdlen			: ^UDINT;
END_VAR
VAR_OUTPUT
	ErrorCode		: DINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	ErrorCode := _SerLib::RecvBlock( Buffer, rdlength, rdlen );

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::RecvBlock
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::RecvChar
VAR_INPUT
	Buffer		: pVoid;
END_VAR
VAR_OUTPUT
	ErrorCode		: DINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	ErrorCode := _SerLib::RecvChar( Buffer );

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::RecvChar
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::GetRecvState
VAR_OUTPUT
	length		: UDINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	length := _SerLib::GetRecvState();

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::GetRecvState
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::GetSendState
VAR_OUTPUT
	to_send		: UDINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	to_send := _SerLib::GetSendState();

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::GetSendState
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::GetError
VAR_OUTPUT
	ErrorCode		: DINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	ErrorCode := _SerLib::GetError();

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::GetError
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::IsInitialized
VAR_OUTPUT
	Initialization		: UDINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	Initialization := _SerLib::IsInitialized();

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::IsInitialized
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::GetInfo
VAR_INPUT
	Info		: ^LSLAPI_SERIALINFO;
END_VAR
VAR_OUTPUT
	ErrorCode		: DINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	ErrorCode := _SerLib::GetInfo( Info );

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::GetInfo
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::SetBufferRecv
VAR_INPUT
	RecvBuffer		: pVoid;
	BufferLength	: UDINT;
END_VAR
VAR_OUTPUT
	ErrorCode		: DINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	ErrorCode := _SerLib::SetBufferRecv( RecvBuffer, BufferLength );

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::SetBufferRecv
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::ClearRecvBuffer
VAR_OUTPUT
	ErrorCode		: DINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	ErrorCode := _SerLib::ClearRecvBuffer();

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::ClearRecvBuffer
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::RtsOnOff
VAR_INPUT
	state		: BOOL;
END_VAR
VAR_OUTPUT
	ErrorCode		: DINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	ErrorCode := _SerLib::RtsOnOff( state );

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::RtsOnOff
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::rdRts
VAR_OUTPUT
	state		: BOOL;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	state := _SerLib::rdRts();

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::rdRts
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::rdCts
VAR_OUTPUT
	state		: BOOL;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	state := _SerLib::rdCts();

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::rdCts
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::DtrOnOff
VAR_INPUT
	state		: BOOL;
END_VAR
VAR_OUTPUT
	ErrorCode		: DINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	ErrorCode := _SerLib::DtrOnOff( state );

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::DtrOnOff
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::rdDtr
VAR_OUTPUT
	state		: BOOL;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	state := _SerLib::rdDtr();

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::rdDtr
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::rdDCD
VAR_OUTPUT
	state		: BOOL;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	state := _SerLib::rdDCD();

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::rdDCD
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::rdDSR
VAR_OUTPUT
	state		: BOOL;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	state := _SerLib::rdDSR();

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::rdDSR
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::rdRI
VAR_OUTPUT
	state		: BOOL;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	state := _SerLib::rdRI();

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::rdRI
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::SetRSMode
VAR_INPUT
	Mode		: UDINT;
END_VAR
VAR_OUTPUT
	ErrorCode		: DINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	
  
  IF pHandle THEN 
		IF Mode = 422 THEN
			ErrorCode := SERUSER_Set422Mode( pHandle, 1 );
		ELSIF Mode = 232 THEN
			ErrorCode := SERUSER_Set422Mode( pHandle, 0 );
    ELSIF Mode = 485 THEN
			IF (_RtosVersion >= 16#01131)  THEN
				ErrorCode := SERUSER_Set485Mode( pHandle, 1, 1 );
			ELSE
				ErrorCode := -21; // not supported
			END_IF;
		ELSIF Mode = 4850 then //new mode RS485 without echo
			IF (_RtosVersion >= 16#01131) THEN
				
				//RS485 Mode without ECHO
				ErrorCode := SERUSER_Set485Mode( pHandle, 1, 0 );
			ELSE
				ErrorCode := -21; // not supported
			END_IF;
      
		ELSE
			ErrorCode := -21; // not supported
		END_IF;
	ELSE
		ErrorCode := -1;
	END_IF;

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::SetRSMode
FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::GetRSMode
VAR_OUTPUT
	Mode		: DINT;
END_VAR

	//if we have no number
	if ( Com = COM_INVALID_VALUE ) then
		GetComnr();
	end_if;	

	Mode := _SerLib::GetRSMode();

END_FUNCTION //VIRTUAL GLOBAL _VaranSerLibOS::GetRSMode



FUNCTION VIRTUAL GLOBAL _VaranSerLibOS::GetInterfaceType
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := 1;

END_FUNCTION
