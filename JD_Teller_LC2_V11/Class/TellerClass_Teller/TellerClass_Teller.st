//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "TellerClass_Teller"
	Revision           = "1.3"
	GUID               = "{24EC4E33-E2A5-4168-AA9C-34ED4BC0AD0D}"
	RealtimeTask       = "true"
	DefRealtime        = "1 ms"
	DefRealtimeIndex   = "1073742080"
	CyclicTask         = "true"
	DefCyclictime      = "100 ms"
	DefCyclicIndex     = "1073742080"
	BackgroundTask     = "true"
	DefBackground      = "200 ms"
	DefBackgroundIndex = "1073742080"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(570,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{F8A43A54-AA24-4905-AFBA-56ED7F3B5AD8}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Standaard 20&#13;&#10;"/>
		<Server Name="i2SenCNT" GUID="{F1C18584-758C-4F28-951E-E18D8BCEABC3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Servicemenu instelling&#13;&#10;&#13;&#10;Met de waarde kan het aantal telsensors worden ingesteld.&#13;&#10;Algemene instelling. Met deze server worden alle Visuteller &#13;&#10;i2SenCNT overschreven!&#13;&#10;&#13;&#10;Bereik&#13;&#10;&#13;&#10;0:&#13;&#10;Alleen SensorL wordt gebruikt bij type 1 t/m 5, behalve type 3.&#13;&#10;&#13;&#10;1:&#13;&#10;Zowel Sensor L en Sensor R worden gebruikt bij type 1t/m 5, behalve type 3.&#13;&#10;&#13;&#10;"/>
		<Server Name="iBoxlengthCNT" GUID="{58FB0B41-73C8-4393-97F0-E90B279CD24C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="iBoxlengthCNT_Max" GUID="{652AFA1F-0151-4B45-A06B-32D5B27E3371}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="iBoxlengthCNT_Min" GUID="{8D21F0FE-3232-422B-B73C-312C7D9DC986}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="iBoxlengthJamL" GUID="{F0E55DC3-8043-46E0-9D5D-B69C3D26FFFA}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="iBoxlengthJamL_Max" GUID="{AF396F92-4A79-4DE9-86E3-340A82E1D7C9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="iBoxlengthJamL_Min" GUID="{7DD6BD79-2603-4CAD-A62D-DE490926D205}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="iBoxlengthJamR" GUID="{8EF46781-08F6-41D5-8EAB-C782664E77D8}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="iBoxlengthJamR_Max" GUID="{9BE111E0-1C85-4901-B578-403488C9F976}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="iBoxlengthJamR_Min" GUID="{E9ACAC2B-6B13-4C47-AA8C-A4BC61CE72B9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="iBoxlengthJamSTR" GUID="{EF438C36-F909-4F6D-8052-30235DA16922}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="iBoxlengthJamSTR_Max" GUID="{5EE80A2A-5309-4769-B2F1-85A223DAEF1C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="iBoxlengthJamSTR_Min" GUID="{5CAEDE43-AD0D-45F9-9DCC-616AF0CBECA6}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="iEncDiv" GUID="{94D2DBED-D5AD-4858-BEA7-C950BEF76232}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="idem als iEncMul&#13;&#10;&#13;&#10;Alleen is dit de deelfactor"/>
		<Server Name="iEncMeetdist" GUID="{14A9AA41-6F19-4BFF-A4C0-82ED89A49DFD}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="iEncMul" GUID="{1CE9AA2C-7E37-4FC4-B3E1-485AEF221340}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Met deze instelling is de encoder in te stellen naar de juiste eenheid.&#13;&#10;&#13;&#10;Dit is de vermenigvuldig factor&#13;&#10;&#13;&#10; "/>
		<Server Name="iEncStapper" GUID="{3F982738-677D-4397-9299-5ECAAFA89159}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="iJamdetReset" GUID="{9D7E3400-AD56-4CE6-86C3-75688A223526}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="iSensorCNT" GUID="{870AF824-1A1D-4BDF-8C40-1CA28EBF9721}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="&#13;&#10;&#13;&#10;"/>
		<Server Name="iTotalProduction" GUID="{9ECB2BBA-C1E4-4203-950A-7808603132C9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="MinSpot" GUID="{E1EE0AF2-E0F7-46B7-963E-53DE87B1280F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="oCounter" GUID="{5852BF7B-AE0F-4804-A1A6-C354D086ED7F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="oCounterPerHour" GUID="{B027FDA3-4A44-40B2-9714-BD32A4C2056A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="oJamdetL" GUID="{D3AD7573-24E4-4C5D-81A1-59B48E99F035}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="oJamdetR" GUID="{9C3C56E4-3C74-4269-A81C-635B6A64894C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="oJamdetSTR" GUID="{38904EEC-C04F-4721-B0C5-F01769D0B2C1}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="oRemainingProduction" GUID="{4B968758-89F8-4D4E-AE10-4807842D2A97}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="oSensorHWCNT" GUID="{9FDCD3E3-94CE-4BBA-A0DB-054F085FBB73}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="oSpeed" GUID="{9DB8B9A1-A238-4357-A67D-586FB69516A6}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Snelheid machine in m/min.&#13;&#10;&#13;&#10;in meter per minuut.&#13;&#10;"/>
		<Server Name="oStopperLSE" GUID="{08122A8B-B750-49A1-BEFA-EB6F183CED0F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="De serverLSE wordt gebruikt om plaatjes in LSE te laten zien"/>
		<Server Name="sAnalogSpeed_Man_Auto" GUID="{9DEC25B8-B6F9-4680-9433-69995957281A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="sAnalogSpeedEnable" GUID="{2F8D8BD0-3A21-4EDA-8E7E-1950737EE49E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="sCounter" GUID="{EF202D99-D0D1-4506-94AC-3D08BD670C3B}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="sCounterPerMin" GUID="{AB7A2D34-483F-4443-A9BB-AD12C097D75C}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="sData" GUID="{DA39AEB8-E9D2-48D2-B027-E8AF4DA653FE}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="SRam"/>
		<Server Name="SExtraBox" GUID="{243361EE-F723-4085-9B37-89DA1BE73B9F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Standaard 30"/>
		<Server Name="sFactorAnalogSpeedIn" GUID="{31C1D42D-41D7-4BC9-8C97-9F2A954BE083}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Slider voor bepaling van een factor voor aansturing van de conveyor met een analoog signaal&#13;&#10;&#13;&#10;Min = 0&#13;&#10;Max = 10000"/>
		<Server Name="sFactorAnalogSpeedout" GUID="{9D208B20-6ECF-4973-AB9B-8D10E7E696AD}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="&#13;&#10;Output voor snelheids referentie van de conveyor&#13;&#10;Factor voor aansturing van de conveyor met een analoog signaal&#13;&#10;&#13;&#10;Min = 0&#13;&#10;Max = 10000"/>
		<Server Name="SimSpeed" GUID="{EAA4BB48-D507-49E5-B349-CF89E1C69FAC}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Simulatie" GUID="{731B0840-3941-4DAA-9C05-3C3FBE4FC562}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="sMaxSpeed" GUID="{9433925C-1726-4ECB-8360-7F9E0F17D6E9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="sRemainingProduction" GUID="{C3AE3F5C-421F-4CD8-9566-748EAD57A29F}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="sTotalProduction" GUID="{757E0A77-58A3-4633-909C-62010753FDE1}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="c_JamData" Required="true" Internal="false"/>
		<Client Name="cAnalogSpeedOut" Required="true" Internal="false"/>
		<Client Name="cExtBoxCount" Required="true" Internal="false"/>
		<Client Name="coCounter" Required="true" Internal="false"/>
		<Client Name="coCounterPerMin" Required="true" Internal="false"/>
		<Client Name="coRemainingproduction" Required="true" Internal="false"/>
		<Client Name="coSpeed" Required="true" Internal="false"/>
		<Client Name="coTotalproduction" Required="true" Internal="false"/>
		<Client Name="GetDataTanabe" Required="false" Internal="false"/>
		<Client Name="iEncoder" Required="false" Internal="false"/>
		<Client Name="iSensorL" Required="false" Internal="false"/>
		<Client Name="iSensorR" Required="false" Internal="false"/>
		<Client Name="iSensorSTR" Required="false" Internal="false"/>
		<Client Name="iSimPuls" Required="false" Internal="false"/>
		<Client Name="ObjTaskObjectControl" Required="false" Internal="false"/>
		<Client Name="oHeadnr01" Required="false" Internal="false"/>
		<Client Name="oHeadnr02" Required="false" Internal="false"/>
		<Client Name="oHeadnr03" Required="false" Internal="false"/>
		<Client Name="oHeadnr04" Required="false" Internal="false"/>
		<Client Name="oHeadnr05" Required="false" Internal="false"/>
		<Client Name="oHeadnr06" Required="false" Internal="false"/>
		<Client Name="oHeadnr07" Required="false" Internal="false"/>
		<Client Name="oHeadnr08" Required="false" Internal="false"/>
		<Client Name="oJam" Required="false" Internal="false"/>
		<Client Name="RamEx" Required="true" Internal="false"/>
		<Client Name="ri2SenCNT" Required="true" Internal="true"/>
		<Client Name="riBoxlengthCNT" Required="true" Internal="true"/>
		<Client Name="riBoxlengthJAML" Required="true" Internal="true"/>
		<Client Name="riBoxlengthJAMR" Required="true" Internal="true"/>
		<Client Name="riBoxlengthJamSTR" Required="true" Internal="true"/>
		<Client Name="riEncDiv" Required="true" Internal="true"/>
		<Client Name="riEncMul" Required="true" Internal="true"/>
		<Client Name="riSensorCNT" Required="true" Internal="true"/>
		<Client Name="riTotalProduction" Required="true" Internal="true"/>
		<Client Name="RMinSpot" Required="true" Internal="true"/>
		<Client Name="roCounter" Required="true" Internal="true"/>
		<Client Name="rsAnalogSpeedEnable" Required="true" Internal="true"/>
		<Client Name="rSextraBox" Required="true" Internal="true"/>
		<Client Name="rsFactorAnalogSpeedIn" Required="true" Internal="true"/>
		<Client Name="rsMaxSpeed" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="JD" Author="AP"/>
		<Dokumentation Revision="1.3" Date="2018-01-12" Author="AP" Company="JD" Description="Toevoegen extra counter output (cExBoxCount - CIO07) voor triggeren bij detectie van nieuwe doos&#13;&#10;"/>
		<Dokumentation Revision="1.2" Date="2016-10-24" Author="AP" Company="JD" Description="Aansturing Conveyor analoog signaal&#13;&#10;"/>
		<Dokumentation Revision="1.1" Date="2014-10-14" Author="SV" Company="JD" Description="ClassSvr teruggezet en server MinSpot opnieuw aangemaakt.&#13;&#10;coTotalproduction naar server Stotalproduction overzetten.&#13;&#10;coCounter naar server sCounter overzetten.&#13;&#10;coRemainingProduction naar server sRemainingProduction overzetten.&#13;&#10;coCounterPerMin naar server sCounterPerMin overzetten."/>
		<Dokumentation Revision="1.1" Date="2014-09-23" Author="SV" Company="JD" Description="TaskOnOff code uit class verwijderd. TaskOnOff server verwijderd."/>
		<Dokumentation Revision="1.0" Date="2014-09-04" Author="SV" Company="JD" Description="Gekopieert uit retrofit van versie 1.9. TellerClass_Teller geeft nu de waarden van EncMul, EncDiv,&#13;&#10;MinSpot en ExtraBox door aan de TeachInClass_Teller. Via de nieuwe client c_JamData.&#13;&#10;"/>
	</RevDoku>
	<Network Name="TellerClass_Teller">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "ri2SenCNT"
				GUID       = "{6F01F915-5C30-4D2F-AC6D-B3A69D90934B}"
				Class      = "Ram"
				Position   = "(210,1740)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "riBoxlengthCNT"
				GUID       = "{0E310FFB-8201-469B-92A3-493DB45AD13F}"
				Class      = "Ram"
				Position   = "(210,840)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "riBoxlengthJAML"
				GUID       = "{DF6DEAED-22A3-4358-9934-CBCA89075E6A}"
				Class      = "Ram"
				Position   = "(210,1290)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "riBoxlengthJAMR"
				GUID       = "{9D4F4665-3D76-4930-A42A-93D87AF659E5}"
				Class      = "Ram"
				Position   = "(210,1440)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "riBoxlengthJamSTR"
				GUID       = "{95173EBF-6451-42D6-8ADC-B3F23CFC623C}"
				Class      = "Ram"
				Position   = "(210,1590)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "riEncDiv"
				GUID       = "{938C8078-236A-4678-806E-30C6F54CB574}"
				Class      = "Ram"
				Position   = "(210,540)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "riEncMul"
				GUID       = "{A0A93B84-1225-4C6F-8B83-C29423F710F6}"
				Class      = "Ram"
				Position   = "(210,390)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "riSensorCNT"
				GUID       = "{64CC59DF-FB29-4D95-91CF-ADA8D2E1C3B1}"
				Class      = "Ram"
				Position   = "(210,690)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "riTotalProduction"
				GUID       = "{69CE30E7-4D92-4304-853F-B87F64655A6F}"
				Class      = "Ram"
				Position   = "(210,990)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "RMinSpot"
				GUID       = "{48F75A04-D02C-4D82-BE2B-E38A343B6C39}"
				Class      = "Ram"
				Position   = "(210,90)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "roCounter"
				GUID       = "{E4946E7B-9635-4133-934C-8D2CE3D57CF6}"
				Class      = "Ram"
				Position   = "(210,1140)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "rsAnalogSpeedEnable"
				GUID       = "{49A6ED02-B56D-415D-9B1A-3C04CE12CA18}"
				Class      = "Ram"
				Position   = "(210,2190)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "rSextraBox"
				GUID       = "{D7BE89C8-3A7D-49CF-AD52-75EE30EEEBE5}"
				Class      = "Ram"
				Position   = "(210,240)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "rsFactorAnalogSpeedIn"
				GUID       = "{57B6EFAD-7EB6-4A0E-8E48-9E705BBFADFD}"
				Class      = "Ram"
				Position   = "(210,2040)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "rsMaxSpeed"
				GUID       = "{03E3B597-A708-494C-8EEF-F2C03B39393C}"
				Class      = "Ram"
				Position   = "(210,1890)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.riTotalProduction" Destination="riTotalProduction.Data"/>
			<Connection Source="this.RMinSpot" Destination="RMinSpot.Data"/>
			<Connection Source="this.rSextraBox" Destination="rSextraBox.Data"/>
			<Connection Source="this.riEncMul" Destination="riEncMul.Data"/>
			<Connection Source="this.riEncDiv" Destination="riEncDiv.Data"/>
			<Connection Source="this.riSensorCNT" Destination="riSensorCNT.Data"/>
			<Connection Source="this.riBoxlengthCNT" Destination="riBoxlengthCNT.Data"/>
			<Connection Source="this.ri2SenCNT" Destination="ri2SenCNT.Data"/>
			<Connection Source="this.riBoxlengthJAML" Destination="riBoxlengthJAML.Data"/>
			<Connection Source="this.riBoxlengthJAMR" Destination="riBoxlengthJAMR.Data"/>
			<Connection Source="this.riBoxlengthJamSTR" Destination="riBoxlengthJamSTR.Data"/>
			<Connection Source="this.roCounter" Destination="roCounter.Data"/>
			<Connection Source="this.rsMaxSpeed" Destination="rsMaxSpeed.Data"/>
			<Connection Source="this.rsFactorAnalogSpeedIn" Destination="rsFactorAnalogSpeedIn.Data"/>
			<Connection Source="this.rsAnalogSpeedEnable" Destination="rsAnalogSpeedEnable.Data"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
TellerClass_Teller : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	MinSpot 	: SvrCh_DINT;
	SimSpeed 	: SvrCh_DINT;
	Simulatie 	: SvrCh_DINT;
	SExtraBox 	: SvrCh_DINT;
	iEncMul 	: SvrCh_DINT;
	iEncDiv 	: SvrCh_DINT;
	sMaxSpeed 	: SvrCh_DINT;
	iEncStapper 	: SvrCh_DINT;
	iEncMeetdist 	: SvrCh_DINT;
	oSpeed 	: SvrCh_DINT;
	iSensorCNT 	: SvrCh_DINT;
	oSensorHWCNT 	: SvrCh_DINT;
	iBoxlengthCNT 	: SvrCh_DINT;
	iTotalProduction 	: SvrCh_DINT;
	oRemainingProduction 	: SvrCh_DINT;
	oCounter 	: SvrCh_DINT;
	sAnalogSpeed_Man_Auto 	: SvrCh_DINT;
	sAnalogSpeedEnable 	: SvrCh_DINT;
	sFactorAnalogSpeedIn 	: SvrCh_DINT;
	sFactorAnalogSpeedout 	: SvrCh_DINT;
	oCounterPerHour 	: SvrCh_DINT;
	iBoxlengthJamL 	: SvrCh_DINT;
	iBoxlengthJamR 	: SvrCh_DINT;
	iBoxlengthJamSTR 	: SvrCh_DINT;
	oJamdetL 	: SvrCh_DINT;
	oJamdetR 	: SvrCh_DINT;
	oJamdetSTR 	: SvrCh_DINT;
	iJamdetReset 	: SvrCh_DINT;
	oStopperLSE 	: SvrCh_DINT;
	sData 	: SvrCh_DINT;
	i2SenCNT 	: SvrCh_DINT;
	iBoxlengthCNT_Max 	: SvrCh_DINT;
	iBoxlengthCNT_Min 	: SvrCh_DINT;
	iBoxlengthJamL_Max 	: SvrCh_DINT;
	iBoxlengthJamL_Min 	: SvrCh_DINT;
	iBoxlengthJamR_Max 	: SvrCh_DINT;
	iBoxlengthJamR_Min 	: SvrCh_DINT;
	iBoxlengthJamSTR_Max 	: SvrCh_DINT;
	iBoxlengthJamSTR_Min 	: SvrCh_DINT;
	sTotalProduction 	: SvrCh_DINT;
	sCounter 	: SvrCh_DINT;
	sRemainingProduction 	: SvrCh_DINT;
	sCounterPerMin 	: SvrCh_DINT;
  //Clients:
	iEncoder 	: CltCh_DINT;
	iSensorL 	: CltCh_DINT;
	iSensorR 	: CltCh_DINT;
	iSensorSTR 	: CltCh_DINT;
	oJam 	: CltCh_DINT;
	oHeadnr01 	: CltCh_DINT;
	oHeadnr02 	: CltCh_DINT;
	oHeadnr03 	: CltCh_DINT;
	oHeadnr04 	: CltCh_DINT;
	oHeadnr05 	: CltCh_DINT;
	oHeadnr06 	: CltCh_DINT;
	oHeadnr07 	: CltCh_DINT;
	oHeadnr08 	: CltCh_DINT;
	RamEx 	: CltChCmd_RAMex;
	RMinSpot 	: CltChCmd_Ram;
	rSextraBox 	: CltChCmd_Ram;
	riEncMul 	: CltChCmd_Ram;
	riEncDiv 	: CltChCmd_Ram;
	riSensorCNT 	: CltChCmd_Ram;
	riBoxlengthCNT 	: CltChCmd_Ram;
	riTotalProduction 	: CltChCmd_Ram;
	riBoxlengthJAML 	: CltChCmd_Ram;
	riBoxlengthJAMR 	: CltChCmd_Ram;
	riBoxlengthJamSTR 	: CltChCmd_Ram;
	roCounter 	: CltChCmd_Ram;
	ri2SenCNT 	: CltChCmd_Ram;
	iSimPuls 	: CltCh_DINT;
	coTotalproduction 	: CltCh_DINT;
	coCounter 	: CltCh_DINT;
	coRemainingproduction 	: CltCh_DINT;
	coCounterPerMin 	: CltCh_DINT;
	coSpeed 	: CltCh_DINT;
	c_JamData 	: CltChCmd_RAMex;
	GetDataTanabe 	: CltCh_DINT;
	rsMaxSpeed 	: CltChCmd_Ram;
	rsFactorAnalogSpeedIn 	: CltChCmd_Ram;
	cAnalogSpeedOut 	: CltCh_DINT;
	rsAnalogSpeedEnable 	: CltChCmd_Ram;
	ObjTaskObjectControl 	: CltChCmd__TaskObjectControl;
	cExtBoxCount 	: CltCh_DINT;
  //Variables:
		Sensor 	: SensorLR;
		Jam 	: Jam;
		Kop 	: Aansturing;
		Sposbuffer : ARRAY [0..10] OF ringbuffer;

		Enc 	: Encoder1;
		Kopdata 	: ^tKop;
		Teller 	: Counter1;
		Ospeedie 	: tOspeed;
		timer 	: UDINT;
		CounterperMinute 	: DINT;
		i 	: DINT;
		ii 	: DINT;
		MarkAktieInterupt : ARRAY [0..10] OF SINT;

		JamData 	: ^tJamDetect;
		tmp_AutoAnalogSpeed 	: DINT;
		tmp_ManualAnalogSpeed 	: DINT;
		MyobjInfo 	: LSLOBJ_INFO;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetSensorSprayer
		VAR_OUTPUT
			Result 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetSensorKicker
		VAR_OUTPUT
			Result 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetSensorOffsetSprayer
		VAR_OUTPUT
			Result 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetSensorOffsetKicker
		VAR_OUTPUT
			Result 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL SetMarkInterupt
		VAR_INPUT
			Sprayer_Kicker 	: DINT;			//! <Variable Comment="1 = sprayer&#13;&#10;2 = kicker" Name="SetMarkInterupt.Sprayer_Kicker"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL sMaxSpeed::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL sAnalogSpeed_Man_Auto::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL sAnalogSpeedEnable::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL sFactorAnalogSpeedIn::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL sData::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using Ram
#pragma usingLtd _TaskObjectControl
#pragma usingLtd RAMex


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB TellerClass_Teller::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_TELLERCLASS_TELLER
1$UINT, 3$UINT, (SIZEOF(::TellerClass_Teller))$UINT, 
44$UINT, 40$UINT, 0$UINT, 
TO_UDINT(4092741209), "TellerClass_Teller", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::TellerClass_Teller.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::TellerClass_Teller.MinSpot.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3653713552), "MinSpot", 
(::TellerClass_Teller.SimSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3801008399), "SimSpeed", 
(::TellerClass_Teller.Simulatie.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(277377033), "Simulatie", 
(::TellerClass_Teller.SExtraBox.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1270495476), "SExtraBox", 
(::TellerClass_Teller.iEncMul.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3186417609), "iEncMul", 
(::TellerClass_Teller.iEncDiv.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2837987425), "iEncDiv", 
(::TellerClass_Teller.sMaxSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(599753005), "sMaxSpeed", 
(::TellerClass_Teller.iEncStapper.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1077421377), "iEncStapper", 
(::TellerClass_Teller.iEncMeetdist.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3060558619), "iEncMeetdist", 
(::TellerClass_Teller.oSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1906102849), "oSpeed", 
(::TellerClass_Teller.iSensorCNT.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4264447253), "iSensorCNT", 
(::TellerClass_Teller.oSensorHWCNT.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3496540575), "oSensorHWCNT", 
(::TellerClass_Teller.iBoxlengthCNT.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3135638135), "iBoxlengthCNT", 
(::TellerClass_Teller.iTotalProduction.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2301204702), "iTotalProduction", 
(::TellerClass_Teller.oRemainingProduction.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3971994472), "oRemainingProduction", 
(::TellerClass_Teller.oCounter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4136942132), "oCounter", 
(::TellerClass_Teller.sAnalogSpeed_Man_Auto.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2835439546), "sAnalogSpeed_Man_Auto", 
(::TellerClass_Teller.sAnalogSpeedEnable.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2752185544), "sAnalogSpeedEnable", 
(::TellerClass_Teller.sFactorAnalogSpeedIn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1471660610), "sFactorAnalogSpeedIn", 
(::TellerClass_Teller.sFactorAnalogSpeedout.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2335857206), "sFactorAnalogSpeedout", 
(::TellerClass_Teller.oCounterPerHour.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2764467106), "oCounterPerHour", 
(::TellerClass_Teller.iBoxlengthJamL.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2397520140), "iBoxlengthJamL", 
(::TellerClass_Teller.iBoxlengthJamR.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1961393263), "iBoxlengthJamR", 
(::TellerClass_Teller.iBoxlengthJamSTR.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2692738775), "iBoxlengthJamSTR", 
(::TellerClass_Teller.oJamdetL.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3524883844), "oJamdetL", 
(::TellerClass_Teller.oJamdetR.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(672549095), "oJamdetR", 
(::TellerClass_Teller.oJamdetSTR.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1922127071), "oJamdetSTR", 
(::TellerClass_Teller.iJamdetReset.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4048409699), "iJamdetReset", 
(::TellerClass_Teller.oStopperLSE.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2482741193), "oStopperLSE", 
(::TellerClass_Teller.sData.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(62096333), "sData", 
(::TellerClass_Teller.i2SenCNT.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2112812101), "i2SenCNT", 
(::TellerClass_Teller.iBoxlengthCNT_Max.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2656398066), "iBoxlengthCNT_Max", 
(::TellerClass_Teller.iBoxlengthCNT_Min.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2723698091), "iBoxlengthCNT_Min", 
(::TellerClass_Teller.iBoxlengthJamL_Max.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1712057018), "iBoxlengthJamL_Max", 
(::TellerClass_Teller.iBoxlengthJamL_Min.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1510397411), "iBoxlengthJamL_Min", 
(::TellerClass_Teller.iBoxlengthJamR_Max.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3118187353), "iBoxlengthJamR_Max", 
(::TellerClass_Teller.iBoxlengthJamR_Min.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2245458944), "iBoxlengthJamR_Min", 
(::TellerClass_Teller.iBoxlengthJamSTR_Max.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(540328866), "iBoxlengthJamSTR_Max", 
(::TellerClass_Teller.iBoxlengthJamSTR_Min.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(473562363), "iBoxlengthJamSTR_Min", 
(::TellerClass_Teller.sTotalProduction.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2612862060), "sTotalProduction", 
(::TellerClass_Teller.sCounter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3716193872), "sCounter", 
(::TellerClass_Teller.sRemainingProduction.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3746514342), "sRemainingProduction", 
(::TellerClass_Teller.sCounterPerMin.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2390146770), "sCounterPerMin", 
//Clients:
(::TellerClass_Teller.iEncoder.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3545101083), "iEncoder", 
(::TellerClass_Teller.iSensorL.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2885865646), "iSensorL", 
(::TellerClass_Teller.iSensorR.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1443753421), "iSensorR", 
(::TellerClass_Teller.iSensorSTR.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3141972363), "iSensorSTR", 
(::TellerClass_Teller.oJam.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2117196808), "oJam", 
(::TellerClass_Teller.oHeadnr01.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4168458151), "oHeadnr01", 
(::TellerClass_Teller.oHeadnr02.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1635569181), "oHeadnr02", 
(::TellerClass_Teller.oHeadnr03.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(377224843), "oHeadnr03", 
(::TellerClass_Teller.oHeadnr04.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2283760424), "oHeadnr04", 
(::TellerClass_Teller.oHeadnr05.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4279786430), "oHeadnr05", 
(::TellerClass_Teller.oHeadnr06.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1712392708), "oHeadnr06", 
(::TellerClass_Teller.oHeadnr07.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(286669458), "oHeadnr07", 
(::TellerClass_Teller.oHeadnr08.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2175346435), "oHeadnr08", 
(::TellerClass_Teller.RamEx.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(933570811), "RamEx", TO_UDINT(933570811), "RAMex", 1$UINT, 16$UINT, 
(::TellerClass_Teller.RMinSpot.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(915065404), "RMinSpot", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.rSextraBox.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4091023961), "rSextraBox", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.riEncMul.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1386294117), "riEncMul", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.riEncDiv.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1181070541), "riEncDiv", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.riSensorCNT.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1458696298), "riSensorCNT", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.riBoxlengthCNT.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2722904578), "riBoxlengthCNT", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.riTotalProduction.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(844516984), "riTotalProduction", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.riBoxlengthJAML.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2928701071), "riBoxlengthJAML", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.riBoxlengthJAMR.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1419727852), "riBoxlengthJAMR", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.riBoxlengthJamSTR.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(452999281), "riBoxlengthJamSTR", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.roCounter.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(689641475), "roCounter", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.ri2SenCNT.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2724288114), "ri2SenCNT", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.iSimPuls.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3324891495), "iSimPuls", 
(::TellerClass_Teller.coTotalproduction.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4046484898), "coTotalproduction", 
(::TellerClass_Teller.coCounter.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2459979313), "coCounter", 
(::TellerClass_Teller.coRemainingproduction.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(764494460), "coRemainingproduction", 
(::TellerClass_Teller.coCounterPerMin.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(534739127), "coCounterPerMin", 
(::TellerClass_Teller.coSpeed.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(684835704), "coSpeed", 
(::TellerClass_Teller.c_JamData.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3006162123), "c_JamData", TO_UDINT(933570811), "RAMex", 1$UINT, 16$UINT, 
(::TellerClass_Teller.GetDataTanabe.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4267960097), "GetDataTanabe", 
(::TellerClass_Teller.rsMaxSpeed.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2614995840), "rsMaxSpeed", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.rsFactorAnalogSpeedIn.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1118290468), "rsFactorAnalogSpeedIn", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.cAnalogSpeedOut.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3336483636), "cAnalogSpeedOut", 
(::TellerClass_Teller.rsAnalogSpeedEnable.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(870765369), "rsAnalogSpeedEnable", TO_UDINT(1903583397), "Ram", 1$UINT, 3$UINT, 
(::TellerClass_Teller.ObjTaskObjectControl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2352661849), "ObjTaskObjectControl", TO_UDINT(1584830088), "_TaskObjectControl", 1$UINT, 1$UINT, 
(::TellerClass_Teller.cExtBoxCount.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2479094609), "cExtBoxCount", 
END_FUNCTION


#define USER_CNT_TellerClass_Teller 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_TellerClass_Teller] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION TellerClass_Teller::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_TellerClass_Teller, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MinSpot.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF MinSpot.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SimSpeed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF SimSpeed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Simulatie.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Simulatie.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SExtraBox.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF SExtraBox.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	iEncMul.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF iEncMul.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	iEncDiv.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF iEncDiv.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sMaxSpeed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #sMaxSpeed::Write() );
	IF sMaxSpeed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	iEncStapper.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF iEncStapper.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	iEncMeetdist.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF iEncMeetdist.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	iSensorCNT.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF iSensorCNT.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	iBoxlengthCNT.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF iBoxlengthCNT.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	iTotalProduction.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF iTotalProduction.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	oRemainingProduction.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF oRemainingProduction.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	oCounter.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF oCounter.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sAnalogSpeed_Man_Auto.pMeth			:= StoreMethod( #M_RD_DIRECT(), #sAnalogSpeed_Man_Auto::Write() );
	IF sAnalogSpeed_Man_Auto.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sAnalogSpeedEnable.pMeth			:= StoreMethod( #M_RD_DIRECT(), #sAnalogSpeedEnable::Write() );
	IF sAnalogSpeedEnable.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sFactorAnalogSpeedIn.pMeth			:= StoreMethod( #M_RD_DIRECT(), #sFactorAnalogSpeedIn::Write() );
	IF sFactorAnalogSpeedIn.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	oCounterPerHour.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF oCounterPerHour.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	iBoxlengthJamL.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF iBoxlengthJamL.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	iBoxlengthJamR.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF iBoxlengthJamR.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	iBoxlengthJamSTR.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF iBoxlengthJamSTR.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	iJamdetReset.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF iJamdetReset.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	oStopperLSE.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF oStopperLSE.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sData.pMeth			:= StoreMethod( #sData::Read(), #M_WR_DIRECT() );
	IF sData.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	i2SenCNT.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF i2SenCNT.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL TellerClass_Teller::Init

  
    
  if  RamEx.GetSize() <> sizeof(tKop) then
      RamEx.SetSize(udSize:=sizeof(tKop));
  end_if;
          
   //SV 29-08-2014   
  if      c_JamData.GetSize() <> sizeof(tJamDetect) then
          c_JamData.SetSize(udSize:=sizeof(tJamDetect));
  end_if;


  if  _FirstScan = 1 then
      Kopdata := (RamEx.GetDataPtr())$^tKop;
      JamData := (c_JamData.GetDataPtr())$^tJamDetect;//SV
      //divider mag niet 0 zijn
      if iEncDiv = 0 then  
         iEncDiv :=1;
      end_if;
      
      
 

      //geheugen uitlezen          
      RMinSpot := RMinSpot.Read();
      MinSpot.Write(RMinSpot);       
      rSExtraBox := rSExtraBox.Read();
      SextraBox.Write(rSExtraBox);      
      riEncMul := riEncMul.Read();
      iEncMul.Write(riEncMul);      
      riEncDiv := riEncDiv.Read();
      iEncDiv.Write(riEncDiv);      
      riSensorCNT := riSensorCNT.Read();
      iSensorCNT.Write(riSensorCNT);        
      riBoxlengthCNT := riBoxlengthCNT.Read();
      iBoxlengthCNT.Write(riBoxlengthCNT);      
      riTotalProduction := riTotalProduction.Read();
      iTotalProduction.Write(riTotalProduction);        
      rocounter := rocounter.Read();
      ocounter.Write(rocounter);         
      riBoxlengthJAML := riBoxlengthJAML.Read();
      iBoxlengthJamL.Write(riBoxlengthJAML);        
      riBoxlengthJAMR := riBoxlengthJAMr.Read();
      iBoxlengthJamr.Write(riBoxlengthJAMr);         
      riBoxlengthJamSTR := riBoxlengthJAMstr.Read();
      iBoxlengthJamSTR.Write(riBoxlengthJamSTR);       
      ri2SenCNT := ri2SenCNT.Read();
      i2SenCNT.Write(ri2SenCNT);
      rsFactorAnalogSpeedIn := rsFactorAnalogSpeedIn.Read();
      sFactorAnalogSpeedIn.Write(input:=rsFactorAnalogSpeedIn);
      rsMaxSpeed := rsMaxSpeed.Read();
      sMaxSpeed.Write(input:=rsMaxSpeed);
      rsAnalogSpeedEnable := rsAnalogSpeedEnable.Read();
      sAnalogSpeedEnable.Write(input:=rsAnalogSpeedEnable);
        
    //Verhouding Cyclustijd EncoderClass *50ms* en TellerClass *1ms*
      Enc.EncPerCycle := 50;

    //Encoder resolutie
      Enc.EncResolutie := 1000;
      
    //aantal dozen per uur
      teller.SpeedCalc:=0;
      oCounterPerHour:=0;
      iBoxlengthCNT_Max:=2000;
      iBoxlengthCNT_Min:=0;
      iBoxlengthJamL_Max:=2000;
      iBoxlengthJamL_Min:=0;
      iBoxlengthJamR_Max:=2000;
      iBoxlengthJamR_Min:=0;
      iBoxlengthJamSTR_Max:=2000;
      iBoxlengthJamSTR_Min:=0;

      ObjTaskObjectControl.GetObjectInfo(thispointer:=this, tasktype:=OBJ_CT, objinfo:=#MyobjInfo);
  
  end_if;
  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL TellerClass_Teller::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  //SV 14-10-2014 Client gegevens naar server zetten, tbv uitlezen serial tanabe class
  sTotalProduction := coTotalproduction;
  sCounter := coCounter;
  sRemainingProduction := coRemainingproduction;
  sCounterPerMin := coCounterPerMin;



      //Servers in Ram opslaan
        MinSpot := MinSpot.Read();  
        RMinSpot.Write(MinSpot);
        SExtraBox := SExtraBox.Read();
        rSextraBox.Write(SExtraBox);
        iEncMul := iEncMul.Read();
        riEncMul.Write(iEncmul);
        iEncDiv := iEncDiv.Read();
        riEncDiv.Write(iEncDiv);
        iSensorCNT := iSensorCNT.Read();
        riSensorCNT.Write(iSensorCNT);
        iBoxlengthCNT := iBoxlengthCNT.Read();
        riBoxlengthCNT.Write(iBoxlengthCNT);
        iTotalProduction := iTotalProduction.Read();
        riTotalProduction.Write(iTotalProduction);
        iBoxlengthJamL := iBoxlengthJamL.Read();
        riBoxlengthJAML.Write(iBoxlengthJamL);
        iBoxlengthJamR := iBoxlengthJamR.Read();
        riBoxlengthJAMR.Write(iBoxlengthJamR);
        iBoxlengthJamSTR := iBoxlengthJamSTR.Read();
        riBoxlengthJamSTR.Write(iBoxlengthJamSTR);
        i2SenCNT := i2SenCNT.Read();
        ri2SenCNT.Write(i2SenCNT);

  //Snipperbeveiliging
        Sensor.MinimaleSpot:=MinSpot;  //standaard is dit 20
  
  //Jam, extra lengte die bij de doos wordt opgeteld  
        Jam.SExtraBox := SExtraBox;  //30
  
  //Kop aansturing, extra lengte die bij de doos wordt opgeteld 
        kop.SExtraBox := SExtraBox; // standaard is dit 30
    
  //Jam
        Jam.Boxlength[1] := iBoxlengthJamL;
        Jam.Boxlength[2] := iBoxlengthJamR;
        Jam.Boxlength[3] := iBoxlengthJamSTR;
  
  //Counter
        if    iBoxlengthCNT < 50 then
              iBoxlengthCNT := 50;
              iBoxlengthCNT.Write(iBoxlengthCNT);
        elsif iBoxlengthCNT > 2000 then
              iBoxlengthCNT := 2000;
              iBoxlengthCNT.Write(iBoxlengthCNT);
        end_if;

  // De server i2SenCNT bepaalt of er 1 of 2 telsensors worden gebruikt
        if    i2SenCNT < 0 then
              i2SenCNT:=0;
        elsif i2SenCNT > 1 then
              i2SenCNT:=1;
        end_if;


  //Aansturing van de koppen/Inlezen van Servers
      
      for kop.ii := 1 to kop.iii do

              //Mask van elke kop is gelijk aan mask van teller
              
                Kopdata^.Boxlengte[kop.ii] := iBoxlengthCNT;

              //welke fotocel
        
                if    Kopdata^.Sensor[kop.ii] = 1 then
                      Kop.Offset[kop.ii] := Kopdata^.OffsetL[Kop.ii];
                    
                elsif Kopdata^.Sensor[kop.ii] = 2 then
                      Kop.Offset[kop.ii] := Kopdata^.OffsetR[Kop.ii];
                 
                
                elsif Kopdata^.Sensor[kop.ii] = 3 then
                      Kop.Offset[kop.ii] := Kopdata^.OffsetSTR[Kop.ii];
                  
                end_if;

              //Kopspecs inlezen
                Kop.Dooslengte[kop.ii] := (Kopdata^.Boxlengte[kop.ii] * Encres + Jam.SExtraBox * encres);
                  
                Kop.StotAan[kop.ii] := (Kop.Offset[kop.ii] - Sensor.MinimaleSpot + Kopdata^.Start[kop.ii]); //afstand van sensor tot start spoor
                Kop.StotAan[kop.ii] := (Kop.StotAan[kop.ii] * Encres); 
                                   
                Kop.StotUit[kop.ii] := (kop.Offset[kop.ii] - Sensor.MinimaleSpot + Kopdata^.Start[kop.ii] + Kopdata^.Lengte[kop.ii]); //afstand van sensor tot einde van spoor
                Kop.StotUit[kop.ii] := (Kop.StotUit[kop.ii] * Encres);
                         

              //Met i2SenCNT wordt bepaald of er 1 of 2 telsensors aanwezig zijn
              //0->1 sensor, 1-> 2 sensoren 
                if      i2SenCNT = 0 then
                        kopdata^.i2SensorCNT[kop.ii] := 0;
                        iSensorCNT := 1;
            
                elsif   i2SenCNT = 1 then  
                        kopdata^.i2SensorCNT[kop.ii] := 1;
                        if iSensorCNT < 1 then
                           iSensorCNT := 1;
                        elsif iSensorCNT >2 then
                          iSensorCNT :=2;
                        end_if;              
                end_if;
                
                Kopdata^.SensorHW[kop.ii]:= Sensor.DiHW[Kopdata^.Sensor[kop.ii]]; 
              //Pakket teller conveyor op 1 houden
                if  Kopdata^.iType[kop.ii] = 3 then
                    Kopdata^.Pakket1SET[kop.ii] := 1;
                    Kopdata^.Pakket2SET[kop.ii] := 0;
                end_if;
 
  
      end_for;
              
              
  // De server oStopperLSE wordt gebruikt als variabele om plaatjes in LSE te laten zien
              
      if      Kopdata^.iType[1] = 5 & Kopdata^.Present[1]| // Server "present"toegevoegd nadat de pulldown menus vervangen zijn door switch present (type blijft altijd gelijk)
              Kopdata^.iType[2] = 5 & Kopdata^.Present[2]|
              Kopdata^.iType[3] = 5 & Kopdata^.Present[3]|
              Kopdata^.iType[4] = 5 & Kopdata^.Present[4]|
              Kopdata^.iType[5] = 5 & Kopdata^.Present[5]|
              Kopdata^.iType[6] = 5 & Kopdata^.Present[6]|
              Kopdata^.iType[7] = 5 & Kopdata^.Present[7]|
              Kopdata^.iType[8] = 5 & Kopdata^.Present[8]then
                   
              oStopperLSE := 1;
              oStopperLSE.Write(oStopperLSE);
      else      
              oStopperLSE := 0;
              oStopperLSE.Write(oStopperLSE);                      

      end_if;


      Kopdata^.OutputHW[1]:= oHeadnr01;
      Kopdata^.OutputHW[2]:= oHeadnr02;
      Kopdata^.OutputHW[3]:= oHeadnr03;
      Kopdata^.OutputHW[4]:= oHeadnr04;
      Kopdata^.OutputHW[5]:= oHeadnr05;
      Kopdata^.OutputHW[6]:= oHeadnr06;
      Kopdata^.OutputHW[7]:= oHeadnr07;
      Kopdata^.OutputHW[8]:= oHeadnr08;
      

      Kop.iii  := 1;
      kop.iiii := 0;
      
      for ii:=1 to 8 do
         // De aantal keer dat for lussen in deze code wordt doorlopen
         if Kopdata^.iType[ii] > 0 then
            Kop.iii  := ii;
         end_if;
        
         //Bepaling hoevaak de for lus voor de sensoren en jamdetect worden doorlopen 
         if Kopdata^.Sensor[ii] > kop.iiii then
            kop.iiii := Kopdata^.Sensor[ii];
         end_if;
           
      end_for;

 
      if  ops.tAbsolute - timer > 1000 then
          
          CounterperMinute        :=  oCounterPerHour; 
          coTotalproduction       :=  iTotalProduction; 
          coCounter               :=  oCounter;
          coRemainingproduction   :=  oRemainingProduction;
          coCounterPerMin         :=  to_dint(to_Real(CounterperMinute ) / 60);
          coSpeed                 :=  oSpeed;
          
          coTotalproduction.Write(input:=coTotalproduction);
          coCounter.Write(input:=coCounter);
          coRemainingproduction.Write(input:=coRemainingproduction);
          coCounterPerMin.Write(input:=coCounterPerMin);
          coSpeed.Write(input:=coSpeed);

          timer := ops.tAbsolute;
          
      end_if;   

  

	state := READY;

END_FUNCTION




FUNCTION VIRTUAL GLOBAL TellerClass_Teller::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  

  
    //encoder 

      if iEncDiv = 0 then  
         iEncDiv :=1;
      end_if;
      
      if    SimSpeed <= 0 then
            Enc.Multi   := iEncMul;
            Enc.Divider := iEncDiv;
      else            

            Enc.Multi   := 1000;
            Enc.Divider := 60000;
      end_if;  
      
          
      OSpeedie.EncIn :=iEncoder;
      ospeedie.EncDelta := OSpeedie.EncIn - OSpeedie.EncOud;
      OSpeedie.EncOud := OSpeedie.EncIn;
      oSpeed := to_dint((to_Real(ospeedie.EncDelta) * 60 * To_Real(Enc.Multi)) / (to_Real(Enc.Divider)*MyobjInfo.period));       
      
      //Aansturing van de conveyor met een analoog signaal
      if    sAnalogSpeedEnable & sAnalogSpeed_Man_Auto=0 then //manual OFF
            if    tmp_AutoAnalogSpeed <> 0 then //oude waarde van sFactorAnalogSpeedIn weer activeren bij schakelen van manueel naar auto
                  tmp_ManualAnalogSpeed := sFactorAnalogSpeedIn;
                  sFactorAnalogSpeedIn := tmp_AutoAnalogSpeed;
                  tmp_AutoAnalogSpeed := 0;
            end_if;           
            
            cAnalogSpeedOut := to_dint((to_real(oSpeed) * sFactorAnalogSpeedIn) / to_real(sMaxSpeed));

            if    cAnalogSpeedOut < 0 then
                  cAnalogSpeedOut := 0;
            elsif cAnalogSpeedOut > 10000 then
                  cAnalogSpeedOut := 10000;
            end_if; 
      elsif sAnalogSpeedEnable & sAnalogSpeed_Man_Auto=1 then //manual ON
            if    tmp_AutoAnalogSpeed = 0 then //waarde van sFactorAnalogSpeedIn bewaren
                  tmp_AutoAnalogSpeed := sFactorAnalogSpeedIn;
            end_if;
            
            if    tmp_ManualAnalogSpeed > 0 then
                  sFactorAnalogSpeedIn := tmp_ManualAnalogSpeed;    
                  tmp_ManualAnalogSpeed := 0;
            else
                  cAnalogSpeedOut := sFactorAnalogSpeedIn;    
            end_if;
      else
            cAnalogSpeedOut := 0;
      end_if;

      if    sFactorAnalogSpeedout <> cAnalogSpeedOut then
            sFactorAnalogSpeedout := cAnalogSpeedOut;
            cAnalogSpeedOut.Write(input:=cAnalogSpeedOut);
      end_if;
  

    //De encoder multi wordt berekend (Dit nog testen)      
          case  iEncStapper of
                  
                  0:      //wachten todat lse de stapper ophoogd.
                          iEncMeetdist := 0;
                          iEncMeetdist.Write(iEncMeetdist);  
                  1:
                          enc.Meting1 := iEncoder;    //startpositie van de encoder inlezen
                          enc.Meting2 := 0;
                          iEncStapper := 2;
                  2:                                  //LSE geeft opdracht de machineriem te verplaatsen
                  
                  3:      enc.Meting2 :=  iEncoder;    //vervolgens wordt de stopposie van de encoder ingelezen
                          iEncStapper := 4;
                          
                  4:      
                          iEncMeetdist.Read();        //wachten totdat de afstand in mm wordt ingegeven
                  
                          if   iEncMeetdist > 0  then
                          
                          iEncDiv := 10000;
                          iEncDiv.Write(iEncDiv);     //De divider op 10000 zetten
                          riEncDiv.Write(input:=iEncDiv);
                          
                          enc.encdiv := iEncDiv;
                          enc.enccalc1:= ENC.Meting2 - enc.Meting1;
                          enc.enccalc2:= enc.enccalc1 * enc.encdiv;
                          enc.enccalc3:= enc.enccalc2 / (iEncMeetdist*100);
              
                          iEncMul := enc.enccalc3;
                          iEncMul.Write(iEncMul);     //berekenen van de encoder multiplyer.
                          riEncMul.Write(input:=iEncMul);

                          iEncStapper := 0;
                          end_if;
          end_case;

    //Jam detect

         if    Jam.JamDetection[1] or Jam.JamDetection [2]  or Jam.JamDetection [3] then     //Bij Jamdetect L/R -> Client OJam hoog maken    
               if   oJam = 0 then
                    oJam := 1;
                    oJam.Write(input:=Ojam); 
               end_if;     
         elsif oJam = 1 then
               oJam := 0;
               oJam.Write(input:=Ojam);    
         end_if;

    //Counter1

         //welke telsensor 
         if    iSensorCNT = 1  then
               oSensorHWCNT := iSensorL;
               oSensorHWCNT.Write(oSensorHWCNT);
         elsif iSensorCNT = 2  then
               oSensorHWCNT := iSensorR;
               oSensorHWCNT.Write(oSensorHWCNT);
         end_if;


         //Productie teller
         oRemainingProduction := iTotalProduction - oCounter;          
         if oRemainingProduction < 0 then
            oRemainingProduction :=0;           
         end_if;
         oRemainingProduction.Write(oRemainingProduction);



         //Teller Per uur
         if    oSpeed = 0 | ops.tAbsolute - Teller.Timer1 > 3000 then   //bij geen dozen of bij machine stilstand, na 3 seconden counter per uur op 0 zetten  
               oCounterPerHour := 0;
               teller.wijzer:=0;
               teller.CaseNogTeProd:=0;
               Teller.SpeedCalc :=0;
         end_if;     

         if    teller.Dist2Boxen = 0 then    //mag niet nul zijn!
               teller.Dist2Boxen:=1;
         end_if;


         if    teller.SpeedCalc & oSpeed > 0 then   //Hier krijgt de oCounterPerUur een waarde

              
               case teller.CaseNogTeProd of
              
               0:
              
                  teller.NogTeProdBuffer[teller.wijzer]:= ((oSpeed * 60 * 1000) / teller.Dist2Boxen);
                  teller.Timer := ops.tAbsolute;
                  teller.CaseNogTeProd:=1;
              
               1:
              
                  if ops.tAbsolute - Teller.Timer > 1000 then //om de seconde een waarde

                  
                      if Teller.wijzer = 5 then
                          oCounterPerHour := ((teller.NogTeProdBuffer[1]+teller.NogTeProdBuffer[2]+teller.NogTeProdBuffer[3]+teller.NogTeProdBuffer[4]+teller.NogTeProdBuffer[5]) / Teller.wijzer);
                          oCounterPerHour.Write(input:=oCounterPerHour);
                      end_if;

                  if teller.wijzer = 5 then  //wijzer = 5 weer naar 1 
                     teller.wijzer :=0;
                  end_if;         
                                  
                  teller.wijzer+=1;
                  teller.CaseNogTeProd:=0;
                  end_if;

               end_case;

        end_if;      


        if    oSpeed = 0 |
              ops.tAbsolute - Teller.Timer1 > 3000 then   //bij geen dozen of bij machine stilstand, na 3 seconden counter per uur op 0 zetten
              
              oCounterPerHour := 0;
              teller.wijzer:=0;
              
              teller.CaseNogTeProd:=0;
              Teller.SpeedCalc :=0;
        end_if;
         

        //Correcties bepalen
        for i:=1 to kop.iii do
        
        Kop.ScorAan[i]:=(enc.SpeedDelta * Kopdata^.TopkomInMs[i]);
        Kop.ScorUit[i]:=(enc.SpeedDelta * Kopdata^.TafvalInMs[i]);
        
        end_for;



  
  //SV 29-8-2014. Instellinen in de Jamdetection_TaechIn dezelfde waarde moeten hebben, zodat dit maar 1 keer hoeft te worden ingegeven.
  JamData^.MinSpot := MinSpot;
  JamData^.sExtraBox := SExtraBox;
  JamData^.iEncMulti := iEncMul;
  JamData^.iEncDiv := iEncDiv;










	state := READY;


END_FUNCTION




FUNCTION VIRTUAL GLOBAL TellerClass_Teller::RtWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

//Als in de machine setup de functie is geselelecteerd wordt de code uitgevoerd
 

      if    SimSpeed <= 0 then
            iEncoder := iEncoder.Read();   
      else
            iEncoder += SimSpeed;
      end_if;

      if    enc.Divider < 1 then
            enc.Divider := 1;
      end_if;

      Enc.EncoderDelta := iEncoder - Enc.EncoderOld;
      Enc.EncoderOld := iEncoder;
      Enc.SpeedDelta := ((Enc.EncoderDelta * encres * enc.Multi) / enc.Divider);

           
            
    //inlezen van de sensors 
            
        

    //inlezen van de sensors 
    //one shot op de ingang        


            for Sensor.i := 1 to kop.iiii do  
            
              //inlezen van de sensors 
              if    Simulatie = 1 then
                    iSimPuls := iSimPuls.Read();
                    Sensor.DiHW[1] := iSimPuls;
                    Sensor.DiHW[2] := iSimPuls;
                    Sensor.DiHW[3] := iSimPuls;
              else
                    if Sensor.i = 1 then
                       iSensorL := iSensorL.Read();
                       Sensor.DiHW[1] := iSensorL;              
                    end_if;
                    if Sensor.i = 2 then
                       iSensorR := iSensorR.Read();
                       Sensor.DiHW[2] := iSensorR;              
                    end_if;
                    if Sensor.i = 3 then
                       iSensorSTR := iSensorSTR.Read();
                       Sensor.DiHW[3] := iSensorSTR;              
                    end_if;        
              end_if;

            
              case Sensor.MinimaalSSW[Sensor.i] of

              0:
                if  Sensor.DiHW[Sensor.i] then
                    Sensor.MinimaleCounter[Sensor.i]:=0;
                    Sensor.Din[Sensor.i]:=0;
                    Sensor.MinimaalSSW[Sensor.i]+=1;
                end_if;

              1:
     
                    Sensor.MinimaleCounter[Sensor.i]+= Enc.SpeedDelta;
                    
                if  Sensor.MinimaleCounter[Sensor.i] > Sensor.MinimaleSpot * Encres then
                    if  Sensor.DiHW[Sensor.i] = 1 then
                        Sensor.Din[Sensor.i]:=1;     
                    end_if;
                    Sensor.MinimaalSSW[Sensor.i]+=1;
                end_if;

              2: 
                    
                    Sensor.Din[Sensor.i]:=0;
                if  Sensor.DiHW[Sensor.i] =0 then 
                    Sensor.MinimaalSSW[Sensor.i]:=0;
                end_if;

              end_case;
            end_for;

    //Jam

            for Jam.i := 1 to kop.iiii do

                 if (jam.Boxlength[Jam.i] <> 0) then
                     
                      case Jam.CaseJam[Jam.i] of
                            
                      0: //controleren of aan de snipper beveiliging is voldaan 
                         if Sensor.Din[Jam.i] then                
                            Jam.CaseJam[Jam.i] += 1;
                            Jam.JamPos[Jam.i] := Sensor.MinimaleSpot * encres;
                            Jam.JamBoxlength[Jam.i] := (jam.Boxlength[Jam.i] + Jam.SExtraBox) * encres;
                         end_if;
                         
                         
                      1: //Controle op Jamdetect
                         //Kijken of de sensor hoog is na de ingestelde Boxlengte en extra waarde
                                  
                             Jam.JamPos[Jam.i] += Enc.SpeedDelta;                                                                     
                             if   Jam.JamPos[Jam.i] > Jam.JamBoxlength[Jam.i] then 
                                if  Sensor.DiHW[Jam.i] then         
                                    Jam.JamDetection [Jam.i] := 1;
                                    oJamdetL := Jam.JamDetection[1];
                                    oJamdetL.Write(input:=oJamdetL);
                                    oJamdetR := Jam.JamDetection[2];
                                    oJamdetR.Write(input:=oJamdetR);
                                    oJamdetSTR := Jam.JamDetection[3];
                                    oJamdetSTR.Write(input:=oJamdetSTR);
                                    Jam.CaseJam[Jam.i] += 1;
        
                                else                                
                                    Jam.JamDetection[Jam.i] := 0;   //Geen Jamdetect, terug naar stap 0 en wachten op een nieuwe doos
                                    oJamdetL := Jam.JamDetection[1];
                                    oJamdetL.Write(input:=oJamdetL);
                                    oJamdetR := Jam.JamDetection[2];
                                    oJamdetR.Write(input:=oJamdetR);
                                    oJamdetSTR := Jam.JamDetection[3];
                                    oJamdetSTR.Write(input:=oJamdetSTR);                                
                                    Jam.CaseJam[Jam.i] := 0;
                                end_if; 
                                   
                              
                             end_if;
                      
                      2:  //Jam, reset is nodig om verder te gaan.
                         
                         if iJamdetReset then
                            Jam.JamDetection[Jam.i] := 0;
                            oJamdetL := Jam.JamDetection[1];
                            oJamdetL.Write(input:=oJamdetL);
                            oJamdetR := Jam.JamDetection[2];
                            oJamdetR.Write(input:=oJamdetR);
                            oJamdetSTR := Jam.JamDetection[3];
                            oJamdetSTR.Write(input:=oJamdetSTR);
                            Jam.CaseJam[Jam.i]:=0;
                         
                         end_if;

                        
                      end_case;  
                      

                 else 
                    
                 //Als bij een jamdetect de waarde 0 wordt ingevoerd wordt de jam case gereset
                        if  Jam.JamDetection[Jam.i]  then
                            Jam.CaseJam[Jam.i]:=0;
                            Jam.JamDetection[Jam.i] := 0;
                            
                              if  jam.i = 1 then
                                  oJamdetL := Jam.JamDetection[1];
                                  oJamdetL.Write(input:=oJamdetL);
                              end_if;
                              
                              if  jam.i = 2 then
                                  oJamdetR := Jam.JamDetection[2];
                                  oJamdetR.Write(input:=oJamdetR);
                              end_if;
                              
                              if  jam.i = 3 then
                                  oJamdetSTR := Jam.JamDetection[3];
                                  oJamdetSTR.Write(input:=oJamdetSTR);
                              end_if;
                        end_if;
                 end_if;
            
           end_for;

    //Counter1

          case Teller.i of
                
          0:                                      
             if (( iSensorCNT = 1 & Sensor.Din[1] ) | ( iSensorCNT = 2 & Sensor.Din[2] )) then                
                Teller.i += 1;
                Teller.CounterPos := Sensor.MinimaleSpot * Encres; 
                teller.CounterBoxlength :=(iBoxlengthCNT + Jam.SExtraBox - Sensor.MinimaleSpot) * ENCRES;
                
                //Externe teller
                cExtBoxCount := 1;
                cExtBoxCount.Write(input:=cExtBoxCount);
             end_if; 
             
               
             
          1:                                  
                 Teller.CounterPos += Enc.SpeedDelta;
                 if   Teller.CounterPos > Teller.CounterBoxlength then 
                      oCounter += 1;
                      Teller.Timer1 := ops.tAbsolute;
                      roCounter.Write(oCounter);
                      Teller.i += 1; 
                      Teller.Dist2Boxen := (((iEncoder - teller.EncoderOLD) * Enc.Multi) / Enc.Divider);  //in mm   
                      
                      //Externe teller
                      cExtBoxCount := 0;
                      cExtBoxCount.Write(input:=cExtBoxCount);    
                 end_if;
                 
          2:
          
               Teller.i := 0; 
               Teller.EncoderOLD := iEncoder;
               Teller.TelCalc +=1;
                 
               if Teller.TelCalc = 3 then
                  Teller.TelCalc :=0;
                  Teller.SpeedCalc := 1;  
               
               end_if;
          end_case;          
          

    //Aansturing koppen

          for Kop.i:= 1 to kop.iii do 
          
          //Hier wordt de encoderpositie van de doos opgeslagen in een ringbuffer
            case kop.CaseRing[kop.i] of 

            0:
              if sensor.din[Kopdata^.Sensor[kop.i]] then
                 kop.CaseRing[kop.i]+=1;
                 Kop.Senpos[kop.i]:= Sensor.MinimaleSpot * ENCRES;
                 kop.wrpoint[kop.i]:=kop.wrpoint[kop.i] and 16#0000000F; 
                 SPosbuffer[kop.i][kop.wrpoint[kop.i]] := iEncoder;  //Positie van de doos = sensor + snipperbeveiliging
                 kop.wrpoint[kop.i]+=1;
                 kop.wrpoint[kop.i]:=kop.wrpoint[kop.i] and 16#0000000F;
              end_if;

            1:
              
              Kop.Senpos[kop.i] += enc.SpeedDelta;

              if  Kop.Senpos[kop.i] > kop.Dooslengte[kop.i] then  //als de dooslengte + 30mm gemeten is kan weer een nieuwe doos in het buffer worden opgeslagen
                  Kop.CaseRing[kop.i]:=0;  
              end_if;

            end_case;
         

         //Hier wordt de kop aangestuurd
            case  Kop.CaseAansturing[kop.i] of
                    
            0: //Hebben we een nieuwe doos?
            
              
              if kop.wrpoint[kop.i] <> kop.rdpoint[kop.i] Then		
                 // go
                 kop.rdpoint[kop.i]:=kop.rdpoint[kop.i] and 16#0000000F;
                 //positie berekenen van de doos
                 kop.Spos[kop.i]:= ((iEncoder-Sposbuffer[Kop.i][kop.rdpoint[kop.i]])*((enc.Multi*Encres)/enc.Divider));
                 kop.rdpoint[kop.i]+=1;
                 kop.rdpoint[kop.i]:=kop.rdpoint[kop.i] and 16#0000000F;
                 
                 //Koppen aan
                 if   (Kopdata^.OnOff[kop.i] & Kopdata^.Present[kop.i]) | MarkAktieInterupt[kop.i] = 1 then                 
                      Kop.CaseAansturing[kop.i]+=1;
                 end_if;      
              End_if;
            
            
            1:  //Kop aan  
                kop.Spos[kop.i]+=enc.SpeedDelta;

                if    (Kop.Spos[kop.i] >= (kop.StotAan[kop.i] - Kop.ScorAan[kop.i])) then


                       if   MarkAktieInterupt[kop.i] = 0 then
 
                            if      Kopdata^.Pakket2SET[kop.i] = 0 then 
                                    Kop.PakketWijzer[kop.i] := 0;  
                            end_if;

                            if      Kop.PakketWijzer[kop.i] = 0  then
                                    Kopdata^.Pakket1[kop.i]+=1;
                            elsif   Kop.PakketWijzer[kop.i] = 1  then    
                                    Kopdata^.Pakket2[kop.i]+=1;
                            end_if;
                             
                            if      Kopdata^.Pakket1[kop.i] > Kopdata^.Pakket1SET[kop.i] then
                                    Kopdata^.Pakket1[kop.i] := 1;
                            end_if;
         
                            //pakket teller 1
                            if      Kopdata^.Pakket1[kop.i] = Kopdata^.Pakket1SET[kop.i] & Kop.PakketWijzer[kop.i] = 0 then
                                    Kop.Out[kop.i]:=1;
                                    Kop.CaseAansturing[kop.i]+=1;
                                    Kopdata^.Pakket2[kop.i] :=0;
                                    if  Kopdata^.Pakket2SET[kop.i] = 0 then
                                        Kop.PakketWijzer[kop.i] := 0;
                                    else
                                        Kop.PakketWijzer[kop.i] := 1;
                                    end_if;    
                            //pakket teller 2                            
                            elsif   Kopdata^.Pakket2[kop.i] = Kopdata^.Pakket2SET[kop.i] & Kop.PakketWijzer[kop.i] = 1 then
                                    Kop.Out[kop.i]:=1;
                                    Kop.CaseAansturing[kop.i]+=1;
                                    Kopdata^.Pakket1[kop.i] :=0;
                                    Kop.PakketWijzer[kop.i] := 0;  
                            else
                                    Kop.CaseAansturing[kop.i]+=1;                            
                            end_if;
                       else
                            Kop.Out[kop.i]:=1;
                            Kop.CaseAansturing[kop.i]+=1;                            
                            MarkAktieInterupt[kop.i] := 0;
                       end_if;                            
                end_if;
            2:
                  //Conveyor spoor
                  if    (Kopdata^.iType[kop.i] = 3 & (Kopdata^.Lengte[kop.i] > Kopdata^.Boxlengte[kop.i])) then //bij conveyor aansturing en dat lengte groter is dan boxlengte naar stap 6 voor afhandeling.
                        Kop.conveyor[kop.i]:=1;
                        kop.ConveyorPosdoos[kop.i]:= kop.Spos[kop.i];    
                        kop.UpdateConv[kop.i]:=1;                       
                                                                           
                        kop.CaseAansturing[kop.i] :=0;
                                   
                  elsif (Kopdata^.iType[kop.i] = 3 & (kopdata^.Lengte[kop.i] <= Kopdata^.Boxlengte[kop.i])) then
                        kop.conveyor[kop.i]:=0;
                        Kop.CaseAansturing[kop.i]+=1;
                  else
                        Kop.CaseAansturing[kop.i]+=1;
                  end_if;
             
             
            3:     //Kop uitschakelen
                  kop.Spos[kop.i]+=enc.SpeedDelta;
                  if Kop.Spos[kop.i]>= (Kop.StotUit[kop.i]-kop.ScorUit[kop.i]) then
                            Kop.out[kop.i]:=0;
                            Kop.CaseAansturing[kop.i]:=0;                                                
                  end_if;
                  
            end_case;
        
            //als de lengte van het spoor groter is dan de boxlengte (kan alleen bij type 3 conveyor)
            //dan is de lengte, de afstand tussen 2 dozen. Dit om de conveyor continu te laten draaien
            case  kop.ConveyorCase[kop.i] of
              
            0:
                  if  kop.conveyor[kop.i] then
                  
                  kop.ConveyorCase[kop.i] +=1;
                  kop.UpdateConv[kop.i]:=0;
                  kop.ConveyorPosDoosNew[kop.i]:= kop.ConveyorPosdoos[kop.i] + (kopdata^.Lengte[kop.i] * encres);                   //(kop.ConveyorPosdoos[kop.i] + kopdata^.Lengte[kop.i] * encres);// mod 200000;
                  kop.ConveyorLoper[kop.i]:=kop.ConveyorPosdoos[kop.i];               
                  end_if;


            1:
                  kop.ConveyorLoper[kop.i] += enc.SpeedDelta;
                    
                  if   kop.ConveyorLoper[kop.i] > kop.ConveyorPosDoosNew[kop.i] then
                       kop.ConveyorCase[kop.i] +=1; 
                   
                  elsif Kop.UpdateConv[kop.i] = 1 then
                       kop.ConveyorCase[kop.i] :=0; 
                    
                  end_if;

            2: //uitschakelen conveyor
                  kop.out[kop.i] := 0; 
                  Kop.ConveyorCase[kop.i] :=0; 
                  kop.conveyor[kop.i]:=0;   
                                                           
              end_case;


            //Minimale snelheid force Out
            if  oSpeed < Kopdata^.MinSpeed[kop.i] then
                kop.out[kop.i] := 0;
            end_if;

        
    end_for; 


    //aansturing van de hardware + Testknop
       
      //kop1 
      if  kop.Out[1] | Kopdata^.Test[1] then
          oHeadnr01 := 1;
      else    
          oHeadnr01 := 0;
      end_if;

      //kop2
      if  kop.Out[2] | Kopdata^.Test[2] then
          oHeadnr02 := 1;
      else    
          oHeadnr02 := 0;
      end_if;  

      //kop3 
      if  kop.Out[3] | Kopdata^.Test[3] then
          oHeadnr03 := 1;
      else    
          oHeadnr03 := 0;
      end_if;

      //kop4
      if  kop.Out[4] | Kopdata^.Test[4] then
          oHeadnr04 := 1;
      else    
          oHeadnr04 := 0;
      end_if; 

      //kop5 
      if  kop.Out[5] | Kopdata^.Test[5] then
          oHeadnr05 := 1;
      else    
          oHeadnr05 := 0;
      end_if;

      //kop6
      if  kop.Out[6] | Kopdata^.Test[6] then
          oHeadnr06 := 1;
      else    
          oHeadnr06 := 0;
      end_if;  

      //kop7 
      if  kop.Out[7] | Kopdata^.Test[7] then
          oHeadnr07 := 1;
      else    
          oHeadnr07 := 0;
      end_if;

      //kop8
      if  kop.Out[8] | Kopdata^.Test[8] then
          oHeadnr08 := 1;
      else    
          oHeadnr08 := 0;
      end_if; 
     

      oHeadnr01.Write(oHeadnr01);
      oHeadnr02.Write(oHeadnr02);
      oHeadnr03.Write(oHeadnr03);
      oHeadnr04.Write(oHeadnr04);
      oHeadnr05.Write(oHeadnr05);
      oHeadnr06.Write(oHeadnr06);
      oHeadnr07.Write(oHeadnr07);
      oHeadnr08.Write(oHeadnr08);

 

	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL TellerClass_Teller::sData::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  sData:=(#Kopdata^)$dint;
  
	output := sData;


END_FUNCTION




FUNCTION GLOBAL TellerClass_Teller::GetSensorSprayer
	VAR_OUTPUT
		Result 	: DINT;
	END_VAR

  Result := Sensor.DiHW[2];
  
END_FUNCTION


FUNCTION GLOBAL TellerClass_Teller::GetSensorKicker
	VAR_OUTPUT
		Result 	: DINT;
	END_VAR
  
  Result := Sensor.DiHW[1];

END_FUNCTION


FUNCTION GLOBAL TellerClass_Teller::GetSensorOffsetSprayer
	VAR_OUTPUT
		Result 	: DINT;
	END_VAR

  Result := Kop.Offset[2];
  
END_FUNCTION


FUNCTION GLOBAL TellerClass_Teller::GetSensorOffsetKicker
	VAR_OUTPUT
		Result 	: DINT;
	END_VAR
  
  Result := Kop.Offset[1];
  
END_FUNCTION


FUNCTION GLOBAL TellerClass_Teller::SetMarkInterupt
	VAR_INPUT
		Sprayer_Kicker 	: DINT;
	END_VAR
  
  if    Sprayer_Kicker = 1 then //sprayer
        MarkAktieInterupt[1] := 1;
  elsif Sprayer_Kicker = 2 then //kicker
        MarkAktieInterupt[2] := 1;
  end_if;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL TellerClass_Teller::sMaxSpeed::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if    input < 120 then
        sMaxSpeed := 120;
  elsif input > 500 then
        sMaxSpeed := 500;
  else
        sMaxSpeed := input;
  end_if;

  rsMaxSpeed.Write(input:=sMaxSpeed);
	
	result := sMaxSpeed;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL TellerClass_Teller::sFactorAnalogSpeedIn::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	
  
  if    input < 0 then
        sFactorAnalogSpeedIn := 0;
  elsif input > 10000 then
        sFactorAnalogSpeedIn := 10000;
  else
        sFactorAnalogSpeedIn := input;
  end_if;

  rsFactorAnalogSpeedIn.Write(input:=sFactorAnalogSpeedIn);
  
	result := sFactorAnalogSpeedIn;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL TellerClass_Teller::sAnalogSpeedEnable::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if    input <> 1 then
        sAnalogSpeedEnable := 0;
  else
        sAnalogSpeedEnable := input;
  end_if;

  rsAnalogSpeedEnable.Write(input:=sAnalogSpeedEnable);

	result := sAnalogSpeedEnable;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL TellerClass_Teller::sAnalogSpeed_Man_Auto::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	sAnalogSpeed_Man_Auto := input;
	result := sAnalogSpeed_Man_Auto;

END_FUNCTION
