//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define LogBufferSize 1000
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Class\SafetyManager\SafetyManager.h"
#include <.\lsl_st_hardwaretree.h>
#include "..\..\Class\HwControl\HwControl.h"

(*!
<Class
	Name               = "SafetyManager"
	Revision           = "1.42"
	GUID               = "{186EBAC0-5F71-4A3F-BA36-ED9EA68EA059}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Safety.ico"
	SharedCommandTable = "true"
	Objectsize         = "(646,120)"
	Comment            = "Class to handle:&#13;&#10; - safety communication between domains&#13;&#10; - time synchronisation of safety modules">
	<Channels>
		<Server Name="ClassState" GUID="{0B1E483A-B110-4D1E-9B4C-F20593EE2D5C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows state of safety functionality initialisation&#13;&#10;&#13;&#10; 1..OK&#13;&#10; 0..not active or initializing&#13;&#10;-1..failed to allocate memory&#13;&#10;-2..invalid domain number set in this system&#13;&#10;-3..newer OS version required for domain number support&#13;&#10;-4..method to determine domain number not provided by lsl_st_hardwaretree.h&#13;&#10;-5..only 1 instance of safety manager allowed&#13;&#10;-6..a slave system can only have 1 master. check hw class configuration&#13;&#10;-7..invalid module type tried to log in&#13;&#10;-8..couldn&apos;t find InterfaceCRC which is requested by other domain. Check SafetyDesigner projects, most likely the interface variables doesn&apos;t match.&#13;&#10;-9..failed to add a new copy data object to varan manager&#13;&#10;-10..a non-optional module or domain is not available&#13;&#10;-11..timeout in initialisation (see debugger trace or logfile for further details)&#13;&#10;-12..invalid interface domain configuration (no safety module found, only interface domains)&#13;&#10;-13..failed to install callbacks for cyclic and realtime task"/>
		<Server Name="LoginCnt" GUID="{5FC5C929-C7F8-4BFB-8DF3-09B84403273D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="MaxSyncDuration" GUID="{7517B303-9F59-4B9A-AD1A-8766B8C07194}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Shows maximum value of server SyncDuration"/>
		<Server Name="MinSyncDuration" GUID="{697A1FC7-1D68-4539-AE59-3800B4CF8373}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Shows minimum value of server SyncDuration"/>
		<Server Name="SyncDuration" GUID="{58439908-A73E-4D89-8216-1483D81B8572}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Time of last complete synchronisation cycle in ms (only the Master has this information)"/>
		<Client Name="SafetyDomainTimeout" Required="false" Internal="false" Comment="[ms] the class has to wait for optional interface domains (leave 0 if none available)"/>
		<Client Name="To_HwControl" Required="true" Internal="false"/>
		<Client Name="To_StdLib" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\SafetyManager\SafetyManager.h" Include="true"/>
			<File Path=".\lsl_st_hardwaretree.h" Include="true"/>
			<File Path=".\Class\HwControl\HwControl.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.42" Date="14.04.2014" Author="RamAnd" Company="Sigmatek" Description="Prevent crash if the safety configs are not available at startup."/>
		<Dokumentation Revision="1.41" Date="31.03.2014" Author="LanSte" Company="Sigmatek" Description="Improved Error checking and Logging."/>
		<Dokumentation Revision="1.40" Date="05.12.2013" Author="RamAnd" Company="Sigmatek" Description="Removed domain support&#13;&#10;Support for SCP011 added"/>
		<Dokumentation Revision="1.30" Date="18.07.2013" Author="RamAnd" Company="Sigmatek" Description="Updated LogValue method to show also the actual object name."/>
		<Dokumentation Revision="1.20" Date="07.03.2013" Author="RamAnd&#13;&#10;RamAnd&#13;&#10;ZoePat" Company="Sigmatek" Description="Changed range of the safety NewInst commands. Range for HW-Classes: 0x8000-0x8FFF; Range for Safety HW-Classes: 0x8100-0x81FF&#13;&#10;Corrected order of managing time sync elements. It could have happened, that a subdomain returns the token to the master before sending it to their subdomains.&#13;&#10;Corrected minimal length of configuration."/>
		<Dokumentation Revision="1.10" Date="22.01.2013" Author="ZoePat&#13;&#10;RamAnd&#13;&#10;RamAnd&#13;&#10;RamAnd&#13;&#10;RamAnd" Company="Sigmatek" Description="Support for SCP010 added&#13;&#10;Corrected error in unsafe variable handling if a new safety project is downloaded, while the hardware classes are running.&#13;&#10;Send messages only to managing modules which are synchron.&#13;&#10;Added functionality for domain internal interface frames.&#13;&#10;Fixed memory leak in recreating the time sync list."/>
		<Dokumentation Revision="1.0" Date="03.09.2012" Author="RamAnd" Company="Sigmatek" Description="Initial version"/>
	</RevDoku>
</Class>
*)
SafetyManager : CLASS
	TYPE
#pragma pack(push, 1)
	  t_CopyCmdDO : STRUCT
	    pHandle : ^LSL_VARANFRAME;
	    pSettings : ^t_VaranDOSettingsMov;
	    b_Ready4Action : BOOL;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ModuleInfo : STRUCT
	    SafetyNbr : HDINT;
	    ModuleType : t_e_ModuleType;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_InterfaceFrameInfo : STRUCT
	    ModuleInfo : t_ModuleInfo;
	    InterfaceCRC : HDINT;
	    IFPdoLen : USINT;
	    OffsetInDomainModule : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_IFInfo : STRUCT
	    IsResponse : BOOL;
	    aModuleInfos : ARRAY [0..MAX_MODULES_IN_OTHER_DOMAINS-1] OF t_InterfaceFrameInfo;
	  END_STRUCT;
#pragma pack(pop)
	  t_InitSSW :
	  (
	    _NotMaster,
	    _ClearRoutingInfos:=5,
	    _FirstWait4SynchronManagingNodes,
	    _FirstWait4SynchronSubdomains,
	    _SendDomainRoutingInfo,
	    _SetConnectionOk,
	    _Wait4ReInit:=10,
	    _CheckLocalCPUConfigs:=13,
	    _Wait4SynchronManagingNodes:=15,
	    _Wait4SynchronSubdomains:=20,
	    _Wait4ConfigFlush:=25,
	    _SendDomainNr:=30,
	    _Wait4DomainInfos:=32,
	    _Wait4CPUConfigs:=35,
	    _SendInterfaceConfigs:=40,
	    _Wait4InterfaceConfigs:=45,
	    _SendNextUnsafeConfig:=50,
	    _Wait4UnsafeConfigAck:=55,
	    _SendNextPDO:=60,
	    _Wait4PDOAcks:=65,
	    _Wait4CopyCmdStart:=70,
	    _NoDomains:=75,
	    _FinishInitialisation:=80,
	    _InitFinished:=85
	  )$UDINT;
#pragma pack(push, 1)
	  t_SafetyComponent : STRUCT
	    ModuleType : t_e_ModuleType;
	    pThis : pVirtualBase;
	    SafetyNbr : HDINT;
	    FW_Version : HDINT;
	    FPGA_Version : HSINT;
	    NewConfigType : t_ConfigStateType;
	    InfoBits : BSINT
	    [
	      1 OnlyInputs,
	      6 IsOptional,
	    ];
	    PathLen : USINT;
	    pPath : ^USINT;
	    pNext : ^t_SafetyComponent;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_LocalIFs : STRUCT
	    InterfaceCRC : HDINT;
	    pSafetyModule : ^t_SafetyComponent;
	  END_STRUCT;
#pragma pack(pop)
	  t_LogBufCmd :
	  (
	    Cmd_None:=0,
	    Cmd_StartTimeSync:=10,
	    Cmd_SetNewSyncMode:=20,
	    Cmd_InitFinished:=21,
	    Cmd_SDO2Module:=22,
	    Cmd_TDO2Module:=23,
	    Cmd_GetSafetyNr:=24,
	    Cmd_AddInputPDO:=25,
	    Cmd_AddOutputPDO:=26,
	    Cmd_RemoveInputPDO:=27,
	    Cmd_SyncCheck:=30,
	    Cmd_IFPossible:=31,
	    Cmd_PDO_MemUsageWr:=32,
	    Cmd_PDO_MemUsageRd:=33,
	    Cmd_PDO_CopyMode:=34,
	    Cmd_TimeSyncFinished:=40,
	    Cmd_NewSafetyProject:=41,
	    Cmd_AddModule:=50,
	    Cmd_AddModuleInfo:=51,
	    Cmd_SDO2Manager:=52,
	    Cmd_TDO2Manager:=53,
	    Cmd_CPU_Cfg2Manager:=54,
	    Cmd_UnsafeCfg2Manager:=55,
	    Cmd_NewCfgType:=56,
	    Cmd_Disconnect:=60,
	    Cmd_AddManagingInfo:=61,
	    Cmd_TDO_TokenFwd:=70,
	    Cmd_DomainNrSend:=71,
	    Cmd_DomainNrFwd:=72,
	    Cmd_StopAndFlushCfg:=73,
	    Cmd_StoppedAndFlushed:=74,
	    Cmd_SpreadCfgAndStart:=75,
	    Cmd_SubdomainsSynchron:=76,
	    Cmd_CPU_Cfg2MasterMng:=77,
	    Cmd_PDO_MappingBroadcast:=78,
	    Cmd_PDO_MappingAck:=79,
	    Cmd_PDO_SafetyNr2Dom:=80,
	    Cmd_SDO_InitInformation:=81,
	    Cmd_ToP_SDO2Master:=82,
	    Cmd_ToP_SDO2Module:=83,
	    Cmd_SendUnsafeVarCfg:=84,
	    Cmd_UnsafeVarCfgAck:=85,
	    Cmd_UnsafeVarNewValue:=86,
	    Cmd_SendSubdomainSync:=87,
	    Cmd_IF_ModuleInfo:=90
	  )$UINT;
#pragma pack(push, 1)
	  t_LogBuf : STRUCT
	    OldState : t_InitSSW;
	    NewState : t_InitSSW;
	    Command : t_LogBufCmd;
	    TimeSinceLastLog_us : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_LogMsgs : BDINT
	  [
	    1 NoTDOTargetToManager,
	    2 NoTDOTargetToModule,
	    3 InvalidCommandReceived,
	    4 UnkownCopySource,
	    5 InvalidIFConfiguration,
	    6 TooManyOptionalMissing,
	  ];
#pragma pack(push, 1)
	  t_ManagingComponent : STRUCT
	    ModuleType : t_e_ModuleType;
	    pThis : pVirtualBase;
	    InfoBits : BINT
	    [
	      1 HasBeenFlushed,
	      2 NewTimeSyncPossible,
	      3 IsSynchron,
	      4 SubDomainsSynchron,
	      5 GotIFInfo,
	      6 IsOptional,
	      8 IsConnectionToMaster,
	      9 LocalConfigReady,
	    ];
	    DomainNr : USINT;
	    SubDomainsUsed : USINT;
	    SubDomainNr : ARRAY [0..MAX_DOMAINS_ALLOWED-1] OF INT;
	    ModuleNo : USINT;
	    ModuleInfo : ARRAY [0..MAX_MODULES_IN_OTHER_DOMAINS-1] OF t_ModuleInfo;
	    PDOWriteMemUsed : UDINT;
	    PDOWriteMemAvailable : UDINT;
	    pPDOWriteSpace : ^USINT;
	    pPDOWriteSpaceDPRAM : ^USINT;
	    ud_HandlePDOWriteSpaceDPRAM : UDINT;
	    PDOWriteSpaceDPRAM : DINT;
	    PDOReadMemUsed : UDINT;
	    PDOReadMemAvailable : UDINT;
	    pPDOReadSpace : ^USINT;
	    pPDOReadSpaceDPRAM : ^USINT;
	    ud_HandlePDOReadSpaceDPRAM : UDINT;
	    pModulePath : ^USINT;
	    pNext : ^t_ManagingComponent;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_PDOModuleInfo : STRUCT
	    pPDOMem : ^USINT;
	    pPDOMemDPRAM : ^USINT;
	    SafetyNbr : HDINT;
	    DomainNr : USINT;
	    PathLen : UINT;
	    pPath : ^USINT;
	    HandlePDODPRAM : UDINT;  //! <Type Comment="Handle of the VARAN DO. &#13;&#10;Needed to be passed through with Payload Support because the Handle can not be derived from pPDOMemDPRAM in this case.&#13;&#10;The Handle is needed to start/stop the DO and for creating the Payload Move DO." Name="t_PDOModuleInfo.HandlePDODPRAM"/>
	    OffsetPDODPRAM : UDINT;  //! <Type Comment="Offset the VARAN DO. &#13;&#10;Needed for creating the Payload Move DO." Name="t_PDOModuleInfo.OffsetPDODPRAM"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_PDOElement : STRUCT
	    PDO_ID : USINT;
	    Length : USINT;
	    ThisDomainsRole : t_SourceDest;
	    SourceInfo : t_PDOModuleInfo;
	    DestInfo : t_PDOModuleInfo;
	    pSafety : ^t_SafetyComponent;
	    CopyCmdIndex : INT;
	    pManagingSource : ^t_ManagingComponent;
	    pManagingDest : ^t_ManagingComponent;
	  END_STRUCT;
#pragma pack(pop)
	  t_pManagingComponent : ^t_ManagingComponent;
#pragma pack(push, 1)
	  t_SDOLog : STRUCT
	    SDOCmd : t_AsyCMDType;
	    Cmd : USINT;
	    IsResponse : BOOL;
	  END_STRUCT;
#pragma pack(pop)
	  t_TimeSyncInfoBits : BSINT
	  [
	    1 IsConnectionToMaster,  //! <Type Comment="if the this-pointer matches the this-pointer of the master connection" Name="t_TimeSyncInfoBits.IsConnectionToMaster"/>
	    2 IsManagingModule,
	    3 IsInterfaceDomain,
	    4 IsMissingOptional,
	  ];
#pragma pack(push, 1)
	  t_TimeSyncElement : STRUCT
	    pThis : pVirtualBase;
	    InfoBits : t_TimeSyncInfoBits;
	    pManaging : ^t_ManagingComponent;
	    pSafety : ^t_SafetyComponent;
	    pPrev : ^t_TimeSyncElement;
	    pNext : ^t_TimeSyncElement;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassState 	: SvrChCmd_DINT;
	LoginCnt 	: SvrCh_DINT;
	MinSyncDuration 	: SvrCh_UDINT;
	SyncDuration 	: SvrCh_UDINT;
	MaxSyncDuration 	: SvrCh_UDINT;
  //Clients:
	To_HwControl 	: CltChCmd_HwControlBase;
	To_StdLib 	: CltChCmd__StdLib;
	SafetyDomainTimeout 	: CltCh_UDINT;
  //Variables:
		InitSSW 	: t_InitSSW;			//! <Variable Comment="initialisation state machine (mostly relevant for the master) which is handled in CyWork()" Name="InitSSW"/>
		us_FirstScan 	: USINT;
		pFirstManagingInterfaceComponent 	: ^t_ManagingComponent;			//! <Variable Comment="linked list with all logged in management modules (for interface frames)" Name="pFirstManagingInterfaceComponent"/>
		pFirstSafetyComponent 	: ^t_SafetyComponent;			//! <Variable Comment="linked list with all logged in safety modules" Name="pFirstSafetyComponent"/>
		pMasterConnection 	: ^t_ManagingComponent;			//! <Variable Comment="managing module whiich connects us to the master (for faster sending of messages to the master)" Name="pMasterConnection"/>
		us_SafetyModuleNo 	: USINT;			//! <Variable Comment="number of safety modules logged in" Name="us_SafetyModuleNo"/>
		b_NewSyncMode 	: BOOL;			//! <Variable Comment="remembers if there is a new time synchronisation (master safetymanager controls time synchronisation of single safety modules) or an old (every single safety module controls it&apos;s own synchronisation)" Name="b_NewSyncMode"/>
		LastTimeSyncThis 	: pVirtualBase;			//! <Variable Comment="remembers the this pointer of the module where the time synchronisation is active" Name="LastTimeSyncThis"/>
		TimeSyncTimeStamp 	: UDINT;			//! <Variable Comment="ms timestamp of last time a module finished synchronisation or when the synchronisation process started" Name="TimeSyncTimeStamp"/>
		TimeSyncCycleStart 	: UDINT;			//! <Variable Comment="ms timestamp of when we started the time synchronisation cycle (the first module of the master)" Name="TimeSyncCycleStart"/>
		b_CheckTimeSyncTimeout 	: BOOL;			//! <Variable Comment="this variable tells if the timeout of time synchronisation is active or not" Name="b_CheckTimeSyncTimeout"/>
		pNeedThisClass4GlobVarDef 	: ^SafetyCDIAS_Base;			//! <Variable Comment="this variable is needed to make a dependency to class SafetyCDIAS_Base, because we need the global variable declaration of it" Name="pNeedThisClass4GlobVarDef"/>
		pHardwareTree 	: ^LSL_HARDWARETREE;			//! <Variable Comment="this variable is needed to use the hardwaretree commands of OS" Name="pHardwareTree"/>
		ActPDO_ID 	: USINT;			//! <Variable Comment="actual PDO ID, to definitely identify a PDO" Name="ActPDO_ID"/>
		ConfigNo 	: USINT;			//! <Variable Comment="number of configs stored in pConfigs pointer" Name="ConfigNo"/>
		pConfigs 	: ^t_CfgListElem;			//! <Variable Comment="linked list with the configurations of all safety CPUs in the system" Name="pConfigs"/>
		SafeCPU_Nbr_No 	: USINT;
		aSafetyCPU_Nbr : ARRAY [0..99] OF HDINT;

		LocalCPUNo 	: USINT;
		LocalCPUCfgNo 	: USINT;
		pFirstLocalCPUCfg 	: ^t_LocalCfgListElem;
		pActualSendCfg 	: ^t_CfgListElem;
		pActualSendPDO 	: ^t_PdoListElem;
		PDOElementNo 	: UDINT;
		aPDOElements : ARRAY [0..MAX_PDO_CONFIGS-1] OF t_PDOElement;

		p_KernelLog 	: ^DINT;
		InterfaceFrameNo 	: DINT;
		aInterfaceFrameInfos : ARRAY [0..MAX_MODULES_IN_OTHER_DOMAINS-1] OF t_InterfaceFrameInfo;

		b_StartTimeSync 	: BOOL;
		b_SlaveSyncActive 	: BOOL;
		UnsafeSendNbr 	: UDINT;
		ud_InitTimeOut 	: UDINT;
		CopyCmdsAvailable 	: USINT;			//! <Variable Comment="number of copy commands which have been added to VM" Name="CopyCmdsAvailable"/>
		CopyCmdsUsed 	: USINT;			//! <Variable Comment="number of copy commands used in the VM (can be maximum the number of available copy commands)" Name="CopyCmdsUsed"/>
		aCopyCmds : ARRAY [0..MAX_PDO_COPY_CMDS-1] OF t_CopyCmdDO;

		b_SynchroTimeoutSet 	: BOOL;
		b_SyncTimeoutExceeded 	: BOOL;
		SynchroTimeout 	: UDINT;
		DomainInfoSendTime 	: UDINT;
		pFirstTimeSyncElement 	: ^t_TimeSyncElement;
		pActTimeSyncElement 	: ^t_TimeSyncElement;
		pMasterTimeSyncElement 	: ^t_TimeSyncElement;
		OldInitSSW 	: t_InitSSW;
		LogBuf : ARRAY [0..LogBufferSize-1] OF t_LogBuf;

		ActLogIndex 	: UDINT;
		TimeStampLastLog_us 	: UDINT;
		LocalIFNo 	: USINT;
		aLocalIFs : ARRAY [0..MAX_INTERNAL_IF_MODULES-1] OF t_LocalIFs;

		s_TimeRt 	: t_TimeMeasurementVaran;
		s_TimeRtPostScan 	: t_TimeMeasurementVaran;
		s_TimeCy 	: t_TimeMeasurementVaran;
		SyncTimeoutCounter 	: UDINT;
		bd_LogRtMessagesInCy 	: t_LogMsgs;
		ud_SizeTempMemCy 	: UDINT;
		pTempMemCy 	: pVoid;
		IsTimeSyncMaster 	: DINT;
  //Functions:
	
	FUNCTION SafetyManager
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION AddModule
		VAR_INPUT
			pPara 	: ^CmdStruct;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION AddSafetyModule
		VAR_INPUT
			ModuleType 	: t_e_ModuleType;
			pThis 	: pVirtualBase;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION AddManagingModule
		VAR_INPUT
			ModuleType 	: t_e_ModuleType;
			pThis 	: pVirtualBase;
			pObjectPath 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION AddSafetyNbr
		VAR_INPUT
			pThis 	: pVirtualBase;
			ud_SafetyNbr 	: UDINT;
			FirmwareVersion 	: HDINT;
			FPGAVersion 	: HSINT;
			PathLen 	: USINT;
			pPath 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GetModuleTypeNo
		VAR_INPUT
			ModuleType 	: t_e_ModuleType;
		END_VAR
		VAR_OUTPUT
			ModuleNo 	: DINT;
		END_VAR;
	
	FUNCTION NewTimeSyncPossible
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION SetNewSyncMode
		VAR_INPUT
			b_NewMode 	: BOOL;
		END_VAR;
	
	FUNCTION TellAllSafetyModules
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR;
	
	FUNCTION TellAllInterfaceManagingModules
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR;
	
	FUNCTION StartTimeSync;
	
	FUNCTION NextTimeSyncModule;
	
	FUNCTION GiveTokenToNextModule
		VAR_OUTPUT
			RestartCycle 	: BOOL;
		END_VAR;
	
	FUNCTION AllManagingNodesSynchron
		VAR_OUTPUT
			AllReady 	: BOOL;
		END_VAR;
	
	FUNCTION AddConfiguration
		VAR_INPUT
			Length 	: UINT;
			pData 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION FreeCfgLists;
	
	FUNCTION AddOwnCPUsToList;
	
	FUNCTION AllCPUConfigsArrived
		VAR_OUTPUT
			AllReady 	: BOOL;
		END_VAR;
	
	FUNCTION AddLocalCPUCfg
		VAR_INPUT
			Length 	: UINT;
			pData 	: ^void;
		END_VAR;
	
	FUNCTION RemoveLocalCPUCfg
		VAR_INPUT
			SafetyNumber 	: HDINT;
		END_VAR;
	
	FUNCTION SendLocalCfgsToMaster;
	
	FUNCTION BroadCastActPDO;
	
	FUNCTION IsAffectedByPDO
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pSourceDest 	: ^t_SourceDest;
			pSafetyNbr 	: ^HDINT;
		END_VAR
		VAR_OUTPUT
			IsAffected 	: BOOL;
		END_VAR;
				//! <Function Comment="for SDOs and TDOs" Name="GetDestManagingOfDO"/>
	FUNCTION GetDestManagingOfDO
		VAR_INPUT
			pDO 	: ^SafetyCDIAS_Base::SDOHeader;
		END_VAR
		VAR_OUTPUT
			pDestManaging 	: ^t_ManagingComponent;
		END_VAR;
	
	FUNCTION GetDestSafetyOfDO
		VAR_INPUT
			pDO 	: ^SafetyCDIAS_Base::SDOHeader;
		END_VAR
		VAR_OUTPUT
			pDestSafety 	: ^t_SafetyComponent;
		END_VAR;
	
	FUNCTION IsOurPdoInfo
		VAR_INPUT
			pPara 	: ^CmdStruct;
		END_VAR
		VAR_OUTPUT
			ItsMine 	: BOOL;
		END_VAR;
	
	FUNCTION CheckTopSDO
		VAR_INPUT
			pPara 	: ^CmdStruct;
		END_VAR;
	
	FUNCTION TopSDODest
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			IsDestDomain 	: BOOL;
		END_VAR;
	
	FUNCTION PDOLengthCorrection;
	
	FUNCTION DoublePDOEntry
		VAR_INPUT
			NewPDO 	: t_PdoCfg;
			pNewCfg 	: ^t_CfgListElem;
		END_VAR
		VAR_OUTPUT
			IsDoubleEntry 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL LogError
		VAR_INPUT
			e_msg 	: ^CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL MyTrace
		VAR_INPUT
			pFormat 	: ^CHAR;
			pTxt0 	: ^CHAR;
			pTxt1 	: ^CHAR;
			pTxt2 	: ^CHAR;
		END_VAR;
	
	FUNCTION StoreInterfaceRoutingList
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR;
	
	FUNCTION AllInterfaceCfgsArrived
		VAR_OUTPUT
			AllReady 	: BOOL;
		END_VAR;
	
	FUNCTION SendInterfaceConfigs
		VAR_INPUT
			DestinationThis 	: pVirtualBase := NIL;
			IsResponse 	: BOOL := FALSE;
		END_VAR;
	
	FUNCTION GetIFInfoByCRC
		VAR_INPUT
			InterfaceCRC 	: HDINT;
			pMemOffset 	: ^UDINT := NIL;
			pLength 	: ^USINT := NIL;
		END_VAR
		VAR_OUTPUT
			SafetyNbr 	: HDINT;
		END_VAR;
	
	FUNCTION SetTimeout;
	
	FUNCTION CheckTimeout;
	
	FUNCTION AllNonOptionalIFDomainsSynchron
		VAR_OUTPUT
			EverythingSynchron 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL LogValue
		VAR_INPUT
			pString 	: ^CHAR;
			Value 	: UDINT;
			Value2 	: UDINT := 16#FFFFFFFF;
			Value3 	: UDINT := 16#FFFFFFFF;
		END_VAR;
	
	FUNCTION VIRTUAL GetThisViaServerName
		VAR_INPUT
			pObjectDotServer 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			ThisPtr 	: pVoid;
		END_VAR;
	
	FUNCTION GetNewMovDO
		VAR_OUTPUT
			Index 	: INT;
		END_VAR;
	
	FUNCTION CheckCPUConfigs
		VAR_OUTPUT
			ConfigsOK 	: BOOL;
		END_VAR;
	
	FUNCTION ClearRoutingInformations;
	
	FUNCTION CheckPDORecycle
		VAR_INPUT
			SourceDest 	: t_SourceDest;
			pNewPDO 	: ^t_PDOElement;
		END_VAR
		VAR_OUTPUT
			pRecyclePDO 	: ^t_PDOElement;
		END_VAR;
	
	FUNCTION AddManagingInfo
		VAR_INPUT
			pPara 	: ^CmdStruct;
		END_VAR;
	
	FUNCTION CheckModuleUsage
		VAR_INPUT
			Length 	: UINT;
			pData 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION SetModuleUsed
		VAR_INPUT
			PathLen 	: UINT;
			pPath 	: ^USINT;
			IgnoreOptional 	: BOOL;
			IsOptional 	: BOOL;
			IsInterfaceDomain 	: BOOL;
		END_VAR;
	
	FUNCTION CreateTimeSyncList;
	
	FUNCTION AddTimeSyncElement
		VAR_INPUT
			pManaging 	: ^t_ManagingComponent;
			pSafety 	: ^t_SafetyComponent;
			IsInterfaceDomain 	: BOOL;
		END_VAR;
	
	FUNCTION CreateVirtualPDOs;
	
	FUNCTION AddVirtualPDOToCfg
		VAR_INPUT
			pCfg 	: ^t_CfgListElem;
			pNewPDO 	: ^t_PdoCfg;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION AddToLocalIFs
		VAR_INPUT
			pHelpPDO 	: ^t_PdoCfg;
		END_VAR;
	
	FUNCTION IFInfoNotArrivedYet
		VAR_INPUT
			pThis 	: pVirtualBase;
		END_VAR
		VAR_OUTPUT
			InfoNotAvailable 	: BOOL;
		END_VAR;
	
	FUNCTION StartTimeMeasurement
		VAR_INPUT
			usMode (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION StopTimeMeasurement
		VAR_INPUT
			usMode (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION AnyIFDomainSynchron
		VAR_OUTPUT
			AnythingSynchron 	: BOOL;
		END_VAR;
	
	FUNCTION LocalIFsAvailable
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION IsCPUModule
		VAR_INPUT
			ModuleType 	: t_e_ModuleType;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GetMasterConnection
		VAR_OUTPUT
			pMasterConn 	: ^t_ManagingComponent;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassState::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _StdLib
#pragma usingLtd HwControlBase


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SafetyManager::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SAFETYMANAGER
1$UINT, 42$UINT, (SIZEOF(::SafetyManager))$UINT, 
5$UINT, 3$UINT, 0$UINT, 
TO_UDINT(1799751072), "SafetyManager", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::SafetyManager.ClassState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1096059024), "ClassState", 
(::SafetyManager.LoginCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3842434630), "LoginCnt", 
(::SafetyManager.MinSyncDuration.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1133920085), "MinSyncDuration", 
(::SafetyManager.SyncDuration.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1910597126), "SyncDuration", 
(::SafetyManager.MaxSyncDuration.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1680693348), "MaxSyncDuration", 
//Clients:
(::SafetyManager.To_HwControl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1012711711), "To_HwControl", TO_UDINT(1193052171), "HwControlBase", 1$UINT, 10$UINT, 
(::SafetyManager.To_StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2139173287), "To_StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::SafetyManager.SafetyDomainTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1863305286), "SafetyDomainTimeout", 
END_FUNCTION


#define USER_CNT_SafetyManager 4

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SafetyManager] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SafetyManager::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_SafetyManager, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #LogError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #MyTrace();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #LogValue();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #GetThisViaServerName();

#pragma warning (default : 74)
	ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MinSyncDuration.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF MinSyncDuration.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MaxSyncDuration.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF MaxSyncDuration.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= SafetyManager();

END_FUNCTION

#pragma usingLtd SafetyCDIAS_Base

//{{LSL_IMPLEMENTATION
VAR_EXTERNAL
  pSafetyManagerThis   : pVirtualBase;
  b_SafetyOnLocalCDIAS : BOOL;
  ModuleSyncNo : DINT; // Number of modules which need to be synchron before everyone sends the set bus ready signal
END_VAR


FUNCTION VIRTUAL GLOBAL SafetyManager::Init
  VAR
  	MasterObjects : DINT;
  	tempCmd    : CmdStruct;
    _result    : results;
  END_VAR

  us_FirstScan += 1;

  case us_FirstScan of
//**********************************************************************************************************************************************************
    1:
      // in first init we ensure that the pointer is NIL (and not any value that is in the memory)
      pSafetyManagerThis := NIL;
      
      SafetyDomainTimeout := SafetyDomainTimeout.Read();

//**********************************************************************************************************************************************************    
    2:
      if pSafetyManagerThis = NIL then
        pSafetyManagerThis := THIS;
//        pVaranManager := (To_HwControl.AddSafetyManager(pThis:=THIS))$^VaranManager;
      else
        LogError("(SafetyManager::Init) Only 1 Instance of SafetyManager possible");
        ClassState := -5;
      end_if;
//**********************************************************************************************************************************************************
  // in init nr.3 the managing master objects log in
  // in init nr.4 the managing slave objects log in (to be the last one called in the token ring => give the token back to master)
//**********************************************************************************************************************************************************
    5:
      // now we check if we're on the topmost level
      MasterObjects := GetModuleTypeNo(_VBC021Slave) + GetModuleTypeNo(_VaranManager4VMC);
      if MasterObjects = 0 then
        // if there are no modules which makes us a slave => we're the master
        IsTimeSyncMaster := 1;
        
        if pFirstManagingInterfaceComponent then
          // if there are more domains => initialize them
          InitSSW := _ClearRoutingInfos;
        else
          // otherwise just finish the configuration
          InitSSW := _SetConnectionOk;
        end_if;
      elsif MasterObjects > 1 then
        // it's not possible to be a slave to more than 1 master (sync forwarding doesn't work then)
        LogError("(SafetyManager::Init) A Slave-System can't have more than 1 Master-System! Please check your HW class configuration!");
        ClassState := -6;
      else
        // we're sync-slave when using interface frames
       
       GetMasterConnection();
       
        // if there are more domains => initialize them
        InitSSW := _ClearRoutingInfos;
      end_if;

//**********************************************************************************************************************************************************
    12:
      // if no safety modules are logged in, disable the tasks
      if (pFirstSafetyComponent = NIL) & (pFirstManagingInterfaceComponent = NIL) then
//        To_HwControl.DisableSafetyManager();
        ClassState := 0;
      else
        // Install the callbacks
        tempCmd.uiCmd := CMD_HWCONTROL_LOGIN;
        tempCmd.aPara[0] := THIS$DINT;
        tempCmd.aPara[1] := CALL_OPTION_RT_PRESCAN  OR
                            CALL_OPTION_RT_POSTSCAN OR
                            CALL_OPTION_CYCLIC;
        
        if To_HwControl.NewInst(#tempCmd, #_result) <> READY then
          LogError("(SafetyManager::Init) Failed to Install callbacks at HwControl");
          ClassState := -13;
        end_if;
      end_if;

//**********************************************************************************************************************************************************
  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyManager::ClassState::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  VAR
  	i                   : UDINT;
    pHelpManaging       : ^t_ManagingComponent;
    pHelpSafety         : ^t_SafetyComponent;
    pHelpHDINT          : ^HDINT;
    pHelpTimeSync       : ^t_TimeSyncElement;
    pDO 	              : ^SafetyCDIAS_Base::SDOHeader;
    IsOptionalIFDomain  : BOOL;
  END_VAR

#ifdef SAFETY_DEBUG_LOGGING_ACTIVATED
  // don't log the TDO and SDO events (would be too much for logging)
	CASE pPara^.uiCmd OF
    CMD_SM_TDO_TO_MANAGER, CMD_SM_TDO_TO_MODULE, CMD_SM_TDO_TOKEN_FWD, CMD_SM_TIME_SYNC_FINISHED,
    CMD_SM_SDO_TO_MANAGER, CMD_SM_SDO_TO_MODULE, CMD_SM_TOP_SDO_TO_MASTER, CMD_SM_TOP_SDO_TO_MODULE:
  ELSE
#ifdef SAFETY_DEBUG_TRACING_ACTIVATED
    LogValue(pString:="(SafetyManager::ClassState::NewInst) Incoming Command: {0}", Value:=pPara^.uiCmd);  
#endif
    LogBuf[ActLogIndex].NewState := _NotMaster;
    LogBuf[ActLogIndex].OldState := _NotMaster;
    LogBuf[ActLogIndex].Command := pPara^.uiCmd$t_LogBufCmd;
    LogBuf[ActLogIndex].TimeSinceLastLog_us := OS_READMICROSEC();
    LogBuf[ActLogIndex].TimeSinceLastLog_us -= TimeStampLastLog_us;
    TimeStampLastLog_us := OS_READMICROSEC();
    if ActLogIndex = (LogBufferSize - 1) then
      ActLogIndex := 0;
    else
      ActLogIndex += 1;
    end_if;
  END_CASE;
#endif

	CASE pPara^.uiCmd OF
//**********************************************************************************************************************************************************
    CMD_SM_ADD_MODULE:
      pResult^.aData[0]$BOOL := AddModule( pPara );

      pResult^.uiLng := sizeof(pResult^.uiLng) + sizeof(BOOL);
  
//**********************************************************************************************************************************************************
    CMD_SM_ADD_MODULE_INFO:
      pResult^.aData[0]$BOOL := AddSafetyNbr( pThis           := pPara^.aPara[0]$pVirtualBase
                                            , ud_SafetyNbr    := pPara^.aPara[1]$UDINT
                                            , FirmwareVersion := pPara^.aPara[2]$HDINT
                                            , FPGAVersion     := pPara^.aPara[3]$HSINT
                                            , PathLen         := pPara^.aPara[4]$USINT
                                            , pPath           := pPara^.aPara[5]$^USINT
                                            );

      pResult^.uiLng := sizeof(pResult^.uiLng) + sizeof(BOOL);
      
//**********************************************************************************************************************************************************
    CMD_SM_ADD_MANAGING_INFO:
      AddManagingInfo(pPara);

//**********************************************************************************************************************************************************
    CMD_SM_TIME_SYNC_FINISHED:
      // check if the time synchronisation is still active
      if pActTimeSyncElement then      
        NextTimeSyncModule();
      end_if;
      
//**********************************************************************************************************************************************************
    CMD_SM_SDO_TO_MANAGER:
      pDO := (pPara^.aPara[1])$^SafetyCDIAS_Base::SDOHeader;
    
      // check if it's addressed via topology path
      if (pDO^.StdHeader.Typ AND SSDO_MASK_TYPE) = FRM_TYPECODE_SSDO_MOD_TP then
        // if so, send it to the master, because only he knows who is the addressee
    
        pPara^.aPara[2] := this$DINT;
        
        // change the command, because now we forward it to the master
        pPara^.uiCmd := CMD_SM_TOP_SDO_TO_MASTER;

        // call our own newinst to forward the message to the master
        NewInst(pPara, pResult);
      else
        // change the command, because now we forward it to the receiver
        pPara^.uiCmd := CMD_SM_SDO_TO_MODULE;
      
        // check if we got a module which could be the destination of this
        pHelpManaging := GetDestManagingOfDO(pDO);

        if pHelpManaging then
          if pHelpManaging^.InfoBits.IsSynchron then
            pHelpManaging^.pThis^.NewInst(pPara, pResult);
          end_if;
        else
          // search in the local safety modules
          pHelpSafety := GetDestSafetyOfDO(pDO);
          
          if pHelpSafety then
            pHelpSafety^.pThis^.NewInst(pPara, pResult);
          else
            LogError("(SafetyManager::ClassState::NewInst) Couldn't find target of SDO (CMD_SM_SDO_TO_MANAGER)");
            LogValue(pString:="SrcAddr: {0} / DestAddr: {1}", Value:=pDO^.SrcAdr, Value2:=pDO^.DstAdr);
          end_if;
        end_if;
      end_if;

//**********************************************************************************************************************************************************
    CMD_SM_SDO_TO_MODULE:
      pDO := (pPara^.aPara[1])$^SafetyCDIAS_Base::SDOHeader;

      // check if we got a module which could be the destination of this
      pHelpSafety := GetDestSafetyOfDO(pDO);
      
      if pHelpSafety then
        pHelpSafety^.pThis^.NewInst(pPara, pResult);
      else
        // if we have no such module or it's addressed via topology path we check if there is a domain which knows that module
        pHelpManaging := GetDestManagingOfDO(pDO);

        // if we found a domain for this module, forward it
        if pHelpManaging then
          if pHelpManaging^.InfoBits.IsSynchron then
            pHelpManaging^.pThis^.NewInst(pPara, pResult);
          end_if;
        else
          LogError("(SafetyManager::ClassState::NewInst) Couldn't find target of SDO (CMD_SM_SDO_TO_MODULE)");
          LogValue(pString:="SrcAddr: {0} / DestAddr: {1}", Value:=pDO^.SrcAdr, Value2:=pDO^.DstAdr);
        end_if;
      end_if;

//**********************************************************************************************************************************************************
    CMD_SM_TOP_SDO_TO_MASTER:
      // if we're the master, we check the message and send the sdo with uncompressed path to it's addressee
      CheckTopSDO(pPara);

//**********************************************************************************************************************************************************
    CMD_SM_TOP_SDO_TO_MODULE:
      // if this is the destination domain, send the SDO to the right module
      if TopSDODest(pPara, pResult) = FALSE then

      end_if;

//**********************************************************************************************************************************************************
    CMD_SM_TDO_TOKEN_FWD:
      // we sent the token to our slave and now we got it back
      if b_SlaveSyncActive then
        b_SlaveSyncActive := FALSE;
        
        // if we have no act time sync element we're maybe reconfiguring the system
        if pActTimeSyncElement then      
          // if we started the syncing, take the next module
          NextTimeSyncModule();
        end_if;
      else
        // otherwise we got the token from a superior system => start timesyncing
        b_StartTimeSync := TRUE;
      end_if;
      
//**********************************************************************************************************************************************************      
    CMD_SM_TDO_TO_MANAGER:
      // change the command, because now we forward it to the receiver
      pPara^.uiCmd := CMD_SM_TDO_TO_MODULE;

      // check if we got a module which could be the destination of this
      pHelpSafety := GetDestSafetyOfDO((pPara^.aPara[1])$^SafetyCDIAS_Base::SDOHeader);
      
      if pHelpSafety then
        pHelpSafety^.pThis^.NewInst(pPara, pResult);
      else
        pHelpManaging := GetDestManagingOfDO((pPara^.aPara[1])$^SafetyCDIAS_Base::SDOHeader);

        if pHelpManaging then
          if pHelpManaging^.InfoBits.IsSynchron then
            pHelpManaging^.pThis^.NewInst(pPara, pResult);
          end_if;
        else
          bd_LogRtMessagesInCy.NoTDOTargetToManager := TRUE;
        end_if;
      end_if;
    
//**********************************************************************************************************************************************************      
    CMD_SM_TDO_TO_MODULE:
      // check if we got a module which could be the destination of this
      pHelpSafety := GetDestSafetyOfDO((pPara^.aPara[1])$^SafetyCDIAS_Base::SDOHeader);
      
      if pHelpSafety then
        pHelpSafety^.pThis^.NewInst(pPara, pResult);
      else
        // if we have no such module or it's addressed via topology path we check if there is a domain which knows that module
        pHelpManaging := GetDestManagingOfDO((pPara^.aPara[1])$^SafetyCDIAS_Base::SDOHeader);

        // if we found a domain for this module, forward it
        if pHelpManaging then
          if pHelpManaging^.InfoBits.IsSynchron then
            pHelpManaging^.pThis^.NewInst(pPara, pResult);
          end_if;
        else
          bd_LogRtMessagesInCy.NoTDOTargetToModule := TRUE;
        end_if;
      end_if;

//**********************************************************************************************************************************************************      
    CMD_SM_DOMAIN_NR_SEND,
    CMD_SM_DOMAIN_NR_FWD:
      // remember to which domain the managing module connects us and tell the other managing modules (but with a different cmd because they are not next door neighbors)
      
//**********************************************************************************************************************************************************      
    CMD_SM_DISCONNECT:
      // a domain has lost it's connection to the actual domain
      
      // stop all available copy commands
      for i := 0 to (CopyCmdsAvailable-1) do
        aCopyCmds[i].pHandle^.ucCtrlStat := VARAN_DO_NO_RUN;
      end_for;        

      // check if it was an interface domain
      IsOptionalIFDomain := FALSE;
      if pFirstManagingInterfaceComponent then
        pHelpManaging := pFirstManagingInterfaceComponent;
        while pHelpManaging do
          if pHelpManaging^.pThis = pPara^.aPara[2]$pVirtualBase then
            if pHelpManaging^.InfoBits.IsOptional then
              IsOptionalIFDomain := TRUE;
#ifdef SAFETY_DEBUG_TRACING_ACTIVATED
              LogError("(SafetyManager::ClassState::NewInst) Disconnect of optional interface frame domain detected!");
#endif
            end_if;
            exit;
          end_if;
        
          pHelpManaging := pHelpManaging^.pNext;
        end_while;
      end_if;

      // if the disconnected domain was no optional interface domain => tell all other to disconnect and prepare for reinitialisation
      if IsOptionalIFDomain = FALSE then
        pPara^.aPara[0] := 0; // set length of further parameters to 0
        TellAllSafetyModules(pPara, pResult);
      end_if;

      // reset module sync no (no more modules synchron)
      ModuleSyncNo := 0;

      ClassState := 0;

      // wait until we're synchron again
      InitSSW := _ClearRoutingInfos;        

//**********************************************************************************************************************************************************      
    CMD_SM_NEW_SAFETY_PROJECT:
      // remove the old config from the local memory
      if pPara^.aPara[0] = 4 then
        RemoveLocalCPUCfg((pPara^.aPara[4]$^HDINT)^);
      end_if;
    
      // new safety project detected (different crc) => reinit the system (similar to disconnect)
      pPara^.uiCmd := CMD_SM_DISCONNECT;
      pPara^.aPara[0] := 0; // set length of further parameters to 0
      TellAllInterfaceManagingModules(pPara, pResult);  // tell all interface domains to reestablish connection (they need the safety number from the configuration)
      TellAllSafetyModules(pPara, pResult);             // tell all of our local safety modules that there's a new config => reinitialize

      ClassState := 0;      

      // restart initialisation (maybe we had no clue about interfaceframes when initialising the first time)
      InitSSW := _ClearRoutingInfos;        


//**********************************************************************************************************************************************************      
    CMD_SM_STOP_AND_FLUSH_CFG:
      // prevent interface-frame participants from flushing each other
      if pMasterConnection then

        // send all available local configurations to the master
        SendLocalCfgsToMaster();

        // the master tells us to stop working and flush our configuration => do it and tell our slaves
        InitSSW := _Wait4ConfigFlush;        
        SetTimeout();
      end_if;

//**********************************************************************************************************************************************************      
    CMD_SM_STOPPED_AND_FLUSHED:
      
      // if we're the master, we have to remember the safety numbers of the safe CPUs (without a safety number there's only 1 byte with the time sync info
      if (pPara^.aPara[0] > 1) then
      
        // set the pointer to the first safety number
        pHelpHDINT := (pPara^.aPara[1] + sizeof(BOOL))$^HDINT;
 
        for i := 1 to ((pPara^.aPara[0]$UDINT-1)/4) do
          aSafetyCPU_Nbr[SafeCPU_Nbr_No] := pHelpHDINT^;
          SafeCPU_Nbr_No += 1;
          pHelpHDINT += sizeof(HDINT);
        end_for;
      end_if;

//**********************************************************************************************************************************************************      
    CMD_SM_FIRST_CONNECT_READY:
      // tell everyone it's on!

      // prevent interface-frame participants from finishing each others initialisation
      if pMasterConnection then
        InitSSW := _SetConnectionOk;
      end_if;
            
//**********************************************************************************************************************************************************      
    CMD_SM_CPU_CFG_TO_MANAGER:     
      // if master or not we add the configuration to the local config memory, which is send on connect or disconnect&reconnect
      AddLocalCPUCfg((pPara^.aPara[0])$UINT, (pPara^.aPara[1])$^void);
        
//**********************************************************************************************************************************************************      
    CMD_SM_IF_MODULE_INFO: 
      // the interface domain sent us their safety-numbers
      
      // if we wait for this info or we did't receive the info of this domain yet
      if (* (InitSSW = _Wait4InterfaceConfigs) |*) (IFInfoNotArrivedYet(pPara^.aPara[2]$pVirtualBase)) then
        // if we wait for it => safe them
        StoreInterfaceRoutingList(pPara, pResult);
      end_if;

      // resend the info to the module, which sent us the info so that bootup order doesn't matter (only if the response info in the first byte is false)
      if (InitSSW >= _Wait4InterfaceConfigs) & ((pPara^.aPara[1]$^BOOL)^ = FALSE) then
        // if not and we already have the config of the other system => the other domain waits for our config => send it
        SendInterfaceConfigs(pPara^.aPara[2]$pVirtualBase, TRUE);
      end_if;
      
//**********************************************************************************************************************************************************      
    CMD_SM_NEW_CFG_TYPE:
      // search for the right safety component
      pHelpSafety := pFirstSafetyComponent;
      while pHelpSafety do
        // if we found it => remember the actual config type
        if pHelpSafety^.SafetyNbr = pPara^.aPara[0]$HDINT then
          pHelpSafety^.NewConfigType := pPara^.aPara[1]$t_ConfigStateType;
          exit;
        end_if;
        
        pHelpSafety := pHelpSafety^.pNext;
      end_while;      

//**********************************************************************************************************************************************************      
    CMD_SM_MODULE_DISCONNECT:
      // deactivate entry in time sync list (if it's there)

      if pFirstTimeSyncElement then
        // check if we got this already
        pHelpTimeSync := pFirstTimeSyncElement;
        repeat
          if pHelpTimeSync^.pSafety & (pHelpTimeSync^.pSafety^.pThis = pPara^.aPara[0]$pVirtualBase) then
            // found this pointer in time sync list
            
            // mark the module missing, if it's optional
            if pHelpTimeSync^.pSafety^.InfoBits.IsOptional then
              pHelpTimeSync^.InfoBits.IsMissingOptional := TRUE;
            end_if;

            // if the actual time syncing module has been disconnected => select the next one
            if pActTimeSyncElement = pHelpTimeSync then      
              NextTimeSyncModule();
            end_if;

            exit;
          end_if;

          if pHelpTimeSync^.pManaging & (pHelpTimeSync^.pManaging^.pThis = pPara^.aPara[0]$pVirtualBase)  then
            // found this pointer in time sync list

            // mark the module missing, if it's optional
            if pHelpTimeSync^.pManaging^.InfoBits.IsOptional then
              pHelpTimeSync^.InfoBits.IsMissingOptional := TRUE;
            end_if;

            // if the actual time syncing module has been disconnected => select the next one
            if pActTimeSyncElement = pHelpTimeSync then      
              NextTimeSyncModule();
            end_if;

            exit;
          end_if;
          
          pHelpTimeSync := pHelpTimeSync^.pNext;
        until (pHelpTimeSync = pFirstTimeSyncElement) end_repeat;      
      end_if;

//**********************************************************************************************************************************************************      
    CMD_SM_MODULE_RECONNECT:
      // reactivate entry in time sync list (if it's there)

      if pFirstTimeSyncElement then
        // check if we got this already
        pHelpTimeSync := pFirstTimeSyncElement;
        repeat
          if pHelpTimeSync^.pSafety & (pHelpTimeSync^.pSafety^.pThis = pPara^.aPara[0]$pVirtualBase) then
            // found this pointer in time sync list
            
            // unmark the module if it's optional and was missing
            if pHelpTimeSync^.InfoBits.IsMissingOptional then
              pHelpTimeSync^.InfoBits.IsMissingOptional := FALSE;
            end_if;

            exit;
          end_if;

          if pHelpTimeSync^.pManaging & (pHelpTimeSync^.pManaging^.pThis = pPara^.aPara[0]$pVirtualBase)  then
            // found this pointer in time sync list

            // unmark the module if it's optional and was missing
            if pHelpTimeSync^.InfoBits.IsMissingOptional then
              pHelpTimeSync^.InfoBits.IsMissingOptional := FALSE;
            end_if;

            exit;
          end_if;
          
          pHelpTimeSync := pHelpTimeSync^.pNext;
        until (pHelpTimeSync = pFirstTimeSyncElement) end_repeat;      
      end_if;
      
//**********************************************************************************************************************************************************      
    CMD_SM_POST_INIT_FINISHED: // post init is finished => time to get the configs of the safety CPUs
      // check all safety components for CPUs
      pHelpSafety := pFirstSafetyComponent;
      while pHelpSafety do
        // if it's a CPU
        if IsCPUModule(pHelpSafety^.ModuleType) then
          // forward the command
          pHelpSafety^.pThis^.NewInst(pPara, pResult);
        end_if;
        
        pHelpSafety := pHelpSafety^.pNext;
      end_while;
      
//**********************************************************************************************************************************************************      
  else
    bd_LogRtMessagesInCy.InvalidCommandReceived := TRUE;
	END_CASE;

#ifdef SAFETY_DEBUG_LOGGING_ACTIVATED
  if InitSSW <> OldInitSSW then
#ifdef SAFETY_DEBUG_TRACING_ACTIVATED
    LogValue(pString:="(SafetyManager::ClassState::NewInst) InitSSW changed from {0} to {1}", Value:=OldInitSSW, Value2:=InitSSW);
#endif
    LogBuf[ActLogIndex].NewState := InitSSW;
    LogBuf[ActLogIndex].OldState := OldInitSSW;
    LogBuf[ActLogIndex].Command := 0;
    LogBuf[ActLogIndex].TimeSinceLastLog_us := OS_READMICROSEC();
    LogBuf[ActLogIndex].TimeSinceLastLog_us -= TimeStampLastLog_us;
    TimeStampLastLog_us := OS_READMICROSEC();
    if ActLogIndex = (LogBufferSize - 1) then
      ActLogIndex := 0;
    else
      ActLogIndex += 1;
    end_if;
  end_if;
  OldInitSSW := InitSSW;
#endif

	ret_code := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyManager::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
		MyPara 	      : CmdStruct;
		MyResult	    : results;
  	pHelpSafety   : ^t_SafetyComponent;
  	pHelpManaging : ^t_ManagingComponent;
    pModuleInfo   : ^t_ModuleInfo;
    pTempMem      : ^void;
    i             : UDINT;
    Synchron      : BOOL;
    AllReady      : BOOL;
    pHelpCfg      : ^t_LocalCfgListElem;
    pHelpConfig   : ^t_CfgListElem;
    pPDOElement   : ^t_PDOElement;
  END_VAR

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
	StartTimeMeasurement(VARANTIME_CY);
#endif
//=================================================================================================

  case InitSSW of
//**********************************************************************************************************************************************************
    _NotMaster: // don't start any actions, because we're not the master. but if the master wants something from us, we help out

//**********************************************************************************************************************************************************
    _ClearRoutingInfos: // initialize the structures or clean up an old configuration
      ClearRoutingInformations();

      // reactivate the domain synchronicity timeout
      b_SynchroTimeoutSet := FALSE;

      InitSSW := _FirstWait4SynchronManagingNodes;

//**********************************************************************************************************************************************************
    _FirstWait4SynchronManagingNodes: // wait for managing nodes to be syncron (all nodes are optionaly for this case, the will be checked laiter again)
      if SafetyDomainTimeout & (b_SynchroTimeoutSet = FALSE) then
        b_SynchroTimeoutSet := TRUE;
        SynchroTimeout := ops.tAbsolute;
      end_if;
    
      Synchron := AllManagingNodesSynchron();
                                                        // we wait synchro timeout + 50ms (50ms time for the domains to give up trying: see AllManagingNodesSynchron method)
      if Synchron then// | (SafetyDomainTimeout & ((ops.tAbsolute - SynchroTimeout) > (SafetyDomainTimeout + 50))) then
        if b_SyncTimeoutExceeded then
          b_SyncTimeoutExceeded := FALSE;
          LogError("(SafetyManager::CyWork) Timeout for optional Domain exceeded! Initialisation will continue without it!");
        end_if;

        InitSSW := _SetConnectionOk;
      end_if;

//**********************************************************************************************************************************************************
    _SetConnectionOk:
      // send hw-connection ok to start SDOs
      MyPara.uiCmd := CMD_SM_FIRST_CONNECT_READY;
      MyPara.aPara[0] := 0; // length of parameters

      TellAllSafetyModules(#MyPara, #MyResult);
      
      InitSSW := _Wait4ReInit;

//**********************************************************************************************************************************************************
    _Wait4ReInit: // wait until all local CSCPs have a valid configuration before we wait to be synchron with other domains

      // add our local configurations if there are any
      SendLocalCfgsToMaster();
     
      // wait until we got a valid config of every local safety cpu
      if LocalCPUCfgNo = LocalCPUNo then
        AllReady := TRUE;

        if LocalCPUCfgNo then
          pHelpCfg := pFirstLocalCPUCfg;
          
          // for is used to ensure thread safety
          for i := 0 to (LocalCPUCfgNo-1) do
            if pHelpCfg^.ConfigSize = 0 then
              AllReady := FALSE;
              exit;
            end_if;
            
            pHelpCfg := pHelpCfg^.pNext;
          end_for;
        end_if;
        
        // if we have a config from every cscp, we start the initialisation
        if AllReady then
          InitSSW := _CheckLocalCPUConfigs;
        end_if;
      else
        InitSSW := _SendInterfaceConfigs;
      end_if;

//**********************************************************************************************************************************************************
    _CheckLocalCPUConfigs: // check for unused and optional modules in the local configurations (needed for correct time synchronisation)
      // if we have a configuration of every safety cpu => check if the managing modules are optional or any of the safety/managing components is unused (not involved in any PDO)
      if LocalCPUCfgNo = LocalCPUNo then

        // set the IsOptional-Bit of all modules (safety and managing components) to TRUE
        // in CheckModuleUsage the the non-optional will get the IsOptional-Bit set to FALSE
        pHelpSafety := pFirstSafetyComponent;
        while pHelpSafety do
          pHelpSafety^.InfoBits.IsOptional    := TRUE;
          
          pHelpSafety := pHelpSafety^.pNext;
        end_while;

        pHelpManaging := pFirstManagingInterfaceComponent;
        while pHelpManaging do
          pHelpManaging^.InfoBits.IsOptional    := TRUE;

          pHelpManaging := pHelpManaging^.pNext;
        end_while;

        // check all configurations which modules are used
        if LocalCPUCfgNo then
          pHelpCfg := pFirstLocalCPUCfg;
          
          for i := 0 to (LocalCPUCfgNo-1) do
            // check for used modules and mark them in the infobits
            CheckModuleUsage(pHelpCfg^.ConfigSize, pHelpCfg^.pConfig);
            
            pHelpCfg := pHelpCfg^.pNext;
          end_for;
        end_if;
        
        // now create the linked list for the time synchronisation
        CreateTimeSyncList();
        
        if (pFirstManagingInterfaceComponent = NIL) then
          InitSSW := _NoDomains;
        else
          // reactivate the domain synchronicity timeout
// don't wait twice, we already waited in state _FirstWait4SynchronManagingNodes
//          b_SynchroTimeoutSet := FALSE;

          InitSSW := _Wait4SynchronManagingNodes;
        end_if;
      end_if;      

//**********************************************************************************************************************************************************
    _Wait4SynchronManagingNodes: // wait until all managing modules are synchron with the other stations
      if SafetyDomainTimeout & (b_SynchroTimeoutSet = FALSE) then
        b_SynchroTimeoutSet := TRUE;
        SynchroTimeout := ops.tAbsolute;
      end_if;
    
      Synchron := AllManagingNodesSynchron();
                                                        // we wait synchro timeout + 50ms (50ms time for the domains to give up trying: see AllManagingNodesSynchron method)
      if Synchron then// | (SafetyDomainTimeout & ((ops.tAbsolute - SynchroTimeout) > (SafetyDomainTimeout + 50))) then
        if b_SyncTimeoutExceeded then
          b_SyncTimeoutExceeded := FALSE;
          LogError("(SafetyManager::CyWork) Timeout for optional Domain exceeded! Initialisation will continue without it!");
        end_if;
  
        // add our own safety cpus to the config list
        AddOwnCPUsToList();
        
        InitSSW := _Wait4ConfigFlush;

      end_if;

//**********************************************************************************************************************************************************
    _Wait4ConfigFlush:
      // if all slaves have been flushed

      // flush our own stuff
      if PDOElementNo then
      
        // at first we have to check if there are any safety modules out there with a pointer to the PDO List (if they use a VMC/VBC as source)
        pPDOElement := #aPDOElements[0];
        for i := 0 to (PDOElementNo-1) do
          if (pPDOElement^.ThisDomainsRole = SourceDest_IsDest) & (pPDOElement^.SourceInfo.pPDOMem) & (pPDOElement^.pSafety) then
            // unregister this PDO
            MyPara.uiCmd := CMD_SM_REMOVE_INPUT_PDO;
            MyPara.aPara[0] := pPDOElement^.SourceInfo.pPDOMem$DINT;
            MyPara.aPara[1] := pPDOElement^.SourceInfo.pPDOMemDPRAM$DINT;
            pPDOElement^.pSafety^.pThis^.NewInst(#MyPara, #MyResult);
          end_if;

          // free the memory of the path infos and reset the rest of pdo element info
          if pPDOElement^.SourceInfo.pPath then
            To_StdLib.Free(pPDOElement^.SourceInfo.pPath);
          end_if;
          if pPDOElement^.DestInfo.pPath then
            To_StdLib.Free(pPDOElement^.DestInfo.pPath);
          end_if;
          
          pPDOElement += sizeof(t_PDOElement);
        end_for;

        _memset(dest:=#aPDOElements, usByte:=0, cntr:=PDOElementNo * sizeof(t_PDOElement));
        PDOElementNo := 0;
      end_if;
      
      if NewTimeSyncPossible() then
        // tell every safety module, that it has to initialize the memory for writing the time synchronisation
        SetNewSyncMode(TRUE);
        MyPara.aPara[3] := 1;
      else
        SetNewSyncMode(FALSE);
        MyPara.aPara[3] := 0;
      end_if;

      InitSSW := _SendDomainNr;

//**********************************************************************************************************************************************************
    _SendDomainNr: // send the domain nr. to the managing nodes      
      // if we have a valid domain number
      MyPara.uiCmd := CMD_SM_DOMAIN_NR_SEND;
      MyPara.aPara[0] := 1; // length of parameters
      
      pTempMem := NIL;
      
      if us_SafetyModuleNo then
        if ud_SizeTempMemCy >= 1 + us_SafetyModuleNo * sizeof(t_ModuleInfo) then
          pTempMem := pTempMemCy;
        else
          LogError("_SendDomainNr: Temporary memory for cyclic task is too small!");
          LogValue(pString:="AvaliableMem: {0} / NeededMem: {1}", Value:=ud_SizeTempMemCy, Value2:=1 + us_SafetyModuleNo * sizeof(t_ModuleInfo));
        end_if;

        if pTempMem then
          MyPara.aPara[1] := pTempMem$DINT;
          pModuleInfo$^void := pTempMem;
          
          pModuleInfo^$USINT := 0;
          pModuleInfo += sizeof(USINT);
          if pFirstSafetyComponent then
            pHelpSafety := pFirstSafetyComponent;
            while pHelpSafety do
              pModuleInfo^.SafetyNbr := pHelpSafety^.SafetyNbr;
              pModuleInfo^.ModuleType := pHelpSafety^.ModuleType;
              
              pHelpSafety := pHelpSafety^.pNext;
              pModuleInfo += sizeof(t_ModuleInfo);
            end_while;
            
            MyPara.aPara[0] += us_SafetyModuleNo * sizeof(t_ModuleInfo);
          end_if;
        else
          MyPara.aPara[1] := (#MyPara.aPara[3])$DINT;
          MyPara.aPara[3] := 0;
          LogError("(SafetyManager::CyWork) Failed to allocate memory for distributing the local module information");
        end_if;
      else
        MyPara.aPara[1] := (#MyPara.aPara[3])$DINT;
        MyPara.aPara[3] := 0;
      end_if;
      
      // tell all interface modules, because maybe they don't know we're an interface neighbor
      TellAllInterfaceManagingModules(#MyPara, #MyResult);
    
      DomainInfoSendTime := ops.tAbsolute;
      
      // the slaves get this via newinst command
      InitSSW := _Wait4DomainInfos;

//**********************************************************************************************************************************************************
    _Wait4DomainInfos:
      // wait a little for further domain infos (which are sent as response to our message)
      if (ops.tAbsolute - DomainInfoSendTime) > 200 then
        InitSSW := _Wait4CPUConfigs;
        SetTimeout();
      end_if;

//**********************************************************************************************************************************************************
    _Wait4CPUConfigs:
      CheckTimeout();
      if AllCPUConfigsArrived() then
        // if all needed modules are available (all non-optional modules or interface frames)
        if CheckCPUConfigs() then
          // check if there are PDO configs to broadcast
          if ActPDO_ID then
            // before we broadcast the PDOs, we check if the length informations are correct on every entry
            PDOLengthCorrection();
                  
            // if we have interface-connections, we wait for the safety numbers of it
            if pFirstManagingInterfaceComponent & AnyIFDomainSynchron() then
              InitSSW := _SendInterfaceConfigs;
            else
              InitSSW := _SendNextPDO;
            end_if;
          else
            // otherwise => finalize initialisation
            InitSSW := _Wait4CopyCmdStart;
          end_if;
        else
          // if configs are not ok => set everything to finished so that the firmware can show the error information (otherwise the firmware will not start doing anything)
          InitSSW := _Wait4CopyCmdStart;
        end_if;
      end_if;
    
//**********************************************************************************************************************************************************
    _SendInterfaceConfigs:
      // if all domain managing modules needed for non-optional pdos are synchron
      if AllNonOptionalIFDomainsSynchron() then
        // send our configs to all inferface domains
        SendInterfaceConfigs();
        
        InitSSW := _Wait4InterfaceConfigs;
        SetTimeout();
      end_if;

//**********************************************************************************************************************************************************
    _Wait4InterfaceConfigs:
      CheckTimeout();
      if AllInterfaceCfgsArrived() then
        if (LocalCPUCfgNo = LocalCPUNo) & pActualSendPDO then
          InitSSW := _SendNextPDO;
        else
          InitSSW := _Wait4ReInit;
        end_if;
      end_if;
      
//**********************************************************************************************************************************************************
    _SendNextPDO:
      // broadcast the PDO
      BroadCastActPDO();
      
      InitSSW := _Wait4PDOAcks;
      SetTimeout();
      
//**********************************************************************************************************************************************************
    _Wait4PDOAcks:
      // wait until all acknowledges arrive (all modules which are needed for PDO transport have to answer!)
      CheckTimeout();

      // check if there is another PDO configuration to send
      repeat
        if pActualSendPDO^.pNext then
          pActualSendPDO := pActualSendPDO^.pNext;
        else
          if pActualSendCfg^.pNext then
            pActualSendCfg := pActualSendCfg^.pNext;
            pActualSendPDO := pActualSendCfg^.pFirstPdoCfg;
            
            // if there is no pdo config in this config, go to the next config
            while (pActualSendPDO = NIL) & pActualSendCfg^.pNext do
              pActualSendCfg := pActualSendCfg^.pNext;
              pActualSendPDO := pActualSendCfg^.pFirstPdoCfg;
            end_while;
          else
            pActualSendCfg := NIL;
            pActualSendPDO := NIL;
          end_if;
        end_if;
        
      // skip double entries
      until ((pActualSendPDO = NIL) | (pActualSendPDO^.PdoInfo.Info.DoublePDOEntry = FALSE)) end_repeat;
      
      // if we found another PDO => send it
      if pActualSendPDO then
        InitSSW := _SendNextPDO;
      else
        // otherwise => finalize initialisation
        InitSSW := _Wait4CopyCmdStart;
      end_if;      
      
//**********************************************************************************************************************************************************
    _Wait4CopyCmdStart:
      // this step is handlet in RT because the DOs are isochronous

//**********************************************************************************************************************************************************
    _NoDomains:
      // No domains available => just check if there are old modules or new modules used
      if NewTimeSyncPossible() then
        // tell every safety module, that it has to initialize the memory for writing the time synchronisation
        SetNewSyncMode(TRUE);
      else
        SetNewSyncMode(FALSE);
      end_if;

      // we may have internal interface frames and therefore we have to create a list with the local CRCs
      if LocalIFsAvailable() then
        // add local IFs for easier SDO/TDO forwarding
        CheckCPUConfigs();

        // check if there are PDO configs to broadcast
        if ActPDO_ID then
          // before we broadcast the PDOs, we check if the length informations are correct on every entry
          PDOLengthCorrection();

          // distribute PDOs locally
          pHelpConfig := pConfigs;
          while pHelpConfig do
            pActualSendCfg := pHelpConfig;
            pActualSendPDO := pHelpConfig^.pFirstPdoCfg;
            while pActualSendPDO do
              BroadCastActPDO();
            
              pActualSendPDO := pActualSendPDO^.pNext;
            end_while;
          
            pHelpConfig := pHelpConfig^.pNext;
          end_while;
        end_if;
      end_if;
      
      InitSSW := _FinishInitialisation;
      
//**********************************************************************************************************************************************************
    _FinishInitialisation:
      // if it's the new mode also start the sync process at the first safety device
      MyPara.uiCmd := CMD_SM_INIT_FINISHED;
      MyPara.aPara[0] := 0; // length of parameters

      // sent set bus ready signal (quit error 199 if active)
      TellAllSafetyModules(#MyPara, #MyResult);
            
      // if we have the new sync mode => start the time synchronisation here
      if b_NewSyncMode then
        b_StartTimeSync := TRUE;
      end_if;

      MinSyncDuration := 16#7FFFFFFF;
      
      // if there was an error and we still reached this point, don't conceal the error (except if it's a timeout in this init sequence)
      if (ClassState = 0) | (ClassState = -11) then
        ClassState := 1;
      end_if;
      
      InitSSW := _InitFinished;
      
//**********************************************************************************************************************************************************
    _InitFinished: // finished with initialisation, now start our cyclic business

      // check sync timeout counter
      if SyncTimeoutCounter >= TIMESYNC_TIMEOUTS_BEFORE_LOGMSG then
        LogError("Timeout while Timesynchronizing");
        
        // reset counter
        SyncTimeoutCounter := 0;
      end_if;
      
      // print log messages from realtime here to prevent rt-runtime errors
      if bd_LogRtMessagesInCy then
        if bd_LogRtMessagesInCy.NoTDOTargetToManager then
          bd_LogRtMessagesInCy.NoTDOTargetToManager := FALSE;
          LogError("(SafetyManager::ClassState::NewInst) Couldn't find target of TDO on the way to the manager");
        end_if;

        if bd_LogRtMessagesInCy.NoTDOTargetToModule then
          bd_LogRtMessagesInCy.NoTDOTargetToModule := FALSE;
          LogError("(SafetyManager::ClassState::NewInst) Couldn't find target of TDO on the way to the module");
        end_if;

        if bd_LogRtMessagesInCy.InvalidCommandReceived then
          bd_LogRtMessagesInCy.InvalidCommandReceived := FALSE;
          LogError("(SafetyCDIAS_Base::State::NewInst) Invalid command received");
        end_if;

        if bd_LogRtMessagesInCy.UnkownCopySource then
          bd_LogRtMessagesInCy.UnkownCopySource := FALSE;
          LogError("(SafetyManager::RtWork) Could not activate copy command, because source address is unknown (waiting for safety number info))");
        end_if;

        if bd_LogRtMessagesInCy.InvalidIFConfiguration then
          bd_LogRtMessagesInCy.InvalidIFConfiguration := FALSE;
          LogError("(SafetyManager::GiveTokenToNextModule) Only non-synchron interface domains found => need at least one safe CPU!");
        end_if;

        if bd_LogRtMessagesInCy.TooManyOptionalMissing then
          bd_LogRtMessagesInCy.TooManyOptionalMissing := FALSE;
          LogError("(SafetyManager::GiveTokenToNextModule) Too many optional modules missing for a correct time sync cycle)");
        end_if;
      end_if;
//**********************************************************************************************************************************************************
  end_case;

#ifdef SAFETY_DEBUG_LOGGING_ACTIVATED
  if InitSSW <> OldInitSSW then
#ifdef SAFETY_DEBUG_TRACING_ACTIVATED
    LogValue(pString:="(SafetyManager::CyWork) InitSSW changed from {0} to {1}", Value:=OldInitSSW, Value2:=InitSSW);
#endif
    LogBuf[ActLogIndex].NewState := InitSSW;
    LogBuf[ActLogIndex].OldState := OldInitSSW;
    LogBuf[ActLogIndex].Command := 0;
    LogBuf[ActLogIndex].TimeSinceLastLog_us := OS_READMICROSEC();
    LogBuf[ActLogIndex].TimeSinceLastLog_us -= TimeStampLastLog_us;
    TimeStampLastLog_us := OS_READMICROSEC();
    if ActLogIndex = (LogBufferSize - 1) then
      ActLogIndex := 0;
    else
      ActLogIndex += 1;
    end_if;
  end_if;
  OldInitSSW := InitSSW;
#endif

	state := READY;

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
	StopTimeMeasurement(VARANTIME_CY);
#endif
//=================================================================================================

END_FUNCTION


FUNCTION SafetyManager::AddModule
	VAR_INPUT
		pPara 	: ^CmdStruct;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	ModuleType : t_e_ModuleType;
  END_VAR

  retcode := FALSE;

  ModuleType := pPara^.aPara[0]$t_e_ModuleType;

  // we differ between real safety components and managing components
  case ModuleType of
    _CSCP01x,
    _CSDI16x,
    _CSTO08x,
    _SCP010,
    _SCP011,
    _MS011:
        retcode := AddSafetyModule(ModuleType, pPara^.aPara[1]$pVirtualBase);
    
    _VBC021Master,
    _VBC021Slave, // (is limited to 1 per system, because the system can't sync to different systems at the same time)
    _VMC052,
    _VaranManager4VMC: // VaranManager (VMC052 counterpart is also limited to 1 per system, because the system can't sync to different systems at the same time)
        retcode := AddManagingModule(ModuleType, pPara^.aPara[1]$pVirtualBase, pPara^.aPara[2]$^USINT);
  else
    // invalid module type
    ClassState := -7;
    LogError("(SafetyManager::AddModule) Invalid ModuleType");
  end_case;

  if retcode then
    LoginCnt += 1;
  end_if;

END_FUNCTION


FUNCTION SafetyManager::AddSafetyModule
	VAR_INPUT
		ModuleType 	: t_e_ModuleType;
		pThis 	: pVirtualBase;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pHelpSafety : ^t_SafetyComponent;
  END_VAR

  if pFirstSafetyComponent = NIL then
    pFirstSafetyComponent$pVoid := To_StdLib.Malloc(size:=sizeof(t_SafetyComponent));
    pHelpSafety := pFirstSafetyComponent;    
  else
    pHelpSafety := pFirstSafetyComponent;
    while pHelpSafety^.pNext <> NIL do
      pHelpSafety := pHelpSafety^.pNext;
    end_while;
    pHelpSafety^.pNext$pVoid := To_StdLib.Malloc(size:=sizeof(t_SafetyComponent));
    pHelpSafety := pHelpSafety^.pNext;
  end_if;
  
  if pHelpSafety <> NIL then
    _memset(dest:=pHelpSafety, usByte:=0, cntr:=sizeof(t_SafetyComponent));
    pHelpSafety^.ModuleType   := ModuleType;
    pHelpSafety^.pThis        := pThis;

//    pHelpSafety^.pNext        := NIL;  // not necessary because of memset
    
    case ModuleType of
//**********************************************************************************************************************************************************
      _CSCP01x,
      _SCP010,
      _SCP011: 
        LocalCPUNo += 1;
      
//**********************************************************************************************************************************************************
      _CSDI16x,
      _MS011:
        pHelpSafety^.InfoBits.OnlyInputs := TRUE;
//**********************************************************************************************************************************************************
    end_case;
    
    us_SafetyModuleNo += 1;
    
    retcode := TRUE;
  else
    ClassState := -1;

    retcode := FALSE;
  end_if;

END_FUNCTION


FUNCTION SafetyManager::AddManagingModule
	VAR_INPUT
		ModuleType 	: t_e_ModuleType;
		pThis 	: pVirtualBase;
		pObjectPath 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pHelpManaging : ^t_ManagingComponent;
    pMyPath : ^USINT;
  END_VAR

  if pFirstManagingInterfaceComponent = NIL then
    pFirstManagingInterfaceComponent$pVoid := To_StdLib.Malloc(size:=sizeof(t_ManagingComponent));
    pHelpManaging := pFirstManagingInterfaceComponent;    
  else
    pHelpManaging := pFirstManagingInterfaceComponent;
    while pHelpManaging^.pNext <> NIL do
      pHelpManaging := pHelpManaging^.pNext;
    end_while;
    pHelpManaging^.pNext$pVoid := To_StdLib.Malloc(size:=sizeof(t_ManagingComponent));
    pHelpManaging := pHelpManaging^.pNext;
  end_if;
  
  if pHelpManaging <> NIL then
    _memset(dest:=pHelpManaging, usByte:=0, cntr:=sizeof(t_ManagingComponent));
    pHelpManaging^.ModuleType     := ModuleType;
    pHelpManaging^.pThis          := pThis;
    pHelpManaging^.DomainNr       := 16#FF;
    
    if pObjectPath then
      pMyPath$^void := To_StdLib.Malloc(size:=pObjectPath^ + 2);
      
      // convert 1 byte length info into 2 byte length info
      if pMyPath then
        pMyPath^$UINT := pObjectPath^$USINT;
        To_StdLib.MemCpy(dest:=pMyPath + 2, source:=pObjectPath + 1, size:=pObjectPath^);
      end_if;
    end_if;

    pHelpManaging^.pModulePath := pMyPath;
    
  //pHelpManaging^.pNext          := NIL;  // not necessary because of memset
        
    retcode := TRUE;
  else
    ClassState := -1;

    retcode := FALSE;
  end_if;

END_FUNCTION


FUNCTION SafetyManager::AddSafetyNbr
	VAR_INPUT
		pThis 	: pVirtualBase;
		ud_SafetyNbr 	: UDINT;
		FirmwareVersion 	: HDINT;
		FPGAVersion 	: HSINT;
		PathLen 	: USINT;
		pPath 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pHelpSafety : ^t_SafetyComponent;
  END_VAR
    
  retcode := FALSE;
  
  if pFirstSafetyComponent then
    pHelpSafety := pFirstSafetyComponent;
    while pHelpSafety do
      if pHelpSafety^.pThis = pThis then
        pHelpSafety^.SafetyNbr    := ud_SafetyNbr;
        pHelpSafety^.FW_Version   := FirmwareVersion;
        pHelpSafety^.FPGA_Version := FPGAVersion;
        pHelpSafety^.PathLen      := PathLen;
        pHelpSafety^.pPath        := pPath;
        
        retcode := TRUE;
        return;
      end_if;
      
      pHelpSafety := pHelpSafety^.pNext;
    end_while;
  end_if;

END_FUNCTION


FUNCTION SafetyManager::GetModuleTypeNo
	VAR_INPUT
		ModuleType 	: t_e_ModuleType;
	END_VAR
	VAR_OUTPUT
		ModuleNo 	: DINT;
	END_VAR
  VAR
  	pHelpSafety   : ^t_SafetyComponent;
    pHelpManaging : ^t_ManagingComponent;
  END_VAR
  
  ModuleNo := 0;
  
  if pFirstSafetyComponent then
    pHelpSafety := pFirstSafetyComponent;
    while pHelpSafety do
      if pHelpSafety^.ModuleType = ModuleType then
        ModuleNo += 1;
      end_if;
      
      pHelpSafety := pHelpSafety^.pNext;
    end_while;
  end_if;

  if pFirstManagingInterfaceComponent then
    pHelpManaging := pFirstManagingInterfaceComponent;
    while pHelpManaging do
      if pHelpManaging^.ModuleType = ModuleType then
        ModuleNo += 1;
      end_if;
      
      pHelpManaging := pHelpManaging^.pNext;
    end_while;
  end_if;

END_FUNCTION


FUNCTION SafetyManager::NewTimeSyncPossible
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pHelpSafety   : ^t_SafetyComponent;
  END_VAR
  
  // default is: we can => check if there is any module with too old firmware or fpga
  retcode := TRUE;
  
  if pFirstSafetyComponent then
    pHelpSafety := pFirstSafetyComponent;
    while pHelpSafety do
      
      if ((pHelpSafety^.ModuleType = _CSCP01x) & (   (pHelpSafety^.FPGA_Version    < 16#14)     // if its a CSCP and the FPGA Version is lower than 1.4 
                                                   | (pHelpSafety^.FW_Version$UINT < 100)))     // or the firmware version is lower than 100
      |  (pHelpSafety^.NewConfigType = ConfigState_Old) then                                    // or the module has an old config type

        retcode := FALSE;
        
        // check all modules for correct versions
        // return;
      end_if;
      
      pHelpSafety := pHelpSafety^.pNext;
    end_while;
  end_if;
  
END_FUNCTION


FUNCTION SafetyManager::SetNewSyncMode
	VAR_INPUT
		b_NewMode 	: BOOL;
	END_VAR
  VAR
		MyPara 	  : CmdStruct;
		MyResult	: results;
  END_VAR

  b_NewSyncMode := b_NewMode;

  MyPara.uiCmd := CMD_SM_SET_NEW_SYNC_MODE;
  MyPara.aPara[0] := b_NewSyncMode;
  TellAllSafetyModules(#MyPara, #MyResult);
  
END_FUNCTION


FUNCTION SafetyManager::TellAllSafetyModules
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
  VAR
  	pHelpSafety : ^t_SafetyComponent;
  END_VAR
    
  if pFirstSafetyComponent then
    pHelpSafety := pFirstSafetyComponent;
    while pHelpSafety do
      // call the newinst with the given parameters
      pHelpSafety^.pThis^.NewInst(pPara, pResult);
      
      pHelpSafety := pHelpSafety^.pNext;
    end_while;
  end_if;  

END_FUNCTION


FUNCTION SafetyManager::StartTimeSync
  
  if pFirstTimeSyncElement then
    pActTimeSyncElement := pFirstTimeSyncElement;

    // send the token to the right module    
    GiveTokenToNextModule();
    
    // remember the start time for calculating the time of a complete synchronisation
    TimeSyncCycleStart := ops.tAbsolute;    
  end_if;
  
END_FUNCTION


FUNCTION SafetyManager::NextTimeSyncModule

  pActTimeSyncElement := pActTimeSyncElement^.pNext;

  // must be done after selecting the new element
  if GiveTokenToNextModule() then
    // we're finished with our synchronisation cycle and just started a new one (must be done after selecting the new element)
    if IsTimeSyncMaster then      
      SyncDuration := ops.tAbsolute - TimeSyncCycleStart;
      if SyncDuration > MaxSyncDuration then
        MaxSyncDuration := SyncDuration;
      end_if;
      if SyncDuration < MinSyncDuration then
        MinSyncDuration := SyncDuration;
      end_if;

      // if a cycle has been finished => reset the timeout counter
      SyncTimeoutCounter := 0;

      // remember the start time for calculating the time of a complete synchronisation
      TimeSyncCycleStart := ops.tAbsolute;
    end_if;
  end_if;
  
END_FUNCTION


FUNCTION SafetyManager::GiveTokenToNextModule
	VAR_OUTPUT
		RestartCycle 	: BOOL;
	END_VAR
  VAR
		MyPara 	  : CmdStruct;
		MyResult	: results;
    pTemp : ^t_TimeSyncElement;
  END_VAR

  if pActTimeSyncElement = pFirstTimeSyncElement then
    RestartCycle := TRUE;
  else
    RestartCycle := FALSE;
  end_if;

  // check if we have to skip something (missing optional modules)
  if pActTimeSyncElement^.InfoBits.IsMissingOptional then
    // save the actual position
    pTemp := pActTimeSyncElement;
    
    // if it's a missing optional module
    while pActTimeSyncElement^.InfoBits.IsMissingOptional do
      // skip it
      pActTimeSyncElement := pActTimeSyncElement^.pNext;
      
      // if we jumped on the first, we have to restart the cycle (time measurement and timeout surveillance)
      if pActTimeSyncElement = pFirstTimeSyncElement then
        RestartCycle := TRUE;
      end_if;
      
      // if we're at the start of the rotation => stop rotating and print error message
      if pActTimeSyncElement = pTemp then
        bd_LogRtMessagesInCy.TooManyOptionalMissing := TRUE;
        ClassState := -12;
        exit;
      end_if;
    end_while;
  end_if;

  // check if we have to skip something
  if pActTimeSyncElement^.InfoBits.IsInterfaceDomain then
    // save the actual position
    pTemp := pActTimeSyncElement;

    // if it's an interface managing module and it's not synchron, skip it (there has to be also a Safety CPU in the system, therefore we don't ask for it
    while pActTimeSyncElement^.InfoBits.IsInterfaceDomain & (pActTimeSyncElement^.pManaging^.InfoBits.IsSynchron = FALSE) do
      // skip it
      pActTimeSyncElement := pActTimeSyncElement^.pNext;
      
      // if we jumped on the first, we have to restart the cycle (time measurement and timeout surveillance)
      if pActTimeSyncElement = pFirstTimeSyncElement then
        RestartCycle := TRUE;
      end_if;
      
      // if we're at the start of the rotation => stop rotating and print error message
      if pActTimeSyncElement = pTemp then
        bd_LogRtMessagesInCy.InvalidIFConfiguration := TRUE;
        ClassState := -12;
        exit;
      end_if;
    end_while;
  end_if;

  if pActTimeSyncElement^.InfoBits.IsConnectionToMaster then
    // don't check for sync timeout if we're not the master
    b_CheckTimeSyncTimeout := FALSE;
  else
    b_CheckTimeSyncTimeout := TRUE;    
  end_if;
  
  // if it's a managing module and not the connection to the master, we give the token to a slave => remember it
  if pActTimeSyncElement^.InfoBits.IsManagingModule & (pActTimeSyncElement^.InfoBits.IsConnectionToMaster = FALSE) then
    b_SlaveSyncActive := TRUE;
  end_if;

  // tell the next module, to start the time synchronisation
  MyPara.uiCmd := CMD_SM_START_TIME_SYNC;
  pActTimeSyncElement^.pThis^.NewInst(#MyPara, #MyResult);

  LastTimeSyncThis := pActTimeSyncElement^.pThis;
  TimeSyncTimeStamp := ops.tAbsolute;
  
END_FUNCTION


FUNCTION SafetyManager::TellAllInterfaceManagingModules
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
  VAR
  	pHelpManaging : ^t_ManagingComponent;
  END_VAR
    
  if pFirstManagingInterfaceComponent then
    pHelpManaging := pFirstManagingInterfaceComponent;
    while pHelpManaging do
      // call the newinst with the given parameters
      if pHelpManaging^.InfoBits.IsSynchron then
        pHelpManaging^.pThis^.NewInst(pPara, pResult);
      end_if;
      
      pHelpManaging := pHelpManaging^.pNext;
    end_while;
  end_if;  

END_FUNCTION


FUNCTION SafetyManager::SafetyManager
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  VAR
    p_SSR			: ^LSL_SSR;
  END_VAR

  //get pointer for logging function
	if ( OS_CILGET( "SSR", #p_SSR ) ) then
    p_KernelLog := NIL;
  else
    //Log function is available
		p_KernelLog := ( p_SSR^.KernelLog )$^DINT;
  end_if;

  //get interface for hardwaretree functions
  if ( OS_CILGET(INTERFACE_HARDWARETREE, #pHardwareTree)) then
    pHardwareTree := NIL;

    LogError("Hardwaretree-Interface not found. A newer OS is required for Safety-Modules");
  end_if;
  
  pTempMemCy := To_StdLib.Malloc(size:=SIZE_TEMP_MEMORY);
  if pTempMemCy then
    ud_SizeTempMemCy := SIZE_TEMP_MEMORY;
  else
    LogError("SafetyManager: Allocate temporary Memory failed");
  end_if;

	ret_code := C_OK;

END_FUNCTION


FUNCTION SafetyManager::AllManagingNodesSynchron
	VAR_OUTPUT
		AllReady 	: BOOL;
	END_VAR
  VAR
  	pHelpManaging : ^t_ManagingComponent;
		MyPara 	  : CmdStruct;
		MyResult	: results;
  END_VAR

  AllReady := TRUE;
  
  // check if any of the managing interface modules is not synchron
  if pFirstManagingInterfaceComponent then
    MyPara.uiCmd := CMD_SM_SYNC_CHECK;

    pHelpManaging := pFirstManagingInterfaceComponent;
    while pHelpManaging do
      // if any managing component isn't synchron => stop searching
      if pHelpManaging^.pThis^.NewInst(#MyPara, #MyResult) = ERROR then
        if (pHelpManaging^.InfoBits.IsOptional = TRUE) then
          if ((SafetyDomainTimeout & ((ops.tAbsolute - SynchroTimeout) > SafetyDomainTimeout))) then
            // we give up waiting => timeout exceeded
            b_SyncTimeoutExceeded := TRUE;
            // if it's the last managing module, then it's our connection to the master module
            if (IsTimeSyncMaster = 0) & pHelpManaging^.InfoBits.IsConnectionToMaster then
              // we have to be our own master now
              IsTimeSyncMaster := 1;
            end_if;
          else
            AllReady := FALSE;
          end_if;
        else
          AllReady := FALSE;
        end_if;

        // return; don't give up here => we have to check it for all domains, this one may be an optional interface frame domain
        pHelpManaging^.InfoBits.IsSynchron := FALSE;
      else
        pHelpManaging^.InfoBits.IsSynchron := TRUE;
      end_if;
      
      pHelpManaging := pHelpManaging^.pNext;
    end_while;
  end_if;  

END_FUNCTION


FUNCTION SafetyManager::GetMasterConnection
  VAR_OUTPUT
    pMasterConn : ^t_ManagingComponent;
  END_VAR
  VAR
    pHelpManaging : ^t_ManagingComponent;
  END_VAR

  pMasterConn := NIL;

  if pFirstManagingInterfaceComponent then
    pHelpManaging := pFirstManagingInterfaceComponent;
    while pHelpManaging do
      if (pHelpManaging^.ModuleType = _VBC021Slave) | (pHelpManaging^.ModuleType = _VaranManager4VMC) then
        pMasterConn := pHelpManaging;
        pMasterConn^.InfoBits.IsConnectionToMaster := TRUE;
        // if it's not the last in the list => we have to put it in the last place for easier timesync handling (last managing module to handle is the connection back to the master)
        if pMasterConn^.pNext then
          // if it's the first one
          if pMasterConn = pFirstManagingInterfaceComponent then
            pHelpManaging := pFirstManagingInterfaceComponent;
            while pHelpManaging^.pNext do
              pHelpManaging := pHelpManaging^.pNext;
            end_while;
            pFirstManagingInterfaceComponent := pFirstManagingInterfaceComponent^.pNext;
            pHelpManaging^.pNext := pMasterConn;
            pMasterConn^.pNext := NIL;
          else
            // if it's one in the middle
            pHelpManaging := pFirstManagingInterfaceComponent;
            while pHelpManaging^.pNext do
              if pHelpManaging^.pNext = pMasterConn then
                pHelpManaging^.pNext := pMasterConn^.pNext;
              end_if;

              pHelpManaging := pHelpManaging^.pNext;
            end_while;
            pHelpManaging^.pNext := pMasterConn;
            pMasterConn^.pNext := NIL;
          end_if;
        end_if;
        return;
      end_if;
      
      pHelpManaging := pHelpManaging^.pNext;
    end_while;
  end_if;

END_FUNCTION


FUNCTION SafetyManager::AddConfiguration
	VAR_INPUT
		Length 	: UINT;
		pData 	: ^void;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    pHelpCfg : ^t_CfgListElem;
    pHelpModule : ^t_ModuleListElem;
    pHelpPdo : ^t_PdoListElem;
    pHelpSlave : ^t_SlaveListElem;
    pDataHelp : ^void;
    i : UDINT;
    TmpPathLen : UINT;
    TempCfgNo : USINT;
  END_VAR

(*
    Memory structure:
      4 Byte: SafetyNumber of CPU (is already there from initialisation in CSCP011_IM::InitSafeModule)
      1 Byte: Number of module configurations which are following
      for every module configuration (first is always the CPU itself)
        1 Byte: Info
        4 Byte: Interface Frame Source SafetyNumber (0 if it is no source for interface frames)
        4 Byte: Interface Frame CRC
        1 Byte: Number of destination inferface frame CRCs
        x Byte: Destination interface frame CRCs (number * sizeof(HDINT)
        2 Byte: Length of hardware path
        x Byte (depending on length in the 2 byte before): Hardwarepath
        2 Byte: Length of compressed hardware path
        x Byte (depending on length in the 2 byte before): Compressed Hardwarepath
        1 Byte: PDO out length for this module
      1 Byte: Number of pdo configurations which are following
      for every PDO configuration
        1 Byte: PDO length
        1 Byte: Interface frame info
        4 Byte: Interface CRC
        2 Byte: Length of source hardware path
        x Byte (depending on length in the 2 byte before): Hardwarepath of source
        2 Byte: Length of destination hardware path
        x Byte (depending on length in the 2 byte before): Hardwarepath of destination       
      1 Byte: Number of slave configurations which are following
      for every slave configuration
        1 Byte: Info
        4 Byte: InterfaceCRC
        2 Byte: Length of hardware path
        x Byte (depending on length in the 2 byte before): Hardwarepath
        2 Byte: Length of compressed hardware path
        x Byte (depending on length in the 2 byte before): Compressed Hardwarepath
*)

  // check if the configuration is valid (pData <> NIL) & (Length must be at least 4 byte for SafetyNbr + 1 byte module cfg number + 1 byte pdo cfg number + 1 byte slave cfc number)
  if pData & (Length >= 7)  then

    retcode := 0;
    
    // first we have to allocate some memory for the configuration
    if pConfigs = NIL then
      pConfigs$pVoid := To_StdLib.Malloc(size:=sizeof(t_CfgListElem));
      pHelpCfg := pConfigs;
    else
      pHelpCfg := pConfigs;
      while pHelpCfg^.pNext <> NIL do
        //if searched path is found, we already got this module in our list
        if pHelpCfg^.SafetyNbr = pData^$HDINT then
          // already in buffer => leave function
          return;
        else
          pHelpCfg := pHelpCfg^.pNext;
        end_if;
      end_while;

      //if searched path is found, we already got this module in our list
      if pHelpCfg^.SafetyNbr = pData^$HDINT then
        // already in buffer => leave function
        return;
      end_if;

      pHelpCfg^.pNext$pvoid := To_StdLib.Malloc(size:=sizeof(t_CfgListElem));
      pHelpCfg := pHelpCfg^.pNext;
    end_if;
    
    // if we have memory for the configuration => we add the data to the new element
    if pHelpCfg <> NIL then
      pDataHelp := pData;
      
      // set the next pointer to NIL
      pHelpCfg^.pNext := NIL;

      // safety number of the safety cpu
      pHelpCfg^.SafetyNbr := pDataHelp^$HDINT;
      pDataHelp += sizeof(HDINT);
      
      // number of module configurations which follow now
      TempCfgNo := pDataHelp^$USINT;
      pDataHelp += sizeof(USINT);

      pHelpCfg^.pFirstModuleCfg := NIL;
      
      // module configurations
      if TempCfgNo then
        for i := 0 to (TempCfgNo-1) do
          if pHelpCfg^.pFirstModuleCfg = NIL then
            pHelpCfg^.pFirstModuleCfg$pVoid := To_StdLib.Malloc(size:=sizeof(t_ModuleListElem));
            pHelpModule := pHelpCfg^.pFirstModuleCfg;
          else
            pHelpModule^.pNext$pvoid := To_StdLib.Malloc(size:=sizeof(t_ModuleListElem));
            pHelpModule := pHelpModule^.pNext;
          end_if;
          
          if pHelpModule then
            // info
            pHelpModule^.ModuleInfo.Info := pDataHelp^$BSINT;
            pDataHelp += sizeof(BSINT);
            
            // safety number of interface frame source
            pHelpModule^.ModuleInfo.SafetyNbr := pDataHelp^$HDINT;
            pDataHelp += sizeof(HDINT);

            // interface CRC of interface frame
            pHelpModule^.ModuleInfo.InterfaceCRC := pDataHelp^$HDINT;
            pDataHelp += sizeof(HDINT);
            
            // interface frame destination CRCs
            if pHelpModule^.ModuleInfo.Info.IsInterfaceDest then
              // number of CRCs
              TmpPathLen := pDataHelp^$USINT; // save some time with this local variable
              pHelpModule^.ModuleInfo.DestCRCNo := TmpPathLen$USINT;
              pDataHelp += sizeof(USINT);
              
              // allocate memory for the module path
              pHelpModule^.ModuleInfo.pDestCRCs$pVoid := To_StdLib.Malloc(size:=TmpPathLen * sizeof(HDINT));
              if pHelpModule^.ModuleInfo.pDestCRCs = NIL then
                ClassState := -1;
                retcode := -2;
                return;
              end_if;
              
              // save CRCs
              _memcpy(ptr1:=pHelpModule^.ModuleInfo.pDestCRCs, ptr2:=pDataHelp, cntr:=TmpPathLen * sizeof(HDINT));
              pDataHelp += TmpPathLen * sizeof(HDINT);
            else
              pHelpModule^.ModuleInfo.DestCRCNo := 0;
              pHelpModule^.ModuleInfo.pDestCRCs := NIL;
            end_if;
            
            // length of hardwarepath
            TmpPathLen := pDataHelp^$UINT; // save some time with this local variable
            pHelpModule^.ModuleInfo.PathLen := TmpPathLen;
            pDataHelp += sizeof(UINT);
            
            // allocate memory for the module path
            pHelpModule^.ModuleInfo.pPath$pVoid := To_StdLib.Malloc(size:=TmpPathLen);
            if pHelpModule^.ModuleInfo.pPath = NIL then
              ClassState := -1;
              retcode := -2;
              return;
            end_if;
            
            // save hardwarepath
            _memcpy(ptr1:=pHelpModule^.ModuleInfo.pPath, ptr2:=pDataHelp, cntr:=TmpPathLen);
            pDataHelp += TmpPathLen;

            // length of hardwarepath
            TmpPathLen := pDataHelp^$UINT; // save some time with this local variable
            pHelpModule^.ModuleInfo.CompPathLen := TmpPathLen;
            pDataHelp += sizeof(UINT);
            
            // allocate memory for the module path
            pHelpModule^.ModuleInfo.pCompPath$pVoid := To_StdLib.Malloc(size:=TmpPathLen);
            if pHelpModule^.ModuleInfo.pCompPath = NIL then
              ClassState := -1;
              retcode := -2;
              return;
            end_if;
            
            // save compressed hardwarepath
            _memcpy(ptr1:=pHelpModule^.ModuleInfo.pCompPath, ptr2:=pDataHelp, cntr:=TmpPathLen);
            pDataHelp += TmpPathLen;
            
            // PDO out length for this module (to assign the length to the pdo configurations)
            pHelpModule^.ModuleInfo.PdoOutLen := pDataHelp^$USINT;
            pDataHelp += sizeof(USINT);
            
            pHelpModule^.pNext                  := NIL;
          else
            ClassState := -1;
            retcode := -2;
            return;
          end_if;          
        end_for;
      end_if;

      // number of Pdo configurations which follow now
      TempCfgNo := pDataHelp^$USINT;
      pDataHelp += sizeof(USINT);
      
      pHelpCfg^.pFirstPdoCfg := NIL;
      
      // Pdo configurations
      if TempCfgNo then
        for i := 0 to (TempCfgNo-1) do
          if pHelpCfg^.pFirstPdoCfg = NIL then
            pHelpCfg^.pFirstPdoCfg$pVoid := To_StdLib.Malloc(size:=sizeof(t_PdoListElem));
            pHelpPdo := pHelpCfg^.pFirstPdoCfg;
          else
            pHelpPdo^.pNext$pvoid := To_StdLib.Malloc(size:=sizeof(t_PdoListElem));
            pHelpPdo := pHelpPdo^.pNext;
          end_if;
          
          if pHelpPdo then
            // pdo length
            pHelpPdo^.PdoInfo.PdoLen := pDataHelp^$USINT;
            pDataHelp += sizeof(USINT);
            
            // is it an interface pdo?
            pHelpPdo^.PdoInfo.Info := pDataHelp^$BSINT;
            pDataHelp += sizeof(BSINT);
            
            // if it is an interface frame, we have to copy the CRC too
            if pHelpPdo^.PdoInfo.Info.IsInterfacePDO then
              // interface CRC
              pHelpPdo^.PdoInfo.InterfaceCRC := pDataHelp^$HDINT;
            else
              pHelpPdo^.PdoInfo.InterfaceCRC := 0;
            end_if;
            pDataHelp += sizeof(HDINT);
            
            // length of source hardwarepath
            TmpPathLen := pDataHelp^$UINT; // save some time with this local variable
            pHelpPdo^.PdoInfo.SourcePathLen := TmpPathLen;
            pDataHelp += sizeof(UINT);
            
            // allocate memory for the source module path
            pHelpPdo^.PdoInfo.pSourcePath$pVoid := To_StdLib.Malloc(size:=TmpPathLen);
            if pHelpPdo^.PdoInfo.pSourcePath = NIL then
              ClassState := -1;
              retcode := -2;
              return;
            end_if;
            
            // save source hardwarepath
            _memcpy(ptr1:=pHelpPdo^.PdoInfo.pSourcePath, ptr2:=pDataHelp, cntr:=TmpPathLen);
            pDataHelp += TmpPathLen;

            // length of destination hardwarepath
            TmpPathLen := pDataHelp^$UINT; // save some time with this local variable
            pHelpPdo^.PdoInfo.DestPathLen := TmpPathLen;
            pDataHelp += sizeof(UINT);
            
            // allocate memory for the destination module path
            pHelpPdo^.PdoInfo.pDestPath$pVoid := To_StdLib.Malloc(size:=TmpPathLen);
            if pHelpPdo^.PdoInfo.pDestPath = NIL then
              ClassState := -1;
              retcode := -2;
              return;
            end_if;
            
            // save destination hardwarepath
            _memcpy(ptr1:=pHelpPdo^.PdoInfo.pDestPath, ptr2:=pDataHelp, cntr:=TmpPathLen);
            pDataHelp += TmpPathLen;
                        
            // check if a prior configuration also added this PDO (possible if a CSTO gets PDOs from 2 CSCPs)
            if DoublePDOEntry(pHelpPdo^.PdoInfo, pHelpCfg) then
              // use ID 255 (as kind of invalid) and mark the PDO as double entry (will not be distributed then)
              pHelpPdo^.PdoInfo.PDO_ID := 255;
              pHelpPdo^.PdoInfo.Info.DoublePDOEntry := TRUE;
            else
              // now we give it a priority and increase the number for the next pdo
              pHelpPdo^.PdoInfo.PDO_ID := ActPDO_ID;
              ActPDO_ID += 1;
            end_if;
            
            pHelpPdo^.pNext                  := NIL;
          else
            ClassState := -1;
            retcode := -2;
            return;
          end_if;          
        end_for;
      end_if;

      // number of slave configurations which follow now
      TempCfgNo := pDataHelp^$USINT;
      pDataHelp += sizeof(USINT);

      pHelpCfg^.pFirstSlaveCfg:= NIL;
      
      // slave configurations
      if TempCfgNo then
        for i := 0 to (TempCfgNo-1) do
          if pHelpCfg^.pFirstSlaveCfg = NIL then
            pHelpCfg^.pFirstSlaveCfg$pVoid := To_StdLib.Malloc(size:=sizeof(t_SlaveListElem));
            pHelpSlave := pHelpCfg^.pFirstSlaveCfg;
          else
            pHelpSlave^.pNext$pvoid := To_StdLib.Malloc(size:=sizeof(t_SlaveListElem));
            pHelpSlave := pHelpSlave^.pNext;
          end_if;
          
          if pHelpSlave then
            // info
            pHelpSlave^.SlaveInfo.Info := pDataHelp^$BSINT;
            pDataHelp += sizeof(BSINT);
                       
            // InterfaceCRC
            pHelpSlave^.SlaveInfo.InterfaceCRC := pDataHelp^$HDINT;
            pDataHelp += sizeof(HDINT);

            // length of hardwarepath
            TmpPathLen := pDataHelp^$UINT; // save some time with this local variable
            pHelpSlave^.SlaveInfo.PathLen := TmpPathLen;
            pDataHelp += sizeof(UINT);
            
            // allocate memory for the module path
            pHelpSlave^.SlaveInfo.pPath$pVoid := To_StdLib.Malloc(size:=TmpPathLen);
            if pHelpSlave^.SlaveInfo.pPath = NIL then
              ClassState := -1;
              retcode := -2;
              return;
            end_if;
            
            // save hardwarepath
            _memcpy(ptr1:=pHelpSlave^.SlaveInfo.pPath, ptr2:=pDataHelp, cntr:=TmpPathLen);
            pDataHelp += TmpPathLen;

            // length of hardwarepath
            TmpPathLen := pDataHelp^$UINT; // save some time with this local variable
            pHelpSlave^.SlaveInfo.CompPathLen := TmpPathLen;
            pDataHelp += sizeof(UINT);
            
            // allocate memory for the module path
            pHelpSlave^.SlaveInfo.pCompPath$pVoid := To_StdLib.Malloc(size:=TmpPathLen);
            if pHelpSlave^.SlaveInfo.pCompPath = NIL then
              ClassState := -1;
              retcode := -2;
              return;
            end_if;
            
            // save compressed hardwarepath
            _memcpy(ptr1:=pHelpSlave^.SlaveInfo.pCompPath, ptr2:=pDataHelp, cntr:=TmpPathLen);
            pDataHelp += TmpPathLen;
            
            pHelpSlave^.pNext                  := NIL;
          else
            ClassState := -1;
            retcode := -2;
            return;
          end_if;          
        end_for;
      end_if;
      
      ConfigNo += 1;
      
      // check if the given size matches the memory structure
      if (pDataHelp$UDINT - pData$UDINT) <> Length then
        LogError("(SafetyManager::AddConfiguration) Invalid configuration data given (length doesn't match memory structure)");
        retcode := -3;
        return;
      end_if;
    else
      ClassState := -1;
      retcode := -2;
      return;
    end_if;
  else
    // invalid configuration
    LogError("(SafetyManager::AddConfiguration) Found invalid safety cpu configuration: Pointer or size wrong");
    retcode := -1;
  end_if;

END_FUNCTION


FUNCTION SafetyManager::FreeCfgLists
  VAR
    pHelpCfg      : ^t_CfgListElem;
    pHelpModule   : ^t_ModuleListElem;
    pHelpPdo      : ^t_PdoListElem;
  END_VAR

  while pConfigs do
    pHelpCfg := pConfigs;
    pConfigs := pConfigs^.pNext;
    
    // while we got module cfgs 
    while pHelpCfg^.pFirstModuleCfg do
      pHelpModule := pHelpCfg^.pFirstModuleCfg;
      pHelpCfg^.pFirstModuleCfg := pHelpCfg^.pFirstModuleCfg^.pNext;
      
      if pHelpModule^.ModuleInfo.pDestCRCs then
        To_StdLib.Free(pHelpModule^.ModuleInfo.pDestCRCs);  
      end_if;

      To_StdLib.Free(pHelpModule^.ModuleInfo.pPath);
      To_StdLib.Free(pHelpModule^.ModuleInfo.pCompPath);
      To_StdLib.Free(pHelpModule);
    end_while;

    // while we got pdo cfgs
    while pHelpCfg^.pFirstPdoCfg do
      pHelpPdo := pHelpCfg^.pFirstPdoCfg;
      pHelpCfg^.pFirstPdoCfg := pHelpCfg^.pFirstPdoCfg^.pNext;
      
      To_StdLib.Free(pHelpPdo^.PdoInfo.pSourcePath);
      To_StdLib.Free(pHelpPdo^.PdoInfo.pDestPath);
      To_StdLib.Free(pHelpPdo);
    end_while;
    
    To_StdLib.Free(pHelpCfg);
  end_while;
  ConfigNo := 0;

END_FUNCTION





FUNCTION SafetyManager::AddOwnCPUsToList
  VAR
  	pHelpSafety : ^t_SafetyComponent;
  END_VAR

  // check if any of the managing modules is not synchron
  if pFirstSafetyComponent then   
    pHelpSafety := pFirstSafetyComponent;
    while pHelpSafety do
      // add all safety cpus to the parameters
      if IsCPUModule(pHelpSafety^.ModuleType) then
        aSafetyCPU_Nbr[SafeCPU_Nbr_No] := pHelpSafety^.SafetyNbr;
        SafeCPU_Nbr_No += 1;
      end_if;
      
      pHelpSafety := pHelpSafety^.pNext;
    end_while;
  end_if;  

END_FUNCTION


FUNCTION SafetyManager::AllCPUConfigsArrived
	VAR_OUTPUT
		AllReady 	: BOOL;
	END_VAR
  VAR
    pHelpCfg : ^t_CfgListElem;
    i : UDINT;
    Found : BOOL;
  END_VAR

  // check if there are any CPUs
  if SafeCPU_Nbr_No then
    // if we have already all configurations (according to the number) check if they are correct
    if ConfigNo = SafeCPU_Nbr_No then
      
      // normally we should be fine now
      AllReady := TRUE;
      
      // check all safety numbers stored
      for i := 0 to SafeCPU_Nbr_No-1 do
      
        Found := FALSE;
      
        // search all configurations
        pHelpCfg := pConfigs;
        while pHelpCfg do
          // if we found a match => stop searching for this one
          if pHelpCfg^.SafetyNbr = aSafetyCPU_Nbr[i] then
            Found := TRUE;
            exit;
          end_if;
          pHelpCfg := pHelpCfg^.pNext;
        end_while;
        
        // if this configuration hasn't been found, we may have a problem
        if Found = FALSE then
          AllReady := FALSE;
          LogError("(SafetyManager::AllCPUConfigsArrived) Invalid CPU configuration found!");
          return;
        end_if;
      end_for;
    else
      AllReady := FALSE;
      
      if ConfigNo > SafeCPU_Nbr_No then
        LogError("(SafetyManager::AllCPUConfigsArrived) ERROR! More configs available than safety CPUs");
      end_if;
    end_if;
  else
    AllReady := TRUE;
    LogError("(SafetyManager::AllCPUConfigsArrived) No Safety CPU found in the system!");
  end_if;
  
END_FUNCTION


FUNCTION SafetyManager::AddLocalCPUCfg
	VAR_INPUT
		Length 	: UINT;
		pData 	: ^void;
	END_VAR
  VAR
  	pHelpLocalCfg   : ^t_LocalCfgListElem;
    EditOldCfg      : BOOL;
  END_VAR

  // if the a module wants to add the config which is already added => overwrite the old config
  EditOldCfg := FALSE;

  if pFirstLocalCPUCfg = NIL then
    pFirstLocalCPUCfg$pVoid := To_StdLib.Malloc(size:=sizeof(t_LocalCfgListElem));
    pHelpLocalCfg := pFirstLocalCPUCfg;
  else
    pHelpLocalCfg := pFirstLocalCPUCfg;
    
    if pHelpLocalCfg^.SafetyNbr = pData^$HDINT then
      EditOldCfg := TRUE;
    else
      while pHelpLocalCfg^.pNext <> NIL do
        pHelpLocalCfg := pHelpLocalCfg^.pNext;
        if pHelpLocalCfg^.SafetyNbr = pData^$HDINT then
          EditOldCfg := TRUE;
          exit;
        end_if;
      end_while;
      if EditOldCfg = FALSE then
        pHelpLocalCfg^.pNext$pVoid := To_StdLib.Malloc(size:=sizeof(t_LocalCfgListElem));

        pHelpLocalCfg := pHelpLocalCfg^.pNext;     
      end_if;
    end_if;
  end_if;
  
  if pHelpLocalCfg <> NIL then
    pHelpLocalCfg^.SafetyNbr          := pData^$HDINT;
    pHelpLocalCfg^.ConfigSize         := Length;
    pHelpLocalCfg^.pConfig            := pData;  // memory can be accessed always (never freed)
    pHelpLocalCfg^.ConfigSent2Master  := FALSE; 
    
    // only if we created a new element (incrementing has to be done last becuase of thread safety: bg increments the value and cyclic uses the list)
    if EditOldCfg = FALSE then
      pHelpLocalCfg^.pNext := NIL;
      LocalCPUCfgNo += 1;
    end_if;
  else
    ClassState := -1;
    LogError("(SafetyManager::AddLocalCPUCfg) Failed to allocate Memory for the local CPU Configuration");
  end_if;  

END_FUNCTION


FUNCTION SafetyManager::SendLocalCfgsToMaster
  VAR
  	pHelpLocalCfg : ^t_LocalCfgListElem;
    i : UDINT;
  END_VAR

  if LocalCPUCfgNo then
    pHelpLocalCfg := pFirstLocalCPUCfg;
    
    for i := 0 to (LocalCPUCfgNo-1) do
      if pHelpLocalCfg^.ConfigSize then
        // if we're the master, we keep the configuration of this cpu and share the essentials later (when we got all configurations) with all other domains (distribute the mapping)
        if AddConfiguration(pHelpLocalCfg^.ConfigSize, pHelpLocalCfg^.pConfig) <> 0 then
          LogError("(SafetyManager::SendLocalCfgsToMaster) Failed to add a safety cpu configuration to the local config-memory");
        end_if;
      end_if;
      
      pHelpLocalCfg := pHelpLocalCfg^.pNext;
    end_for;
  end_if;

END_FUNCTION


FUNCTION SafetyManager::BroadCastActPDO
  VAR
		MyPara 	  : CmdStruct;
    PdoMemSize : UINT;
    pPdoMem    : ^USINT;
    pHelp      : ^USINT;
    TmpPathLen : UINT;
    SourceDest : t_SourceDest;
    SafetyNbr           : HDINT;
  END_VAR
  
  // put pdo (marked by pActualSendPDO) into linear memory, find out who needs it and broadcast it

(*
    Memory structure:
      1 Byte: Number of Domains involved
      x Byte: 1 Byte for every involved Domain number
      1 Byte: Number of Domains in source path
      x Byte: 1 Byte for every domain in source path
      1 Byte: Number of Domains in destination path
      x Byte: 1 Byte for every domain in destination path      
      1 Byte: ID of this PDO (starting at 0)
      1 Byte: Length of PDO
      1 Byte: Is it an interface frame
      4 Byte: Interface CRC
      2 Byte: Length of source hardware path
      x Byte (depending on length in the 2 byte before): Hardwarepath of source
      2 Byte: Length of destination hardware path
      x Byte (depending on length in the 2 byte before): Hardwarepath of destination
*)

  // if it's an interface frame broadcast, don't distribute it, there are virtual PDOs to be distributed instead (if necessary)
  if pActualSendPDO^.PdoInfo.Info.IFBroadCast then
    return;
  end_if;


  // add up the sizes and allocate the memory
  PdoMemSize := sizeof(USINT) +                           // 1 byte number of domains involved
                1 +                                       // 1 byte for every involved domain
                sizeof(USINT) +                           // 1 byte number of domains in source path
                1 +                                       // 1 byte for every domain in source path
                sizeof(USINT) +                           // 1 byte number of domains in destination path
                1 +                                       // 1 byte for every domain in destination path                
                sizeof(USINT) +                           // 1 byte ID of this PDO (starting at 0)
                sizeof(USINT) +                           // 1 byte length of PDO
                sizeof(t_PdoCfgInfo) +                    // 1 byte pdo info (is it interface frame or optional...)
                sizeof(HDINT) +                           // 4 byte interface CRC
                sizeof(UINT) +                            // 2 byte length of source hardware path
                pActualSendPDO^.PdoInfo.SourcePathLen +   // x byte source hardware path
                sizeof(UINT) +                            // 2 byte length of destination hardware path
                pActualSendPDO^.PdoInfo.DestPathLen;      // x byte destination hardware path
                
  if ud_SizeTempMemCy >= PdoMemSize then
    pPdoMem := pTempMemCy$^USINT;
  else
    LogError("(SafetyManager::BroadCastActPDO) Temporary memory for cyclic task is too small!");
    LogValue(pString:="AvaliableMem: {0} / NeededMem: {1}", Value:=ud_SizeTempMemCy, Value2:=PdoMemSize);
    ClassState := -1;
    return;
  end_if;

  if pPdoMem then
    pHelp := pPdoMem;
    
    // number of domains involved
    pHelp^$USINT := 1;
    pHelp += sizeof(USINT);

    // domain number of this ack
    pHelp^$USINT := 0;
    pHelp += 1;

    // number of domains in source path
    pHelp^$USINT := 1;
    pHelp += sizeof(USINT);

    // domain numbers of source domains
    pHelp^$USINT := 0;
    pHelp += 1;
    
    // number of domains in dest path
    pHelp^$USINT := 1;
    pHelp += sizeof(USINT);

    // domain numbers of dest domains
    pHelp^$USINT := 0;
    pHelp += 1;

    pHelp^$USINT := pActualSendPDO^.PdoInfo.PDO_ID;
    pHelp += sizeof(USINT);
    
    pHelp^$USINT := pActualSendPDO^.PdoInfo.PdoLen;
    pHelp += sizeof(USINT);

    pHelp^$t_PdoCfgInfo := pActualSendPDO^.PdoInfo.Info;
    pHelp += sizeof(t_PdoCfgInfo);

    pHelp^$HDINT := pActualSendPDO^.PdoInfo.InterfaceCRC;
    pHelp += sizeof(HDINT);
    
    TmpPathLen := pActualSendPDO^.PdoInfo.SourcePathLen; // save some time with this local variable
    pHelp^$UINT := TmpPathLen;
    pHelp += sizeof(UINT);

    _memcpy(ptr1:=pHelp, ptr2:=pActualSendPDO^.PdoInfo.pSourcePath, cntr:=TmpPathLen);
    pHelp += TmpPathLen;

    TmpPathLen := pActualSendPDO^.PdoInfo.DestPathLen;
    pHelp^$UINT := TmpPathLen;
    pHelp += sizeof(UINT);

    _memcpy(ptr1:=pHelp, ptr2:=pActualSendPDO^.PdoInfo.pDestPath, cntr:=TmpPathLen);
          
    MyPara.uiCmd := CMD_SM_PDO_MAPPING_BROADCAST;
    MyPara.aPara[0] := PdoMemSize; // length of parameters
    MyPara.aPara[1] := pPdoMem$DINT;
    
    // check out if we have to work with this, and if so save the PDO info's
    if IsAffectedByPDO(#MyPara, #SourceDest, #SafetyNbr) then

    end_if;
  else
    ClassState := -1;
    LogError("(SafetyManager::BroadCastActPDO) Failed to allocate memory for the currently broadcasting PDO Info");
  end_if;

END_FUNCTION


FUNCTION SafetyManager::IsAffectedByPDO
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pSourceDest 	: ^t_SourceDest;
		pSafetyNbr 	: ^HDINT;
	END_VAR
	VAR_OUTPUT
		IsAffected 	: BOOL;
	END_VAR
  VAR
  	pHelp                 :^USINT;
    pFirstDomainAffected  : ^USINT;
    DomainsInside         : USINT;
    SourcePathLen         : UINT;
    pSourcePath           : ^USINT;
    DestPathLen           : UINT;
    pDestPath             : ^USINT;
    pHelpManaging         : ^t_ManagingComponent;
    pHelpSafety           : ^t_SafetyComponent;
    pSourceSafety         : ^t_SafetyComponent;
    pDestSafety           : ^t_SafetyComponent;
		MyPara 	              : CmdStruct;
		MyResult	            : results;
    PDO_ID                : USINT;
    Length                : USINT;
    SourceDomain          : USINT;
    DestDomain            : USINT;
    SourceDomainNo        : USINT;
    DestDomainNo          : USINT;
    aSourceDomains        : ARRAY [0..99] OF USINT;
    aDestDomains          : ARRAY [0..99] OF USINT;
    IsInterfaceFrame      : BOOL;
    InterfaceCRC          : HDINT;
    CopyCmdIndex          : INT;
    pPDOElement           : ^t_PDOElement;
    pRecyclePDO           : ^t_PDOElement;
    TempLen               : USINT;
    TempOffset            : UDINT;
    PDOInfo               : t_PdoCfgInfo;
  END_VAR

  IsAffected := FALSE;

  pSourceDest^ := SourceDest_None;
  pSafetyNbr^ := 0;

  // check the parameters
  pFirstDomainAffected := (pPara^.aPara[1])$^USINT;
  pHelp  := pFirstDomainAffected;
  
  DomainsInside := pHelp^$USINT;
  pHelp += sizeof(USINT);
  
  if DomainsInside then
    // skip the domain number
    pHelp += sizeof(USINT);

    IsAffected := TRUE;

(*
    Memory structure:
      1 Byte: Number of Domains involved
      x Byte: 1 Byte for every involved Domain number
      1 Byte: Number of Domains in source path
      x Byte: 1 Byte for every domain in source path
      1 Byte: Number of Domains in destination path
      x Byte: 1 Byte for every domain in destination path      
      1 Byte: ID of this PDO (starting at 0)
      1 Byte: Length of PDO
      1 Byte: PDO Info (Is it an interface frame, or optional...)
      4 Byte: Interface CRC
      2 Byte: Length of source hardware path
      x Byte (depending on length in the 2 byte before): Hardwarepath of source
      2 Byte: Length of destination hardware path
      x Byte (depending on length in the 2 byte before): Hardwarepath of destination
*)

    if IsAffected then
      // pHelp is now pointing to the Number of Domains in source path
    
      _memset(dest:=#aSourceDomains[0], usByte:=16#FF, cntr:=sizeof(aSourceDomains));
      _memset(dest:=#aDestDomains[0], usByte:=16#FF, cntr:=sizeof(aDestDomains));
    
      SourceDomainNo := pHelp^;
      pHelp += sizeof(USINT);

      _memcpy(ptr1:=#aSourceDomains[0], ptr2:=pHelp, cntr:=SourceDomainNo);
      pHelp += SourceDomainNo;

      DestDomainNo := pHelp^;
      pHelp += sizeof(USINT);

      _memcpy(ptr1:=#aDestDomains[0], ptr2:=pHelp, cntr:=DestDomainNo);
      pHelp += DestDomainNo;
    
      PDO_ID := pHelp^;
      pHelp += sizeof(USINT);
    
      Length := pHelp^;
      pHelp += sizeof(USINT);
      
      PDOInfo := pHelp^;
      IsInterfaceFrame := PDOInfo.IsInterfacePDO;
      pHelp += sizeof(t_PdoCfgInfo);
      
      InterfaceCRC := pHelp^$HDINT;
      pHelp += sizeof(HDINT);
      
      SourcePathLen := pHelp^$UINT;
      pHelp += sizeof(UINT);
      pSourcePath := pHelp;
      pHelp += SourcePathLen;
      DestPathLen := pHelp^$UINT;
      pHelp += sizeof(UINT);
      pDestPath := pHelp;
      
      SourceDomain := aSourceDomains[SourceDomainNo-1];
      DestDomain   := aDestDomains[DestDomainNo-1];
      
      pSourceSafety := NIL;
      pDestSafety   := NIL;
      
      // if we're the source or destination domain and there is a safety component in this system, check if it's the source or destination for this PDO
      if pFirstSafetyComponent then
        // check for source or dest module
        pHelpSafety := pFirstSafetyComponent;
        while pHelpSafety & ((pSourceSafety = NIL) | (pDestSafety = NIL)) do
          // we compare the last x byte (where x is the length of the local path including the domain)
          if (pSourceSafety = NIL) then
            // if the length matches it's in the same domain, otherwise the local search path must be shorter and there must be a domain escape sequence in the long path
            if ((pSourcePath^ = pHelpSafety^.pPath^) | ((pSourcePath^ > pHelpSafety^.pPath^) & ((pSourcePath + 1 + pSourcePath^ - pHelpSafety^.pPath^)^ = HWT_ESCAPE_DOMAIN))) & 
               (To_StdLib.MemCmp(pHelpSafety^.pPath + 1, pSourcePath + 2 + pSourcePath^ - pHelpSafety^.pPath^, pHelpSafety^.pPath^) = 0) then

              pSourceSafety := pHelpSafety;
            end_if;
          end_if;
          
          if (pDestSafety = NIL) then
            // if the length matches it's in the same domain, otherwise the local search path must be shorter and there must be a domain escape sequence in the long path
            if ((pDestPath^ = pHelpSafety^.pPath^) | ((pDestPath^ > pHelpSafety^.pPath^) & ((pDestPath + 1 + pDestPath^ - pHelpSafety^.pPath^)^ = HWT_ESCAPE_DOMAIN))) & 
               (To_StdLib.MemCmp(pHelpSafety^.pPath + 1, pDestPath + 2 + pDestPath^ - pHelpSafety^.pPath^, pHelpSafety^.pPath^) = 0) then

              pDestSafety := pHelpSafety;
              AddTimeSyncElement(pManaging:=NIL, pSafety:=pHelpSafety, IsInterfaceDomain := FALSE);
            end_if;
          end_if;
          
          pHelpSafety := pHelpSafety^.pNext;
        end_while;
      end_if;

      // use the pointer to the array element to save time
      pPDOElement := #aPDOElements[PDOElementNo];

      // here we have to check what to do with the PDO:
      // is the actual domain the source or the destination domain? or maybe both?
      if pSourceSafety & pDestSafety then
        pSourceDest^ := SourceDest_IsSourceAndDest;
        
        // only possible for interface frames
        if IsInterfaceFrame then
          // we have to tell the source, that there's a receiver for the PDO (also get the addresses)
          MyPara.uiCmd := CMD_SM_ADD_OUTPUT_PDO;
          MyPara.aPara[0] := 1;  // mark as interface frame PDO
          
          pSourceSafety^.pThis^.NewInst(#MyPara, #MyResult);

          // use a PDO element for automated removal of the input pdo in case of a new config
          pPDOElement^.PDO_ID                   := PDO_ID;
          pPDOElement^.Length                   := Length;
          pPDOElement^.ThisDomainsRole          := SourceDest_IsDest;
          pPDOElement^.SourceInfo.pPDOMem       := MyResult.aData[0]$^USINT;
          pPDOElement^.SourceInfo.pPDOMemDPRAM  := MyResult.aData[4]$^USINT;
          pPDOElement^.SourceInfo.SafetyNbr     := pSourceSafety^.SafetyNbr;
          pPDOElement^.DestInfo.SafetyNbr       := pDestSafety^.SafetyNbr;
          pPDOElement^.pSafety                  := pDestSafety;
          pPDOElement^.SourceInfo.HandlePDODPRAM:= MyResult.aData[8]$UDINT;   // Needed for Payload Support
          pPDOElement^.SourceInfo.OffsetPDODPRAM:= MyResult.aData[12]$UDINT;  // Needed for Payload Support
          PDOElementNo += 1;

          // then tell the destination about the PDO
          MyPara.uiCmd := CMD_SM_ADD_INPUT_PDO;
          MyPara.aPara[0] := pPDOElement^.SourceInfo.pPDOMem$DINT;  // we got the pointer to the local mem and the pointer to the DPRAM from the call of the source module
          MyPara.aPara[1] := pPDOElement^.SourceInfo.pPDOMemDPRAM$DINT;
          MyPara.aPara[2] := pSourceSafety^.SafetyNbr$DINT;
          MyPara.aPara[3] := Length;
          MyPara.aPara[4] := pActualSendPDO^.PdoInfo.Info.IsOptional; // only possible because this kind of PDOs is only available on Domain 0
          MyPara.aPara[5] := pPDOElement^.SourceInfo.HandlePDODPRAM$DINT; // Needed for Payload Support
          MyPara.aPara[6] := pPDOElement^.SourceInfo.OffsetPDODPRAM$DINT; // Needed for Payload Support

          pDestSafety^.pThis^.NewInst(#MyPara, #MyResult);
        else
          LogError("(SafetyManager::IsAffectedByPDO) Error in PDO distribution: No InterfaceFrame but Source and Destination in this domain!");
        end_if;        
      elsif pSourceSafety & (pDestSafety = NIL) then
        pSourceDest^ := SourceDest_IsSource;
        
        // get safety number of the source
        MyPara.uiCmd := CMD_SM_GET_SAFETY_NUMBER;
        MyPara.aPara[0] := pSafetyNbr$DINT;
        pSourceSafety^.pThis^.NewInst(#MyPara, #MyResult);
        
        pPDOElement^.PDO_ID                 := PDO_ID;
        pPDOElement^.Length                 := Length;
        pPDOElement^.ThisDomainsRole        := SourceDest_IsSource;
        
        pPDOElement^.SourceInfo.SafetyNbr   := pSafetyNbr^;
        pPDOElement^.SourceInfo.DomainNr    := SourceDomain;
        pPDOElement^.SourceInfo.PathLen     := SourcePathLen;
        pPDOElement^.SourceInfo.pPath$pVoid := To_StdLib.Malloc(size:= SourcePathLen);
        if pPDOElement^.SourceInfo.pPath then
          _memcpy(ptr1:=pPDOElement^.SourceInfo.pPath, ptr2:=pSourcePath, cntr:=SourcePathLen);
        else
          LogError("(SafetyManager::IsAffectedByPDO) Failed to allocate memory for PDO path info");
          ClassState := -1;
          return;
        end_if;

        pPDOElement^.DestInfo.SafetyNbr     := 0;
        pPDOElement^.DestInfo.DomainNr      := DestDomain;
        pPDOElement^.DestInfo.PathLen       := DestPathLen;
        pPDOElement^.DestInfo.pPath$pVoid   := To_StdLib.Malloc(size:= DestPathLen);
        if pPDOElement^.DestInfo.pPath then
          _memcpy(ptr1:=pPDOElement^.DestInfo.pPath, ptr2:=pDestPath, cntr:=DestPathLen);
        else
          LogError("(SafetyManager::IsAffectedByPDO) Failed to allocate memory for PDO path info");
          ClassState := -1;
          return;
        end_if;

        pPDOElement^.pSafety              := pSourceSafety;

        // initialize with invalid;
        CopyCmdIndex := -1;
        
        // if we're the master, we may also route interfaceframes
        if IsInterfaceFrame then
          // search for the destination of this PDO
          pHelpManaging := pFirstManagingInterfaceComponent;
          while pHelpManaging do
            if (To_StdLib.MemCmp(pHelpManaging^.pModulePath, pDestPath, DestPathLen) = 0) then
              exit;
            else
              pHelpManaging := pHelpManaging^.pNext;
            end_if;
          end_while;
        
          pPDOElement^.pManagingDest := pHelpManaging;
        end_if;

        if pPDOElement^.pManagingDest then
        
          // if the module is marked as optional and the PDO is not optional => the module is also not optional
          if pPDOElement^.pManagingDest^.InfoBits.IsOptional & (PDOInfo.IsOptional = FALSE) then
            pPDOElement^.pManagingDest^.InfoBits.IsOptional  := FALSE;
          end_if;

          // check if we can recycle the memory of another DO (if this data is already transferred to this managing module
          pRecyclePDO := CheckPDORecycle(SourceDest_IsDest, pPDOElement);

          // only if there is enough space or we already have a memory
          if pRecyclePDO | ((pPDOElement^.pManagingDest^.PDOWriteMemUsed + pPDOElement^.Length) <= pPDOElement^.pManagingDest^.PDOWriteMemAvailable) then
            
            // if we can't use the copy command
            if b_SafetyOnLocalCDIAS then
              // remember the pointer to the memory to copy it manually in rt postscan method
              if pRecyclePDO then
                // this PDO is already in the memory of the managing node, we don't have to copy it again
                pPDOElement^.DestInfo.pPDOMem := NIL;//pRecyclePDO^.DestInfo.pPDOMem;
              else
                pPDOElement^.DestInfo.pPDOMem := pPDOElement^.pManagingDest^.pPDOWriteSpace + pPDOElement^.pManagingDest^.PDOWriteMemUsed;
              end_if;
            else
              if pRecyclePDO then
                // this PDO is already in the memory of the managing node, we don't have to copy it again
                pPDOElement^.DestInfo.pPDOMemDPRAM := NIL;//pRecyclePDO^.DestInfo.pPDOMemDPRAM;
              else
                pPDOElement^.DestInfo.pPDOMemDPRAM := pPDOElement^.pManagingDest^.pPDOWriteSpaceDPRAM + pPDOElement^.pManagingDest^.PDOWriteMemUsed;
              end_if;
              
              CopyCmdIndex := GetNewMovDO();
              if CopyCmdIndex < 0 then
                if pRecyclePDO then
                  // this PDO is already in the memory of the managing node, we don't have to copy it again
                  pPDOElement^.DestInfo.pPDOMem := NIL;//pRecyclePDO^.DestInfo.pPDOMem;
                else
                  pPDOElement^.DestInfo.pPDOMem := pPDOElement^.pManagingDest^.pPDOWriteSpace + pPDOElement^.pManagingDest^.PDOWriteMemUsed;
                end_if;
                LogError("(SafetyManager::IsAffectedByPDO) Failed to install copy command => PDO is beeing copied in RT");
              else
                aCopyCmds[CopyCmdIndex].pSettings^.ud_AddressDest := pPDOElement^.DestInfo.pPDOMemDPRAM$UDINT;
                aCopyCmds[CopyCmdIndex].pSettings^.ui_ByteCnt     := pPDOElement^.Length;
              end_if;
            end_if;
            
            // if we need new memory, tell the managing module
            if pRecyclePDO = NIL then
              pPDOElement^.pManagingDest^.PDOWriteMemUsed += pPDOElement^.Length;

              MyPara.uiCmd := CMD_SM_PDO_MEM_USAGE_WR;
              MyPara.aPara[0] := pPDOElement^.pManagingDest^.PDOWriteMemUsed$DINT;
              pPDOElement^.pManagingDest^.pThis^.NewInst(#MyPara, #MyResult);
            end_if;

            if IsInterfaceFrame then
              MyPara.uiCmd := CMD_SM_ADD_OUTPUT_PDO;
              MyPara.aPara[0] := 1;  // mark as interface frame PDO
              pSourceSafety^.pThis^.NewInst(#MyPara, #MyResult);

              pPDOElement^.SourceInfo.pPDOMem       := MyResult.aData[0]$^USINT;
              pPDOElement^.SourceInfo.pPDOMemDPRAM  := MyResult.aData[4]$^USINT;
              pPDOElement^.SourceInfo.HandlePDODPRAM:= MyResult.aData[8]$UDINT;   // Needed for Payload Support
              pPDOElement^.SourceInfo.OffsetPDODPRAM:= MyResult.aData[12]$UDINT;  // Needed for Payload Support
            end_if;
          else
            // we add the memory anyway to show the user how much he would need
            pPDOElement^.pManagingDest^.PDOWriteMemUsed += pPDOElement^.Length;
            
            MyPara.uiCmd := CMD_SM_PDO_MEM_USAGE_WR;
            MyPara.aPara[0] := pPDOElement^.pManagingDest^.PDOWriteMemUsed$DINT;
            pPDOElement^.pManagingDest^.pThis^.NewInst(#MyPara, #MyResult);

            LogError("(SafetyManager::IsAffectedByPDO) Not enough write memory to map all PDOs");
            return;
          end_if;
        else
          LogError("(SafetyManager::IsAffectedByPDO) Couldn't find destination managing module for PDO");
          return;
        end_if;

        pPDOElement^.CopyCmdIndex := CopyCmdIndex;

        PDOElementNo += 1;
      elsif pDestSafety & (pSourceSafety = NIL) then
        pSourceDest^ := SourceDest_IsDest;

        // get safety number of the destination
        MyPara.uiCmd := CMD_SM_GET_SAFETY_NUMBER;
        MyPara.aPara[0] := pSafetyNbr$DINT;
        pDestSafety^.pThis^.NewInst(#MyPara, #MyResult);

        pPDOElement^.PDO_ID                 := PDO_ID;
        pPDOElement^.Length                 := Length;
        pPDOElement^.ThisDomainsRole        := SourceDest_IsDest;
        
        pPDOElement^.SourceInfo.SafetyNbr   := 0;
        pPDOElement^.SourceInfo.DomainNr    := SourceDomain;
        pPDOElement^.SourceInfo.PathLen     := SourcePathLen;
        pPDOElement^.SourceInfo.pPath$pVoid := To_StdLib.Malloc(size:= SourcePathLen);
        if pPDOElement^.SourceInfo.pPath then
          _memcpy(ptr1:=pPDOElement^.SourceInfo.pPath, ptr2:=pSourcePath, cntr:=SourcePathLen);
        else
          LogError("(SafetyManager::IsAffectedByPDO) Failed to allocate memory for PDO path info");
          ClassState := -1;
          return;
        end_if;

        pPDOElement^.DestInfo.SafetyNbr     := pSafetyNbr^;
        pPDOElement^.DestInfo.DomainNr      := DestDomain;
        pPDOElement^.DestInfo.PathLen       := DestPathLen;
        pPDOElement^.DestInfo.pPath$pVoid   := To_StdLib.Malloc(size:= DestPathLen);
        if pPDOElement^.DestInfo.pPath then
          _memcpy(ptr1:=pPDOElement^.DestInfo.pPath, ptr2:=pDestPath, cntr:=DestPathLen);
        else
          LogError("(SafetyManager::IsAffectedByPDO) Failed to allocate memory for PDO path info");
          ClassState := -1;
          return;
        end_if;

        pPDOElement^.pSafety              := pDestSafety;

        // if we're the master, we may also route interfaceframes
        if IsInterfaceFrame then

          // search for the source of this PDO
          pHelpManaging := pFirstManagingInterfaceComponent;
          while pHelpManaging do
            if (To_StdLib.MemCmp(pHelpManaging^.pModulePath, pSourcePath, SourcePathLen) = 0) then
              exit;
            else
              pHelpManaging := pHelpManaging^.pNext;
            end_if;
          end_while;

          pPDOElement^.pManagingSource := pHelpManaging;
        end_if;
        
        if pPDOElement^.pManagingSource then

          // if the module is marked as optional and the PDO is not optional => the module is also not optional
          if pPDOElement^.pManagingSource^.InfoBits.IsOptional & (PDOInfo.IsOptional = FALSE) then
            pPDOElement^.pManagingSource^.InfoBits.IsOptional  := FALSE;
          end_if;
          
          // check if we can recycle the memory of another DO (if this data is already transferred to this managing module
          pRecyclePDO := CheckPDORecycle(SourceDest_IsSource, pPDOElement);
        
          // only if there is enough space or we already have a memory
          if pRecyclePDO | ((pPDOElement^.pManagingSource^.PDOReadMemUsed + pPDOElement^.Length) <= pPDOElement^.pManagingSource^.PDOReadMemAvailable) then
            if IsInterfaceFrame then
              pPDOElement^.SourceInfo.SafetyNbr   := (GetIFInfoByCRC(InterfaceCRC, #TempOffset, #TempLen))$HDINT;
              if TempLen = Length then
                // get the place in the memory of the source managing module
                pPDOElement^.SourceInfo.pPDOMem       := pPDOElement^.pManagingSource^.pPDOReadSpace + TempOffset;
                pPDOElement^.SourceInfo.pPDOMemDPRAM  := pPDOElement^.pManagingSource^.pPDOReadSpaceDPRAM + TempOffset;
                
                pPDOElement^.SourceInfo.HandlePDODPRAM := pPDOElement^.pManagingSource^.ud_HandlePDOReadSpaceDPRAM;
                pPDOElement^.SourceInfo.OffsetPDODPRAM := TempOffset;
              
                // if we need new memory, tell the managing module
                if (TempOffset + Length) > pPDOElement^.pManagingSource^.PDOReadMemUsed then
                  pPDOElement^.pManagingSource^.PDOReadMemUsed := TempOffset + Length;
                  
                  MyPara.uiCmd := CMD_SM_PDO_MEM_USAGE_RD;
                  MyPara.aPara[0] := pPDOElement^.pManagingSource^.PDOReadMemUsed$DINT;
                  pPDOElement^.pManagingSource^.pThis^.NewInst(#MyPara, #MyResult);
                end_if;

                MyPara.uiCmd := CMD_SM_ADD_INPUT_PDO;
                MyPara.aPara[0] := pPDOElement^.SourceInfo.pPDOMem$DINT;
                MyPara.aPara[1] := pPDOElement^.SourceInfo.pPDOMemDPRAM$DINT;
                MyPara.aPara[2] := pPDOElement^.SourceInfo.SafetyNbr$DINT;
                MyPara.aPara[3] := Length;
                MyPara.aPara[4] := PDOInfo.IsOptional;
                MyPara.aPara[5] := pPDOElement^.SourceInfo.HandlePDODPRAM$DINT; // Needed for Payload Support
                MyPara.aPara[6] := pPDOElement^.SourceInfo.OffsetPDODPRAM$DINT; // Needed for Payload Support

                pDestSafety^.pThis^.NewInst(#MyPara, #MyResult);
              else
                LogError("(SafetyManager::IsAffectedByPDO) Length of interface frames doesn't match the local configuration");
              end_if;
            
            else
              if pRecyclePDO then
                pPDOElement^.SourceInfo.pPDOMem       := pRecyclePDO^.SourceInfo.pPDOMem;
                pPDOElement^.SourceInfo.pPDOMemDPRAM  := pRecyclePDO^.SourceInfo.pPDOMemDPRAM;
              else
                pPDOElement^.SourceInfo.pPDOMem       := pPDOElement^.pManagingSource^.pPDOReadSpace + pPDOElement^.pManagingSource^.PDOReadMemUsed;
                pPDOElement^.SourceInfo.pPDOMemDPRAM  := pPDOElement^.pManagingSource^.pPDOReadSpaceDPRAM + pPDOElement^.pManagingSource^.PDOReadMemUsed;
              
                // if we need new memory, tell the managing module
                pPDOElement^.pManagingSource^.PDOReadMemUsed += pPDOElement^.Length;

                MyPara.uiCmd := CMD_SM_PDO_MEM_USAGE_RD;
                MyPara.aPara[0] := pPDOElement^.pManagingSource^.PDOReadMemUsed$DINT;
                pPDOElement^.pManagingSource^.pThis^.NewInst(#MyPara, #MyResult);
              end_if;
            end_if;
          else
            // we add the memory anyway to show the user how much he would need
            pPDOElement^.pManagingSource^.PDOReadMemUsed += pPDOElement^.Length;

            MyPara.uiCmd := CMD_SM_PDO_MEM_USAGE_RD;
            MyPara.aPara[0] := pPDOElement^.pManagingSource^.PDOReadMemUsed$DINT;
            pPDOElement^.pManagingSource^.pThis^.NewInst(#MyPara, #MyResult);

            LogError("(SafetyManager::IsAffectedByPDO) Not enough read memory to map all PDOs");
            return;
          end_if;
        else

          LogError("(SafetyManager::IsAffectedByPDO) Couldn't find source managing module for PDO");
          return;
        end_if;

        PDOElementNo += 1;
      else
        pSourceDest^ := SourceDest_IsForwarder;
        
        // if source and destination are not in this domain, is it a bifurcation or a linear forwarding?
        pPDOElement^.PDO_ID                 := PDO_ID;
        pPDOElement^.Length                 := Length;
        pPDOElement^.ThisDomainsRole        := SourceDest_IsForwarder;
        
        pPDOElement^.SourceInfo.DomainNr    := SourceDomain;
        pPDOElement^.SourceInfo.PathLen     := SourcePathLen;
        pPDOElement^.SourceInfo.pPath$pVoid := To_StdLib.Malloc(size:= SourcePathLen);
        if pPDOElement^.SourceInfo.pPath then
          _memcpy(ptr1:=pPDOElement^.SourceInfo.pPath, ptr2:=pSourcePath, cntr:=SourcePathLen);
        else
          LogError("(SafetyManager::IsAffectedByPDO) Failed to allocate memory for PDO path info");
          ClassState := -1;
          return;
        end_if;

        pPDOElement^.DestInfo.DomainNr      := DestDomain;
        pPDOElement^.DestInfo.PathLen       := DestPathLen;
        pPDOElement^.DestInfo.pPath$pVoid   := To_StdLib.Malloc(size:= DestPathLen);
        if pPDOElement^.DestInfo.pPath then
          _memcpy(ptr1:=pPDOElement^.DestInfo.pPath, ptr2:=pDestPath, cntr:=DestPathLen);
        else
          LogError("(SafetyManager::IsAffectedByPDO) Failed to allocate memory for PDO path info");
          ClassState := -1;
          return;
        end_if;

        // initialize with invalid;
        CopyCmdIndex := -1;

        // if we're the master, we may also route interfaceframes
        if IsInterfaceFrame then

          // search for the source of this PDO
          pHelpManaging := pFirstManagingInterfaceComponent;
          while pHelpManaging do
            if (To_StdLib.MemCmp(pHelpManaging^.pModulePath, pSourcePath, SourcePathLen) = 0) then
              exit;
            else
              pHelpManaging := pHelpManaging^.pNext;
            end_if;
          end_while;

          pPDOElement^.pManagingSource := pHelpManaging;          
        end_if;

        if pPDOElement^.pManagingSource then
        
          // if the module is marked as optional and the PDO is not optional => the module is also not optional
          if pPDOElement^.pManagingSource^.InfoBits.IsOptional & (PDOInfo.IsOptional = FALSE) then
            pPDOElement^.pManagingSource^.InfoBits.IsOptional  := FALSE;
          end_if;

          // check if we can recycle the memory of another DO (if this data is already transferred to this managing module
          pRecyclePDO := CheckPDORecycle(SourceDest_IsSource, pPDOElement);

          if pRecyclePDO | ((pPDOElement^.pManagingSource^.PDOReadMemUsed + pPDOElement^.Length) <= pPDOElement^.pManagingSource^.PDOReadMemAvailable) then
            if pRecyclePDO then
              pPDOElement^.SourceInfo.pPDOMem       := pRecyclePDO^.SourceInfo.pPDOMem;
              pPDOElement^.SourceInfo.pPDOMemDPRAM  := pRecyclePDO^.SourceInfo.pPDOMemDPRAM;
            else
              pPDOElement^.SourceInfo.pPDOMem       := pPDOElement^.pManagingSource^.pPDOReadSpace + pPDOElement^.pManagingSource^.PDOReadMemUsed;
              pPDOElement^.SourceInfo.pPDOMemDPRAM  := pPDOElement^.pManagingSource^.pPDOReadSpaceDPRAM + pPDOElement^.pManagingSource^.PDOReadMemUsed;
              pPDOElement^.pManagingSource^.PDOReadMemUsed += pPDOElement^.Length;

              MyPara.uiCmd := CMD_SM_PDO_MEM_USAGE_RD;
              MyPara.aPara[0] := pPDOElement^.pManagingSource^.PDOReadMemUsed$DINT;
              pPDOElement^.pManagingSource^.pThis^.NewInst(#MyPara, #MyResult);
            end_if;
          else
            // we add the memory anyway to show the user how much he would need
            pPDOElement^.pManagingSource^.PDOReadMemUsed += pPDOElement^.Length;

            MyPara.uiCmd := CMD_SM_PDO_MEM_USAGE_RD;
            MyPara.aPara[0] := pPDOElement^.pManagingSource^.PDOReadMemUsed$DINT;
            pPDOElement^.pManagingSource^.pThis^.NewInst(#MyPara, #MyResult);

            LogError("(SafetyManager::IsAffectedByPDO) Not enough read memory to map all PDOs");
            return;
          end_if;
        else
          LogError("(SafetyManager::IsAffectedByPDO) Couldn't find source managing module for PDO");
          return;
        end_if;

        // if we're the master, we may also route interfaceframes
        if IsInterfaceFrame then
          // search for the destination of this PDO
          pHelpManaging := pFirstManagingInterfaceComponent;
          while pHelpManaging do
            if (To_StdLib.MemCmp(pHelpManaging^.pModulePath, pDestPath, DestPathLen) = 0) then
              exit;
            else
              pHelpManaging := pHelpManaging^.pNext;
            end_if;
          end_while;

          pPDOElement^.pManagingDest := pHelpManaging;
        end_if;

        if pPDOElement^.pManagingDest then

          // if the module is marked as optional and the PDO is not optional => the module is also not optional
          if pPDOElement^.pManagingDest^.InfoBits.IsOptional & (PDOInfo.IsOptional = FALSE) then
            pPDOElement^.pManagingDest^.InfoBits.IsOptional  := FALSE;
          end_if;

          if pPDOElement^.pManagingDest = pPDOElement^.pManagingSource then
            LogError("(SafetyManager::IsAffectedByPDO) In PDO Forwarding a domain can't be the source and the destination!");
          end_if;
          
          // check if we can recycle the memory of another DO (if this data is already transferred to this managing module
          pRecyclePDO := CheckPDORecycle(SourceDest_IsDest, pPDOElement);
        
          if pRecyclePDO | ((pPDOElement^.pManagingDest^.PDOWriteMemUsed + pPDOElement^.Length) <= pPDOElement^.pManagingDest^.PDOWriteMemAvailable) then

            // if we can't use the copy command
            if b_SafetyOnLocalCDIAS then
              // remember the pointer to the memory to copy it manually in rt postscan method
              if pRecyclePDO then
                // this PDO is already in the memory of the managing node, we don't have to copy it again
                pPDOElement^.DestInfo.pPDOMem := NIL;//pRecyclePDO^.SourceInfo.pPDOMem;
              else
                pPDOElement^.DestInfo.pPDOMem := pPDOElement^.pManagingDest^.pPDOWriteSpace + pPDOElement^.pManagingDest^.PDOWriteMemUsed;
              end_if;
            else
              if pRecyclePDO then
                // this PDO is already in the memory of the managing node, we don't have to copy it again
                pPDOElement^.DestInfo.pPDOMemDPRAM := NIL;//pRecyclePDO^.DestInfo.pPDOMemDPRAM;
              else
                pPDOElement^.DestInfo.pPDOMemDPRAM := pPDOElement^.pManagingDest^.pPDOWriteSpaceDPRAM + pPDOElement^.pManagingDest^.PDOWriteMemUsed;
              end_if;
              
              CopyCmdIndex := GetNewMovDO();
              if CopyCmdIndex < 0 then
                pPDOElement^.DestInfo.pPDOMem := pPDOElement^.pManagingDest^.pPDOWriteSpace + pPDOElement^.pManagingDest^.PDOWriteMemUsed;              
                LogError("(SafetyManager::IsAffectedByPDO) Failed to install copy command => PDO is beeing copied in RT");
              else
                aCopyCmds[CopyCmdIndex].pSettings^.ud_AddressDest := pPDOElement^.DestInfo.pPDOMemDPRAM$UDINT;
                aCopyCmds[CopyCmdIndex].pSettings^.ui_ByteCnt     := pPDOElement^.Length;
              end_if;
            end_if;

            // if we need new memory, tell the managing module
            if pRecyclePDO = NIL then
              pPDOElement^.pManagingDest^.PDOWriteMemUsed += pPDOElement^.Length;
              
              MyPara.uiCmd := CMD_SM_PDO_MEM_USAGE_WR;
              MyPara.aPara[0] := pPDOElement^.pManagingDest^.PDOWriteMemUsed$DINT;
              pPDOElement^.pManagingDest^.pThis^.NewInst(#MyPara, #MyResult);
            end_if;
          else
            // we add the memory anyway to show the user how much he would need
            pPDOElement^.pManagingDest^.PDOWriteMemUsed += pPDOElement^.Length;
            
            MyPara.uiCmd := CMD_SM_PDO_MEM_USAGE_WR;
            MyPara.aPara[0] := pPDOElement^.pManagingDest^.PDOWriteMemUsed$DINT;
            pPDOElement^.pManagingDest^.pThis^.NewInst(#MyPara, #MyResult);

            LogError("(SafetyManager::IsAffectedByPDO) Not enough write memory to map all PDOs");
            return;
          end_if;
        else
          LogError("(SafetyManager::IsAffectedByPDO) Couldn't find destination managing module for PDO");
          return;
        end_if;

        pPDOElement^.CopyCmdIndex := CopyCmdIndex;

        PDOElementNo += 1;
      end_if;
      
    end_if;
  end_if;

END_FUNCTION


FUNCTION SafetyManager::GetDestManagingOfDO
	VAR_INPUT
		pDO 	: ^SafetyCDIAS_Base::SDOHeader;
	END_VAR
	VAR_OUTPUT
		pDestManaging 	: ^t_ManagingComponent;
	END_VAR
	VAR
		pHelpManaging 	: ^t_ManagingComponent;
    i : UDINT;
	END_VAR

  pDestManaging := NIL;

  // maybe it's one of the interface domains
  pHelpManaging := pFirstManagingInterfaceComponent;
  while pHelpManaging do
    if pHelpManaging^.ModuleNo then
      for i := 0 to (pHelpManaging^.ModuleNo-1) do
        if pHelpManaging^.ModuleInfo[i].SafetyNbr = pDO^.DstAdr then
          pDestManaging := pHelpManaging;
          return;
        end_if;
      end_for;
    end_if;
  
    pHelpManaging := pHelpManaging^.pNext;
  end_while;

END_FUNCTION


FUNCTION SafetyManager::GetDestSafetyOfDO
	VAR_INPUT
		pDO 	: ^SafetyCDIAS_Base::SDOHeader;
	END_VAR
	VAR_OUTPUT
		pDestSafety 	: ^t_SafetyComponent;
	END_VAR
	VAR
		pHelpSafety 	: ^t_SafetyComponent;
	END_VAR

  pDestSafety := NIL;

  // check if it's a SDO addressed via safety number
  if (pDO^.StdHeader.Typ AND SSDO_MASK_TYPE) = FRM_TYPECODE_SSDO_MOD_TP then
    // we can't find it via Topology path
    LogError("(SafetyManager::GetDestSafetyOfDO) Misdirected SDO via Topology path. Addressee can't be found here");
    return;
  end_if;

  pHelpSafety := pFirstSafetyComponent;
  while pHelpSafety do
    if pHelpSafety^.SafetyNbr = pDO^.DstAdr then
      pDestSafety := pHelpSafety;
      return;
    end_if;
  
    pHelpSafety := pHelpSafety^.pNext;
  end_while;

END_FUNCTION


FUNCTION SafetyManager::IsOurPdoInfo
	VAR_INPUT
		pPara 	: ^CmdStruct;
	END_VAR
	VAR_OUTPUT
		ItsMine 	: BOOL;
	END_VAR
  VAR
  	pHelp : ^USINT;
    SourceDest : t_SourceDest;
    PDO_ID   : USINT;
    SafetyNbr : HDINT;
    i : UDINT;
    pHelpSafety : ^t_SafetyComponent;
    FoundIt : BOOL;
    MyPara : CmdStruct;
    MyResult : results;
    Index : INT;
    pPDOElement : ^t_PDOElement;
  END_VAR

  ItsMine := FALSE;
  
(*
    Memory structure:
      1 Byte: SourceDest_IsSource = Source safety number for destination domain / SourceDest_IsDest = Destination safety number for source domain
      1 Byte: ID of this PDO (starting at 0)
      4 Byte: Safety number of Source or Dest (according to command)
*)
  // check for the only valid length
  if pPara^.aPara[0] = 6 then
    pHelp := (pPara^.aPara[1])$^USINT;
    
    SourceDest$USINT := pHelp^;
    pHelp += sizeof(USINT);
    
    PDO_ID := pHelp^;
    pHelp += sizeof(USINT);
    
    SafetyNbr := (pHelp$^HDINT)^;

    if PDOElementNo then
      pPDOElement := #aPDOElements[0];
      for i := 0 to (PDOElementNo-1) do
        if pPDOElement^.PDO_ID = PDO_ID then
          if ((SourceDest = SourceDest_IsSource) & (pPDOElement^.SourceInfo.SafetyNbr = 0)) then
            pPDOElement^.SourceInfo.SafetyNbr := SafetyNbr;
            
            FoundIt := FALSE;
            
            pHelpSafety := pFirstSafetyComponent;
            while pHelpSafety do
              if pHelpSafety^.SafetyNbr = pPDOElement^.DestInfo.SafetyNbr then
                FoundIt := TRUE;
                exit;
              end_if;

              pHelpSafety := pHelpSafety^.pNext;
            end_while;

            // tell the module, we got a remote PDO for it
            if FoundIt & pPDOElement^.pManagingSource then
              MyPara.uiCmd := CMD_SM_ADD_INPUT_PDO;
              MyPara.aPara[0] := pPDOElement^.SourceInfo.pPDOMem$DINT;
              MyPara.aPara[1] := pPDOElement^.SourceInfo.pPDOMemDPRAM$DINT;
              MyPara.aPara[2] := SafetyNbr$DINT;
              MyPara.aPara[3] := pPDOElement^.Length;
              MyPara.aPara[4] := pPDOElement^.pManagingSource^.InfoBits.IsOptional;
              MyPara.aPara[5] := pPDOElement^.SourceInfo.HandlePDODPRAM$DINT; // Needed for Payload Support
              MyPara.aPara[6] := pPDOElement^.SourceInfo.OffsetPDODPRAM$DINT; // Needed for Payload Support

              pHelpSafety^.pThis^.NewInst(#MyPara, #MyResult);
              
              ItsMine := TRUE;
            end_if;
            
            // if this module would not be in our domain, the only logical deduction would be that this domain forwards the PDO only
            return;
          elsif ((SourceDest = SourceDest_IsDest) & (pPDOElement^.DestInfo.SafetyNbr = 0)) then
            pPDOElement^.DestInfo.SafetyNbr := SafetyNbr;
            
            // if we have the module in our domain
            if pPDOElement^.pSafety then
              MyPara.uiCmd := CMD_SM_ADD_OUTPUT_PDO;
              MyPara.aPara[0] := 0;  // mark as non-interface frame PDO
              pPDOElement^.pSafety^.pThis^.NewInst(#MyPara, #MyResult);
              
              Index := pPDOElement^.CopyCmdIndex;
              
              if Index = -1 then
                pPDOElement^.SourceInfo.pPDOMem := MyResult.aData[0]$^USINT;
              else
                aCopyCmds[Index].pSettings^.ud_AddressSrc := MyResult.aData[4]$UDINT;
                aCopyCmds[Index].b_Ready4Action := TRUE;
              end_if;
              
              pPDOElement^.SourceInfo.HandlePDODPRAM:= MyResult.aData[8]$UDINT;   // Needed for Payload Support
              pPDOElement^.SourceInfo.OffsetPDODPRAM:= MyResult.aData[12]$UDINT;  // Needed for Payload Support
              
              ItsMine := TRUE;
            end_if;
            
            // if this module would not be in our domain, the only logical deduction would be that this domain forwards the PDO only
            return;
          end_if;
        end_if;
        pPDOElement += sizeof(t_PDOElement);
      end_for;
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SafetyManager::RtWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	i : UDINT;
    pPDOElement : ^t_PDOElement;
    AllCopyCmdsReady : BOOL;
  END_VAR

  if EAX = CALL_OPTION_RT_PRESCAN then
    // prescan

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
	StartTimeMeasurement(VARANTIME_RT);
#endif
//=================================================================================================
    
    case InitSSW of
//**********************************************************************************************************************************************************
      _Wait4CopyCmdStart:
        // start all used copy commands
        AllCopyCmdsReady := TRUE;
        if CopyCmdsUsed then
          for i := 0 to (CopyCmdsUsed-1) do
            if aCopyCmds[i].b_Ready4Action then
              aCopyCmds[i].pHandle^.ucCtrlStat := VARAN_DO_CONT_RUN;
            else
              AllCopyCmdsReady := FALSE;
              bd_LogRtMessagesInCy.UnkownCopySource := TRUE;
            end_if;
          end_for;        
        end_if;
        
        if AllCopyCmdsReady then
          InitSSW := _FinishInitialisation;
        end_if;

//**********************************************************************************************************************************************************
      _InitFinished:
        // if we're master or we're actually time synchronizing
        if b_NewSyncMode & b_CheckTimeSyncTimeout then
          if (ops.tAbsolute - TimeSyncTimeStamp) > TIMESYNC_TIMEOUT then
            // increment timeout counter => message is shown in cyclic after x consecutive 
            SyncTimeoutCounter += 1;
            b_CheckTimeSyncTimeout := FALSE; // => show Trace Message only once per error
            // restart the synchronisation (maybe the other domain has been disconnected)
            b_StartTimeSync := TRUE;
          end_if;
        end_if;

//**********************************************************************************************************************************************************
    end_case;


    // marker is set in cyclic priority (except on timeout), but time synchronisation has to be done in rt priority => start it from here
    if b_StartTimeSync then
      b_StartTimeSync := FALSE;
      
      StartTimeSync();
    end_if;

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
	StopTimeMeasurement(VARANTIME_RT);
#endif
//=================================================================================================

  else
    // postscan
    
//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
	StartTimeMeasurement(VARANTIME_RTPOSTSCAN);
#endif
//=================================================================================================

    // copy data from our memory to the memory of the next domain
    if PDOElementNo then
      pPDOElement := #aPDOElements[0];
      for i := 0 to (PDOElementNo-1) do       
        if (pPDOElement^.ThisDomainsRole = SourceDest_IsSource) |
           (pPDOElement^.ThisDomainsRole = SourceDest_IsForwarder) then
          if pPDOElement^.DestInfo.pPDOMem & pPDOElement^.SourceInfo.pPDOMem & pPDOElement^.Length then
            _memcpy(ptr1:=pPDOElement^.DestInfo.pPDOMem, ptr2:=pPDOElement^.SourceInfo.pPDOMem, cntr:=pPDOElement^.Length);          
          end_if;
        end_if;
        pPDOElement += sizeof(t_PDOElement);
      end_for;
    end_if;

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
	StopTimeMeasurement(VARANTIME_RTPOSTSCAN);
#endif
//=================================================================================================

  end_if;

#ifdef SAFETY_DEBUG_LOGGING_ACTIVATED
  if InitSSW <> OldInitSSW then
#ifdef SAFETY_DEBUG_TRACING_ACTIVATED
    LogValue(pString:="(SafetyManager::RtWork) InitSSW changed from {0} to {1}", Value:=OldInitSSW, Value2:=InitSSW);
#endif
    LogBuf[ActLogIndex].NewState := InitSSW;
    LogBuf[ActLogIndex].OldState := OldInitSSW;
    LogBuf[ActLogIndex].Command := 0;
    LogBuf[ActLogIndex].TimeSinceLastLog_us := OS_READMICROSEC();
    LogBuf[ActLogIndex].TimeSinceLastLog_us -= TimeStampLastLog_us;
    TimeStampLastLog_us := OS_READMICROSEC();
    if ActLogIndex = (LogBufferSize - 1) then
      ActLogIndex := 0;
    else
      ActLogIndex += 1;
    end_if;
  end_if;
  OldInitSSW := InitSSW;
#endif

	state := READY;

END_FUNCTION


FUNCTION SafetyManager::CheckTopSDO
	VAR_INPUT
		pPara 	: ^CmdStruct;
	END_VAR
  VAR
    pDO 	            : ^SafetyCDIAS_Base::SDOHeader;
    pCompDestPath     : ^USINT;
    pHelpConfig       : ^t_CfgListElem;
    pHelpSlave        : ^t_SlaveListElem;
    pHelpModule       : ^t_ModuleListElem;
    pHelpPdo          : ^t_PdoListElem;
    pHelpManaging     : ^t_ManagingComponent;
    pHelpSafety       : ^t_SafetyComponent;
    MyPara            : CmdStruct;
    MyResult          : results;
    pTempMem          : ^USINT;
    pHelp             : ^USINT;
    TmpPathLen        : UINT;
    DomainChangeFound : BOOL;
    i                 : UINT;
    DestDomain        : USINT;
    InterfaceCRC      : HDINT;
  END_VAR

  // get a pointer to the compressed destination path
  pDO := (pPara^.aPara[1])$^SafetyCDIAS_Base::SDOHeader;
  pCompDestPath := (#pDO^.DstAdr)$^USINT;

  // if we have interfaceframes, check them first
  if pFirstManagingInterfaceComponent & (pCompDestPath^ = INTERFACE_CRC_MODE) then
    // after the mode byte we find the interface CRC
    InterfaceCRC := ((pCompDestPath + 1)$^HDINT)^;

    // check if we have an interface frame with this CRC
    pHelpConfig := pConfigs;
    while pHelpConfig do
      pHelpPdo := pHelpConfig^.pFirstPdoCfg;
      while pHelpPdo do
        // don't look at IFBroatCast PDOs, they are not distributed
        if (pHelpPdo^.PdoInfo.InterfaceCRC = InterfaceCRC) then

          // if we found the CRC, forward it to the source of the PDO (the destination asks for the safety number)

          // check the source

          // if the master itself is the caller, it's from this system
          if (pPara^.aPara[2] = this$DINT) then
            pHelpManaging := pFirstManagingInterfaceComponent;
            while pHelpManaging do
              if (To_StdLib.MemCmp(pHelpManaging^.pModulePath, pHelpPdo^.PdoInfo.pSourcePath, pHelpPdo^.PdoInfo.SourcePathLen) = 0) then
                exit;
              else
                pHelpManaging := pHelpManaging^.pNext;
              end_if;
            end_while;

            if pHelpManaging then
              if pHelpManaging^.InfoBits.IsSynchron then
                pHelpManaging^.pThis^.NewInst(pPara, #MyResult);
              end_if;
            else
              // no managing module found => continue search in our special safety module list
              pHelpSafety := NIL;
              if LocalIFNo then
                for i := 0 to (LocalIFNo-1) do
                  if aLocalIFs[i].InterfaceCRC = InterfaceCRC then
                    // found it
                    pHelpSafety := aLocalIFs[i].pSafetyModule;
                    exit;
                  end_if;
                end_for;
              end_if;
              
              if pHelpSafety then
                // change the command, because now we forward it to the receiver
                pPara^.uiCmd := CMD_SM_SDO_TO_MODULE;

                pHelpSafety^.pThis^.NewInst(pPara, #MyResult);
              else
                // check the slave modules if there is one with the interface frame we need
                pHelpConfig := pConfigs;
                while pHelpConfig do
                  pHelpSlave := pHelpConfig^.pFirstSlaveCfg;
                  while pHelpSlave do

                    if (pHelpSlave^.SlaveInfo.Info.IsInterface) & (pHelpSlave^.SlaveInfo.InterfaceCRC = InterfaceCRC) then
                      // we have to add some additional information to the message

                      (*
                        Memory structure:
                          1 Byte destination domain
                          1 Byte IsInterfaceFrame (0/1)
                          2 Byte length of uncompressed path
                          x Byte uncompressed path
                          x Byte SDO message
                      *)
                      
                      MyPara.uiCmd := CMD_SM_TOP_SDO_TO_MODULE;
                      MyPara.aPara[0] := sizeof(USINT) + sizeof(BOOL) + sizeof(UINT) + pHelpSlave^.SlaveInfo.PathLen + pPara^.aPara[0];
                      
                      if ud_SizeTempMemCy >= MyPara.aPara[0]$UDINT then
                        pTempMem := pTempMemCy$^USINT;
                      else
                        LogError("(SafetyManager::CheckTopSDO) Temporary memory for cyclic task is too small!");
                        LogValue(pString:="AvaliableMem: {0} / NeededMem: {1}", Value:=ud_SizeTempMemCy, Value2:=MyPara.aPara[0]$UDINT);
                        return;
                      end_if;

                      TmpPathLen := pHelpSlave^.SlaveInfo.PathLen; // save some time with this local variable
                      DomainChangeFound := FALSE;
                      pHelp := pHelpSlave^.SlaveInfo.pPath + TmpPathLen - 2; // pointer on penultimate byte of path
                      // search from the end for the last domain change
                      for i := (TmpPathLen-2) to 3 by -1 do
                        if pHelp^ = HWT_ESCAPE_DOMAIN then
                          DomainChangeFound := TRUE;
                          DestDomain := (pHelp + 1)^;
                          exit;
                        end_if;
                        
                        pHelp -= sizeof(USINT);
                      end_for;

                      // if there was no domainchange
                      if DomainChangeFound = FALSE then
                        // the master is the Dest
                        DestDomain := (pHelpSlave^.SlaveInfo.pPath + 2)^;
                      end_if;

                      pHelp := pTempMem;
                      
                      // destination domain
                      pHelp^ := DestDomain;
                      pHelp += sizeof(USINT);

                      // is it for an interface frame?
                      pHelp^$BOOL := TRUE;
                      pHelp += sizeof(BOOL);

                      // length of uncompressed path
                      pHelp^$UINT := TmpPathLen;
                      pHelp += sizeof(UINT);

                      // uncompressed path
                      _memcpy(ptr1:=pHelp, ptr2:=pHelpSlave^.SlaveInfo.pPath, cntr:=TmpPathLen);
                      pHelp += TmpPathLen;
                      
                      // SDO message
                      _memcpy(ptr1:=pHelp, ptr2:=pDO, cntr:=pPara^.aPara[0]$UDINT);
                      
                      MyPara.aPara[1] := pTempMem$DINT;
                      
                      NewInst(#MyPara, #MyResult);

                      // path can exist only once in a system
                      return;
                    end_if;
                    
                    pHelpSlave := pHelpSlave^.pNext;
                  end_while;
                  
                  pHelpConfig := pHelpConfig^.pNext;
                end_while;

                LogError("(SafetyManager::CheckTopSDO) Couldn't find target of SDO via TOP (Interface Frame)");
                LogValue(pString:="SrcAddr: {0} / InterfaceCRC: {1}", Value:=pDO^.SrcAdr, Value2:=InterfaceCRC);
              end_if;
            end_if;
          else
            // we have to add some additional information to the message

            (*
              Memory structure:
                1 Byte destination domain
                1 Byte IsInterfaceFrame (0/1)
                2 Byte length of uncompressed path
                x Byte uncompressed path
                x Byte SDO message
            *)
            
            MyPara.uiCmd := CMD_SM_TOP_SDO_TO_MODULE;
            MyPara.aPara[0] := sizeof(USINT) + sizeof(BOOL) + sizeof(UINT) + pHelpPdo^.PdoInfo.SourcePathLen + pPara^.aPara[0];
            
            if ud_SizeTempMemCy >= MyPara.aPara[0]$UDINT then
              pTempMem := pTempMemCy$^USINT;
            else
              LogError("(SafetyManager::CheckTopSDO) Temporary memory for cyclic task is too small!");
              LogValue(pString:="AvaliableMem: {0} / NeededMem: {1}", Value:=ud_SizeTempMemCy, Value2:=MyPara.aPara[0]$UDINT);
              return;
            end_if;

            TmpPathLen := pHelpPdo^.PdoInfo.SourcePathLen; // save some time with this local variable
            DomainChangeFound := FALSE;
            pHelp := pHelpPdo^.PdoInfo.pSourcePath + TmpPathLen - 2; // pointer on penultimate byte of path
            // search from the end for the last domain change
            for i := (TmpPathLen-2) to 3 by -1 do
              if pHelp^ = HWT_ESCAPE_DOMAIN then
                DomainChangeFound := TRUE;
                DestDomain := (pHelp + 1)^;
                exit;
              end_if;
              
              pHelp -= sizeof(USINT);
            end_for;

            // if there was no domainchange
            if DomainChangeFound = FALSE then
              // the master is the Dest
              DestDomain := (pHelpPdo^.PdoInfo.pSourcePath + 2)^;
            end_if;

            pHelp := pTempMem;
            
            // destination domain
            pHelp^ := DestDomain;
            pHelp += sizeof(USINT);

            // is it for an interface frame?
            pHelp^$BOOL := TRUE;
            pHelp += sizeof(BOOL);

            // length of uncompressed path
            pHelp^$UINT := TmpPathLen;
            pHelp += sizeof(UINT);

            // uncompressed path
            _memcpy(ptr1:=pHelp, ptr2:=pHelpPdo^.PdoInfo.pSourcePath, cntr:=TmpPathLen);
            pHelp += TmpPathLen;
            
            // SDO message
            _memcpy(ptr1:=pHelp, ptr2:=pDO, cntr:=pPara^.aPara[0]$UDINT);
            
            MyPara.aPara[1] := pTempMem$DINT;
            
            NewInst(#MyPara, #MyResult);
            
          end_if;
          // path can exist only once in a system
          return;
        end_if;
      
        pHelpPdo := pHelpPdo^.pNext;
      end_while;
    
      pHelpConfig := pHelpConfig^.pNext;
    end_while;

    // check if there is any interface frame domain optional and not available
    pHelpManaging := pFirstManagingInterfaceComponent;
    while pHelpManaging do
      if (pHelpManaging^.InfoBits.IsSynchron = 0) & (pHelpManaging^.InfoBits.IsOptional = 1) then
        // found one => no error here
        return;
      end_if;
    
      pHelpManaging := pHelpManaging^.pNext;
    end_while;

    // no optional interface domains missing => must be an error
    LogError("(SafetyManager::CheckTopSDO) Couldn't find InterfaceCRC. Check SafetyDesigner projects, most likely the interface variables doesn't match.");
    LogValue(pString:="SrcAddr: {0} / InterfaceCRC: {1}", Value:=pDO^.SrcAdr, Value2:=InterfaceCRC);
    ClassState := -8;
    
  // check if it's a local interface frame and we have no interface frame domains
  elsif (pCompDestPath^ = INTERFACE_CRC_MODE) then
    // after the mode byte we find the interface CRC
    InterfaceCRC := ((pCompDestPath + 1)$^HDINT)^;

    // search for the CRC
    pHelpSafety := NIL;
    if LocalIFNo then
      for i := 0 to (LocalIFNo-1) do
        if aLocalIFs[i].InterfaceCRC = InterfaceCRC then
          // found it
          pHelpSafety := aLocalIFs[i].pSafetyModule;
          exit;
        end_if;
      end_for;
    end_if;

    if pHelpSafety then
      // change the command, because now we forward it to the receiver
      pPara^.uiCmd := CMD_SM_SDO_TO_MODULE;

      pHelpSafety^.pThis^.NewInst(pPara, #MyResult);
    else
      // check the slave modules if there is one with the interface frame we need
      pHelpConfig := pConfigs;
      while pHelpConfig do
        pHelpSlave := pHelpConfig^.pFirstSlaveCfg;
        while pHelpSlave do

          if (pHelpSlave^.SlaveInfo.Info.IsInterface) & (pHelpSlave^.SlaveInfo.InterfaceCRC = InterfaceCRC) then
            // we have to add some additional information to the message

            (*
              Memory structure:
                1 Byte destination domain
                1 Byte IsInterfaceFrame (0/1)
                2 Byte length of uncompressed path
                x Byte uncompressed path
                x Byte SDO message
            *)
            
            MyPara.uiCmd := CMD_SM_TOP_SDO_TO_MODULE;
            MyPara.aPara[0] := sizeof(USINT) + sizeof(BOOL) + sizeof(UINT) + pHelpSlave^.SlaveInfo.PathLen + pPara^.aPara[0];
            
            if ud_SizeTempMemCy >= MyPara.aPara[0]$UDINT then
              pTempMem := pTempMemCy$^USINT;
            else
              LogError("(SafetyManager::CheckTopSDO) Temporary memory for cyclic task is too small!");
              LogValue(pString:="AvaliableMem: {0} / NeededMem: {1}", Value:=ud_SizeTempMemCy, Value2:=MyPara.aPara[0]$UDINT);
              return;
            end_if;

            TmpPathLen := pHelpSlave^.SlaveInfo.PathLen; // save some time with this local variable
            DomainChangeFound := FALSE;
            pHelp := pHelpSlave^.SlaveInfo.pPath + TmpPathLen - 2; // pointer on penultimate byte of path
            // search from the end for the last domain change
            for i := (TmpPathLen-2) to 3 by -1 do
              if pHelp^ = HWT_ESCAPE_DOMAIN then
                DomainChangeFound := TRUE;
                DestDomain := (pHelp + 1)^;
                exit;
              end_if;
              
              pHelp -= sizeof(USINT);
            end_for;

            // if there was no domainchange
            if DomainChangeFound = FALSE then
              // the master is the Dest
              DestDomain := (pHelpSlave^.SlaveInfo.pPath + 2)^;
            end_if;

            pHelp := pTempMem;
            
            // destination domain
            pHelp^ := DestDomain;
            pHelp += sizeof(USINT);

            // is it for an interface frame?
            pHelp^$BOOL := TRUE;
            pHelp += sizeof(BOOL);

            // length of uncompressed path
            pHelp^$UINT := TmpPathLen;
            pHelp += sizeof(UINT);

            // uncompressed path
            _memcpy(ptr1:=pHelp, ptr2:=pHelpSlave^.SlaveInfo.pPath, cntr:=TmpPathLen);
            pHelp += TmpPathLen;
            
            // SDO message
            _memcpy(ptr1:=pHelp, ptr2:=pDO, cntr:=pPara^.aPara[0]$UDINT);
            
            MyPara.aPara[1] := pTempMem$DINT;
            
            NewInst(#MyPara, #MyResult);

            // path can exist only once in a system
            return;
          end_if;        
          
          pHelpSlave := pHelpSlave^.pNext;
        end_while;
        
        pHelpConfig := pHelpConfig^.pNext;
      end_while;

      LogError("(SafetyManager::CheckTopSDO) Couldn't find target of SDO via TOP (Local Interface Frame)");
      LogValue(pString:="SrcAddr: {0} / InterfaceCRC: {1}", Value:=pDO^.SrcAdr, Value2:=InterfaceCRC);
    end_if;    
  else
    // check if we have a module with this path
    pHelpConfig := pConfigs;
    while pHelpConfig do
      pHelpModule := pHelpConfig^.pFirstModuleCfg;
      while pHelpModule do
        if (To_StdLib.MemCmp(pCompDestPath, pHelpModule^.ModuleInfo.pCompPath, pHelpModule^.ModuleInfo.CompPathLen) = 0) then       
          // we have to add some additional information to the message
          
          (*
            Memory structure:
              1 Byte destination domain
              1 Byte IsInterfaceFrame (0/1)
              2 Byte length of uncompressed path
              x Byte uncompressed path
              x Byte SDO message
          *)
          
          TmpPathLen := pHelpModule^.ModuleInfo.PathLen; // save some time with this local variable
          MyPara.uiCmd := CMD_SM_TOP_SDO_TO_MODULE;
          MyPara.aPara[0] := sizeof(USINT) + sizeof(BOOL) + sizeof(UINT) + TmpPathLen + pPara^.aPara[0];
          if ud_SizeTempMemCy >= MyPara.aPara[0]$UDINT then
            pTempMem := pTempMemCy$^USINT;
          else
            LogError("(SafetyManager::CheckTopSDO) Temporary memory for cyclic task is too small!");
            LogValue(pString:="AvaliableMem: {0} / NeededMem: {1}", Value:=ud_SizeTempMemCy, Value2:=MyPara.aPara[0]$UDINT);
            return;
          end_if;

          DomainChangeFound := FALSE;
          pHelp := pHelpModule^.ModuleInfo.pPath + TmpPathLen - 2; // pointer on penultimate byte of path
          // search from the end for the last domain change
          for i := (TmpPathLen-2) to 3 by -1 do
            if pHelp^ = HWT_ESCAPE_DOMAIN then
              DomainChangeFound := TRUE;
              DestDomain := (pHelp + 1)^;
              exit;
            end_if;
            
            pHelp -= sizeof(USINT);
          end_for;

          // if there was no domainchange
          if DomainChangeFound = FALSE then
            // the master is the Dest
            DestDomain := (pHelpModule^.ModuleInfo.pPath + 2)^;
          end_if;

          pHelp := pTempMem;
          
          // destination domain
          pHelp^ := DestDomain;
          pHelp += sizeof(USINT);

          // is it for an interface frame?
          pHelp^$BOOL := FALSE;
          pHelp += sizeof(BOOL);

          // length of uncompressed path
          pHelp^$UINT := TmpPathLen;
          pHelp += sizeof(UINT);

          // uncompressed path
          _memcpy(ptr1:=pHelp, ptr2:=pHelpModule^.ModuleInfo.pPath, cntr:=TmpPathLen);
          pHelp += TmpPathLen;
          
          // SDO message
          _memcpy(ptr1:=pHelp, ptr2:=pDO, cntr:=pPara^.aPara[0]$UDINT);
          
          MyPara.aPara[1] := pTempMem$DINT;
          
          NewInst(#MyPara, #MyResult);
          
          // path can exist only once in a system
          return;
        end_if;
      
        pHelpModule := pHelpModule^.pNext;
      end_while;

      if pHelpConfig^.SafetyNbr = pDO^.SrcAdr then
        pHelpSlave := pHelpConfig^.pFirstSlaveCfg;
        while pHelpSlave do
          if (To_StdLib.MemCmp(pCompDestPath, pHelpSlave^.SlaveInfo.pCompPath, pHelpSlave^.SlaveInfo.CompPathLen) = 0) then
            // we have to add some additional information to the message
            
            (*
              Memory structure:
                1 Byte destination domain
                1 Byte IsInterfaceFrame (0/1)
                2 Byte length of uncompressed path
                x Byte uncompressed path
                x Byte SDO message
            *)
            
            TmpPathLen := pHelpSlave^.SlaveInfo.PathLen; // save some time with this local variable
            MyPara.uiCmd := CMD_SM_TOP_SDO_TO_MODULE;
            MyPara.aPara[0] := sizeof(USINT) + sizeof(BOOL) + sizeof(UINT) + TmpPathLen + pPara^.aPara[0];
            if ud_SizeTempMemCy >= MyPara.aPara[0]$UDINT then
              pTempMem := pTempMemCy$^USINT;
            else
              LogError("(SafetyManager::CheckTopSDO) Temporary memory for cyclic task is too small!");
              LogValue(pString:="AvaliableMem: {0} / NeededMem: {1}", Value:=ud_SizeTempMemCy, Value2:=MyPara.aPara[0]$UDINT);
              return;
            end_if;

            DomainChangeFound := FALSE;
            pHelp := pHelpSlave^.SlaveInfo.pPath + TmpPathLen - 2; // pointer on penultimate byte of path
            // search from the end for the last domain change
            for i := (TmpPathLen-2) to 3 by -1 do
              if pHelp^ = HWT_ESCAPE_DOMAIN then
                DomainChangeFound := TRUE;
                DestDomain := (pHelp + 1)^;
                exit;
              end_if;
              
              pHelp -= sizeof(USINT);
            end_for;

            // if there was no domainchange
            if DomainChangeFound = FALSE then
              // the master is the Dest
              DestDomain := (pHelpSlave^.SlaveInfo.pPath + 2)^;
            end_if;

            pHelp := pTempMem;
            
            // destination domain
            pHelp^ := DestDomain;
            pHelp += sizeof(USINT);

            // is it for an interface frame?
            pHelp^$BOOL := FALSE;
            pHelp += sizeof(BOOL);

            // length of uncompressed path
            pHelp^$UINT := TmpPathLen;
            pHelp += sizeof(UINT);

            // uncompressed path
            _memcpy(ptr1:=pHelp, ptr2:=pHelpSlave^.SlaveInfo.pPath, cntr:=TmpPathLen);
            pHelp += TmpPathLen;
            
            // SDO message
            _memcpy(ptr1:=pHelp, ptr2:=pDO, cntr:=pPara^.aPara[0]$UDINT);
            
            MyPara.aPara[1] := pTempMem$DINT;
            
            NewInst(#MyPara, #MyResult);
            
            // path can exist only once in a system
            return;
          end_if;
          
          pHelpSlave := pHelpSlave^.pNext;
        end_while;
      end_if;
    
      pHelpConfig := pHelpConfig^.pNext;
    end_while;

    LogError("(SafetyManager::CheckTopSDO) Couldn't find destination of SDO. (Compressed Topology Path)");
    LogValue(pString:="SrcAddr: {0} / InterfaceCRC: {1}", Value:=pDO^.SrcAdr, Value2:=((pCompDestPath + 1)$^HDINT)^);

  end_if;

END_FUNCTION


FUNCTION SafetyManager::TopSDODest
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
	VAR_OUTPUT
		IsDestDomain 	: BOOL;
	END_VAR
  VAR
  	pHelpUSINT : ^USINT;
    PathLength : UINT;
    pPath : ^USINT;
    pHelpSafety : ^t_SafetyComponent;
  END_VAR

  IsDestDomain := FALSE;
(*
  Memory structure:
    1 Byte destination domain
    1 Byte IsInterfaceFrame (0/1)
    2 Byte length of uncompressed path
    x Byte uncompressed path
    x Byte SDO message
*)
  
  // check size (at least 1 byte for the destination domain + 2 byte for the path length + the header of the SDO message)
  if pPara^.aPara[0] > (sizeof(USINT) + sizeof(PathLength) + sizeof(SafetyCDIAS_Base::SDOHeader.StdHeader)) then
    pHelpUSINT := (pPara^.aPara[1])$^USINT;
    
    // domain
    pHelpUSINT += sizeof(USINT);
    
    // is it an interface frame info?
    pHelpUSINT += sizeof(BOOL);

    // path length
    PathLength := (pHelpUSINT$^UINT)^;
    pHelpUSINT += sizeof(UINT);
    
    // path
    pPath := pHelpUSINT;
    pHelpUSINT += PathLength;
    
    // pHelpUSINT points now to the SDO message
    
    // now we search the logged in modules for one with a matching topology path
    if pFirstSafetyComponent then

      pHelpSafety := pFirstSafetyComponent;
      while pHelpSafety do
        // we compare the last x byte (where x is the length of the local path including the domain)
        if (To_StdLib.MemCmp(pHelpSafety^.pPath + 1, pPath + 2 + pPath^ - pHelpSafety^.pPath^, pHelpSafety^.pPath^) = 0) then
          pPara^.uiCmd := CMD_SM_SDO_TO_MODULE;
          pPara^.aPara[0] := pPara^.aPara[0] - (sizeof(USINT) + sizeof(PathLength) + PathLength);
          pPara^.aPara[1] := pHelpUSINT$DINT;
          
          pHelpSafety^.pThis^.NewInst(pPara, pResult);
          
          IsDestDomain := TRUE;
          return;
        end_if;
        
        pHelpSafety := pHelpSafety^.pNext;
      end_while;
    end_if;
  end_if;  

END_FUNCTION


FUNCTION SafetyManager::PDOLengthCorrection
  VAR
  	pHelpConfig : ^t_CfgListElem;
    pHelpPDO    : ^t_PdoListElem;
    pHelpModule : ^t_ModuleListElem;
    pHelpSearchConfig : ^t_CfgListElem;
    FoundIt : BOOL;
    GotFirst : BOOL;
  END_VAR

  GotFirst := FALSE;

  // check if there is a PDO with a zero length
  pHelpConfig := pConfigs;
  while pHelpConfig do
    pHelpPDO := pHelpConfig^.pFirstPdoCfg;
    while pHelpPDO do
      // remember the first PDO found as our act (to start from)
      if GotFirst = FALSE then
        GotFirst := TRUE;
        
        pActualSendCfg := pHelpConfig;
        pActualSendPDO := pHelpPDO;
      end_if;
    
      // if there is a PDO with no length
      if pHelpPDO^.PdoInfo.PdoLen = 0 then
        FoundIt := FALSE;
        pHelpSearchConfig := pConfigs;
        // search for the source module, because we use the length of it
        while pHelpSearchConfig & (FoundIt = FALSE) do
          pHelpModule := pHelpSearchConfig^.pFirstModuleCfg;
          while pHelpModule & (FoundIt = FALSE) do
            if pHelpModule^.ModuleInfo.PathLen = pHelpPDO^.PdoInfo.SourcePathLen then
              if (To_StdLib.MemCmp(pHelpModule^.ModuleInfo.pPath, pHelpPDO^.PdoInfo.pSourcePath, pHelpModule^.ModuleInfo.PathLen) = 0) then
                pHelpPDO^.PdoInfo.PdoLen := pHelpModule^.ModuleInfo.PdoOutLen;
                FoundIt := TRUE;
              end_if;
            end_if;
          
            pHelpModule := pHelpModule^.pNext;
          end_while;

          pHelpSearchConfig := pHelpSearchConfig^.pNext;
        end_while;      
      end_if;
    
      pHelpPDO := pHelpPDO^.pNext;
    end_while;
    
    pHelpConfig := pHelpConfig^.pNext;
  end_while;

END_FUNCTION


FUNCTION SafetyManager::DoublePDOEntry
	VAR_INPUT
		NewPDO 	: t_PdoCfg;
		pNewCfg 	: ^t_CfgListElem;
	END_VAR
	VAR_OUTPUT
		IsDoubleEntry 	: BOOL;
	END_VAR
  VAR
  	pHelpCfg : ^t_CfgListElem;
    pHelpPdo : ^t_PdoListElem;
  END_VAR

  IsDoubleEntry := FALSE;

  // if it's our first config, there is no chance for a double PDO => check only if not first config
  if pNewCfg <> pConfigs then
    // otherwise: search all prior configs for the same PDO (source and destination path match)    
    pHelpCfg := pConfigs;
    while pHelpCfg <> pNewCfg do
      pHelpPdo := pHelpCfg^.pFirstPdoCfg;
      while pHelpPdo do
        if (pHelpPdo^.PdoInfo.SourcePathLen = NewPDO.SourcePathLen) & (pHelpPdo^.PdoInfo.DestPathLen = NewPDO.DestPathLen) & 
           (To_StdLib.MemCmp(pHelpPdo^.PdoInfo.pSourcePath, NewPDO.pSourcePath, NewPDO.SourcePathLen) = 0) & 
           (To_StdLib.MemCmp(pHelpPdo^.PdoInfo.pDestPath, NewPDO.pDestPath, NewPDO.DestPathLen) = 0) then
          // we found the same PDO in a prior config
          IsDoubleEntry := TRUE;
          return;
        end_if;
      
        pHelpPdo := pHelpPdo^.pNext;
      end_while;

      pHelpCfg := pHelpCfg^.pNext;
    end_while;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyManager::LogError
	VAR_INPUT
		e_msg 	: ^CHAR;
	END_VAR
  VAR
    sz_name : ARRAY [ 0..255 ] OF CHAR;
  END_VAR

  _GetObjName( this, #sz_name[ 0 ] );
  
  MyTrace(pFormat:="Object {0}: {1}", pTxt0:=(#sz_name[ 0 ])$^CHAR, pTxt1:= e_msg, pTxt2:=NIL);

END_FUNCTION


FUNCTION VIRTUAL SafetyManager::MyTrace
	VAR_INPUT
		pFormat 	: ^CHAR;
		pTxt0 	: ^CHAR;
		pTxt1 	: ^CHAR;
		pTxt2 	: ^CHAR;
	END_VAR
  VAR
    nLen      : UDINT;
    pChr      : ^CHAR;
    nTxt      : UDINT;
    nRpl      : UDINT;
    pTxt      : ^CHAR;
    pText     : ^CHAR;
    FormText  : ARRAY [0 .. 255] OF CHAR;
  END_VAR

  // this method is a workaround for the TRACE message limitation problem

  pText := #FormText[0];

  _memset(dest:=#FormText[0], usByte:=0, cntr:=256); // to keep the zero termination

  _strncpy(pText, pFormat, 250);
  nLen  := _strlen(pText);
  pChr  := pText;
  
  WHILE nLen DO
    IF pChr^ = '{' THEN         // works for the first 10 replacement texts (single digit numbers)
      nTxt  := (pChr+1)^ - '0';
      CASE nTxt OF
        0:  pTxt  := pTxt0;
        1:  pTxt  := pTxt1;
        2:  pTxt  := pTxt2;
      ELSE
        pTxt  := "INV";
      END_CASE;
      nRpl  := _strlen(pTxt);
      if nLen - 3 + nRpl > 250 then
        pTxt := "LEN";  // replace the replacement text with "LEN" to see that we're out of length for this string
        nRpl := 3;
      end_if;
      _memmove(pChr + nRpl, pChr + 3, nLen);
      _memcpy(pChr, pTxt, nRpl);
      pChr  += nRpl;  // next character to parse is after the replacement text
      nLen  -= 3;     // the remaining length of the format string is decremented by 3
      if nLen > 250 then  // catch overrun of nLen
        nLen := 0;
      end_if;
    ELSE
      pChr  += 1;
      nLen  -= 1;
    END_IF;
  END_WHILE;

  TRACE(#FormText[0]);
  if ( p_KernelLog ) then
    OS_KERNELLOG0(#FormText[0]);
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SafetyManager::LogValue
	VAR_INPUT
		pString 	: ^CHAR;
		Value 	: UDINT;
		Value2 	: UDINT;
		Value3 	: UDINT;
	END_VAR
  VAR
    TempStr       : ARRAY [0..99] OF CHAR;
    TempStr2      : ARRAY [0..99] OF CHAR;
    TempStr3      : ARRAY [0..99] OF CHAR;
    TraceVal      : USINT;
    sz_name       : ARRAY [ 0..255 ] OF CHAR;
    TmpWithObjName: ARRAY [ 0..255 ] OF CHAR;
  END_VAR

  // number of values
  TraceVal := 1;

  _itoa(Value, #TempStr[0]);
  
  if pString <> NIL then
    _GetObjName( this, #sz_name[ 0 ] );
    _strcpy(dest:=#TmpWithObjName[0], src:="ObjectName ");
    _strcat(dest:=#TmpWithObjName[0], src:=#sz_name[0]);
    _strcat(dest:=#TmpWithObjName[0], src:=": ");
    _strcat(dest:=#TmpWithObjName[0], src:=pString);
    
    if Value2 <> 16#FFFFFFFF then
      _itoa(Value2, #TempStr2[0]);
      TraceVal += 1;
    end_if;

    if Value3 <> 16#FFFFFFFF then
      _itoa(Value3, #TempStr3[0]);
      TraceVal += 1;
    end_if;
    
    case TraceVal of
      1:MyTrace(pFormat:=#TmpWithObjName[0], pTxt0:=#TempStr[0], pTxt1:=NIL, pTxt2:=NIL);
      2:MyTrace(pFormat:=#TmpWithObjName[0], pTxt0:=#TempStr[0], pTxt1:=#TempStr2[0], pTxt2:=NIL);
      3:MyTrace(pFormat:=#TmpWithObjName[0], pTxt0:=#TempStr[0], pTxt1:=#TempStr2[0], pTxt2:=#TempStr3[0]);        
    end_case;
  else
    MyTrace(pFormat:="<invalid string>", pTxt0:=NIL, pTxt1:=NIL, pTxt2:=NIL);
  end_if;
  
END_FUNCTION


FUNCTION SafetyManager::StoreInterfaceRoutingList
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
  VAR
  	pHelpManaging : ^t_ManagingComponent;
    EntryNo : USINT;
    i : UDINT;
    pHelp : ^t_InterfaceFrameInfo;
    ActOffset : UDINT;
  END_VAR

  EntryNo := (pPara^.aPara[0] / sizeof(t_InterfaceFrameInfo))$USINT;
  if (EntryNo <= MAX_MODULES_IN_OTHER_DOMAINS) then
    ActOffset := 0;
    pHelpManaging := pFirstManagingInterfaceComponent;
    while pHelpManaging do
      // if we found the sender of this list in our list of interfaceframe components, remember the safety numbers
      if pHelpManaging^.pThis$DINT = pPara^.aPara[2] then
        if EntryNo then
          // set the help pointer to the first entry of the interface frame info array
          pHelp := pPara^.aPara[1]$^t_InterfaceFrameInfo + sizeof(BOOL);
          for i := 0 to (EntryNo-1) do
            // we save the module info's with the domain interface module for TDO/SDO routing
            pHelpManaging^.ModuleInfo[i] := pHelp^.ModuleInfo;
            
            // we also save the whole info for PDO routing
            aInterfaceFrameInfos[InterfaceFrameNo] := pHelp^;
            
            // only for IFs where the communication partner is the source
            if aInterfaceFrameInfos[InterfaceFrameNo].IFPdoLen then
              aInterfaceFrameInfos[InterfaceFrameNo].OffsetInDomainModule := ActOffset;
              ActOffset += aInterfaceFrameInfos[InterfaceFrameNo].IFPdoLen;
            end_if;

            InterfaceFrameNo += 1;
            
            pHelp += sizeof(t_InterfaceFrameInfo);
          end_for;
        end_if;

        pHelpManaging^.ModuleNo := EntryNo;

        pHelpManaging^.InfoBits.GotIFInfo := TRUE;
        return;
      end_if;
    
      pHelpManaging := pHelpManaging^.pNext;
    end_while;
  else
    LogError("(SafetyManager::StoreInterfaceRoutingList) Invalid size of configuration");
  end_if;
  
END_FUNCTION


FUNCTION SafetyManager::AllInterfaceCfgsArrived
	VAR_OUTPUT
		AllReady 	: BOOL;
	END_VAR
  VAR
    pHelpManaging : ^t_ManagingComponent;
  END_VAR
  
  AllReady := TRUE;
  
  // check if we have the safety numbers for every interface managing module in the system
  pHelpManaging := pFirstManagingInterfaceComponent;
  while pHelpManaging do
    if pHelpManaging^.InfoBits.IsSynchron & (pHelpManaging^.InfoBits.GotIFInfo = FALSE) then
      AllReady := FALSE;
      return;
    end_if;
  
    pHelpManaging := pHelpManaging^.pNext;
  end_while;

END_FUNCTION


FUNCTION SafetyManager::SendInterfaceConfigs
	VAR_INPUT
		DestinationThis 	: pVirtualBase;
		IsResponse 	: BOOL;
	END_VAR
  VAR
    pHelpCfg : ^t_CfgListElem;
    pHelpModule : ^t_ModuleListElem;
    pHelpPdo : ^t_PdoListElem;
    MyPara : CmdStruct;
    MyResult : results;
    TmpIFInfo : t_IFInfo;
    ModuleInfoNo : USINT;
    i : UDINT;
    pActCRC : ^HDINT;
  END_VAR
  
  TmpIFInfo.IsResponse := IsResponse;

  // collect the safety numbers of this system
  ModuleInfoNo := 0;

  // browse through the configs
  pHelpCfg := pConfigs;
  while pHelpCfg do
    pHelpPdo := pHelpCfg^.pFirstPdoCfg;
    while pHelpPdo do
      // if it's a interface broadcast
      if pHelpPdo^.PdoInfo.Info.IFBroadCast then
        // search for the source module
        pHelpModule := pHelpCfg^.pFirstModuleCfg;
        while pHelpModule do
          // if it's an interface source and the interface CRC matches the one of our PDO => Bingo! But to be sure we check also the path length and the path itself
          if pHelpModule^.ModuleInfo.Info.IsInterfaceSource & (pHelpModule^.ModuleInfo.InterfaceCRC = pHelpPdo^.PdoInfo.InterfaceCRC) & 
            (pHelpModule^.ModuleInfo.PathLen = pHelpPdo^.PdoInfo.SourcePathLen) & 
            (To_StdLib.MemCmp(pHelpModule^.ModuleInfo.pPath, pHelpPdo^.PdoInfo.pSourcePath, pHelpPdo^.PdoInfo.SourcePathLen) = 0) then

            TmpIFInfo.aModuleInfos[ModuleInfoNo].InterfaceCRC          := pHelpModule^.ModuleInfo.InterfaceCRC;
            TmpIFInfo.aModuleInfos[ModuleInfoNo].IFPdoLen              := pHelpPdo^.PdoInfo.PdoLen;
            TmpIFInfo.aModuleInfos[ModuleInfoNo].OffsetInDomainModule  := 0; // the correct offset is calculated in the receiver
            TmpIFInfo.aModuleInfos[ModuleInfoNo].ModuleInfo.SafetyNbr  := pHelpModule^.ModuleInfo.SafetyNbr;
            TmpIFInfo.aModuleInfos[ModuleInfoNo].ModuleInfo.ModuleType := _NotUsed; // module type is here irrelevant => can only be a safe cpu
            ModuleInfoNo += 1;
          end_if;

          pHelpModule := pHelpModule^.pNext;
        end_while;        
      end_if;

      pHelpPdo := pHelpPdo^.pNext;
    end_while;

    // check the modules of the actual config if there are interface frame destinations (needed for unidirectional communication, otherwise the SDO routing would fail)
    pHelpModule := pHelpCfg^.pFirstModuleCfg;
    while pHelpModule do
      // if it's a interface destination
      if pHelpModule^.ModuleInfo.Info.IsInterfaceDest then
        pActCRC := pHelpModule^.ModuleInfo.pDestCRCs;
        for i := 0 to (pHelpModule^.ModuleInfo.DestCRCNo-1) do
          TmpIFInfo.aModuleInfos[ModuleInfoNo].InterfaceCRC          := pActCRC^;
          TmpIFInfo.aModuleInfos[ModuleInfoNo].IFPdoLen              := 0; // we don't know the length here, we're only the receiver
          TmpIFInfo.aModuleInfos[ModuleInfoNo].OffsetInDomainModule  := 0; // the correct offset is calculated in the receiver
          TmpIFInfo.aModuleInfos[ModuleInfoNo].ModuleInfo.SafetyNbr  := pHelpModule^.ModuleInfo.SafetyNbr;
          TmpIFInfo.aModuleInfos[ModuleInfoNo].ModuleInfo.ModuleType := _NotUsed; // module type is here irrelevant => can only be a safe cpu
          pActCRC += sizeof(HDINT);
          ModuleInfoNo += 1;
        end_for;
      end_if;         

      pHelpModule := pHelpModule^.pNext;
    end_while;     

    pHelpCfg := pHelpCfg^.pNext;
  end_while;
  
  MyPara.uiCmd := CMD_SM_IF_MODULE_INFO;
  MyPara.aPara[0] := ModuleInfoNo * sizeof(t_InterfaceFrameInfo) + sizeof(TmpIFInfo.IsResponse);
  MyPara.aPara[1] := (#TmpIFInfo)$DINT;
  
  // if we have only 1 destination => sent it to this destination
  if DestinationThis then
    DestinationThis^.NewInst(#MyPara, #MyResult);
  else
    // otherwise send our safety numbers to every interface managing module in the system
    TellAllInterfaceManagingModules(#MyPara, #MyResult);
  end_if;

END_FUNCTION


FUNCTION SafetyManager::GetIFInfoByCRC
	VAR_INPUT
		InterfaceCRC 	: HDINT;
		pMemOffset 	: ^UDINT;
		pLength 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		SafetyNbr 	: HDINT;
	END_VAR
  VAR
    i : DINT;
  END_VAR

  SafetyNbr := 0;

  if InterfaceFrameNo then
    for i := 0 to (InterfaceFrameNo-1) do
      // if we found the interface CRC and it's a interface frame we receive (the sender adds the length)
      if (aInterfaceFrameInfos[i].InterfaceCRC = InterfaceCRC) & aInterfaceFrameInfos[i].IFPdoLen then
        SafetyNbr := aInterfaceFrameInfos[i].ModuleInfo.SafetyNbr;
        // check if pointers are valid
        if pMemOffset & pLength then
          pMemOffset^ := aInterfaceFrameInfos[i].OffsetInDomainModule;
          pLength^    := aInterfaceFrameInfos[i].IFPdoLen;
        end_if;
        return;
      end_if;
    end_for;
    
    if SafetyNbr = 0 then
      LogError("(SafetyManager::GetIFInfoByCRC) Safetynumber of Interface-Frame source couldn't be found in the list");
    end_if;
  end_if;

END_FUNCTION


FUNCTION SafetyManager::SetTimeout

  ud_InitTimeOut := ops.tAbsolute;

END_FUNCTION


FUNCTION SafetyManager::CheckTimeout

  // if the step took too long
  if (OPS.tAbsolute - ud_InitTimeOut) > T_INIT_TIMEOUT then     
    // show the possible error in the log/trace and restart the time for timeout
    case InitSSW of
//**********************************************************************************************************************************************************
      _FirstWait4SynchronSubdomains:
        LogError("Timeout in Initialisation of SafetyManager while waiting first time for subdomains to get synchron!");
//**********************************************************************************************************************************************************
      _Wait4SynchronSubdomains:
        LogError("Timeout in Initialisation of SafetyManager while waiting for subdomains to get synchron!");
//**********************************************************************************************************************************************************
      _Wait4ConfigFlush:
        LogError("Timeout in Initialisation of SafetyManager while waiting for the slave domains to send their safety numbers of safety cpus and if they can handle the new time sync method!");        
//**********************************************************************************************************************************************************
      _Wait4CPUConfigs:
        LogError("Timeout in Initialisation of SafetyManager while waiting for all available cpu configurations!");        
//**********************************************************************************************************************************************************
      _Wait4InterfaceConfigs:
        LogError("Timeout in Initialisation of SafetyManager while waiting for module informations from another domain needed for interface frame communication!");
//**********************************************************************************************************************************************************
      _Wait4UnsafeConfigAck:
        LogError("Timeout in Initialisation of SafetyManager while waiting for an unsafe variable configuration acknowledgment of another domain!");
//**********************************************************************************************************************************************************
      _Wait4PDOAcks:
        LogError("Timeout in Initialisation of SafetyManager while waiting for a pdo configuration acknowledgment!");
//**********************************************************************************************************************************************************
    end_case;
    
    // this error gets quitted if initialisation finishes
    ClassState := -11;
    
    ud_InitTimeOut := ops.tAbsolute;
  end_if; 

END_FUNCTION





FUNCTION SafetyManager::AllNonOptionalIFDomainsSynchron
	VAR_OUTPUT
		EverythingSynchron 	: BOOL;
	END_VAR
  VAR
  	pHelpManaging : ^t_ManagingComponent;
    pHelpConfig : ^t_CfgListElem;
    pHelpPdo : ^t_PdoListElem;
    TempCfg : t_PdoCfg;
		MyPara 	  : CmdStruct;
		MyResult	: results;
  END_VAR
  
  EverythingSynchron := TRUE;

  MyPara.uiCmd := CMD_SM_SYNC_CHECK;

  // check for all interface frame PDOs in the configurations if the corresponding domain managing module is synchron
  pHelpConfig := pConfigs;
  while pHelpConfig do
    pHelpPdo := pHelpConfig^.pFirstPdoCfg;
    while pHelpPdo do
      TempCfg := pHelpPdo^.PdoInfo;
      // if it's an interface  PDO, no double entry and not optional => it has to be synchron!
      if (TempCfg.Info.IsInterfacePDO = TRUE) & (TempCfg.Info.DoublePDOEntry = FALSE) & (TempCfg.Info.IsOptional = FALSE) then
        pHelpManaging := pFirstManagingInterfaceComponent;
        while pHelpManaging do
          // we found the corresponding domain managing module
          if (pHelpManaging^.InfoBits.IsOptional = FALSE) &
            ((To_StdLib.MemCmp(pHelpManaging^.pModulePath, TempCfg.pSourcePath, TempCfg.SourcePathLen) = 0) |
             (To_StdLib.MemCmp(pHelpManaging^.pModulePath, TempCfg.pDestPath, TempCfg.DestPathLen) = 0)) then

            // if any of those is not synchron, stop searching
            if pHelpManaging^.pThis^.NewInst(#MyPara, #MyResult) = ERROR then
              EverythingSynchron := FALSE;
              return;
            end_if;

            exit;
          end_if;
          
          pHelpManaging := pHelpManaging^.pNext;
        end_while;  
      end_if;
      
      pHelpPdo := pHelpPdo^.pNext;
    end_while;

    pHelpConfig := pHelpConfig^.pNext;
  end_while;

END_FUNCTION





FUNCTION VIRTUAL SafetyManager::GetThisViaServerName
	VAR_INPUT
		pObjectDotServer 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		ThisPtr 	: pVoid;
	END_VAR
  VAR
    ChannelMode : CHMODE;
  END_VAR
  
  ThisPtr := NIL;

  if pObjectDotServer = NIL then
    return;
  end_if;
  
  // get thispointer to server via name
  ChannelMode := _LookUpEmbed_C(pObjectDotServer, #ThisPtr, NIL);

  // check if it's a server
  case ChannelMode of
    _CH_CMD,
    _CH_SVR:
    
  else
    ThisPtr := NIL;
    LogError(e_msg:="(SafetyManager::GetThisViaServerName) Couldn't get thispointer of server:");
    LogError(e_msg:=pObjectDotServer);
  end_case;

END_FUNCTION


FUNCTION SafetyManager::GetNewMovDO
	VAR_OUTPUT
		Index 	: INT;
	END_VAR
//  VAR
//  	sd_retval : DINT;
//  END_VAR
  
  Index := -1;

  if CopyCmdsUsed < MAX_PDO_COPY_CMDS then
    // check if there is one available but not used
    if CopyCmdsUsed < CopyCmdsAvailable then
      Index := CopyCmdsUsed;
      CopyCmdsUsed += 1;      
    else
      // we have to create a new one

(*
// connection to varan manager required
      // add data object to copy our data
      sd_retval := pVaranManager^.AddMovDO(ud_dol_type:=VARAN_DOL_ISO
                                         , p_ud_handle:=(#aCopyCmds[CopyCmdsAvailable].pHandle)$^UDINT
                                         , p_ud_MovSettings:=( #aCopyCmds[CopyCmdsAvailable].pSettings)$^UDINT
                                         , ud_type := VM_PRIORITY_2
                                         );

      //look for an error
      if ( sd_retval <> 0 ) then
        ClassState := -9;
        LogError("(SafetyManager::GetNewMovDO) Failed to add a new copy command to the VaranManager!");
        return;
      end_if;
*)
      aCopyCmds[CopyCmdsAvailable].b_Ready4Action := FALSE;
      
      Index := CopyCmdsAvailable;
      
      CopyCmdsAvailable += 1;
      CopyCmdsUsed += 1;
    end_if;
  else
    LogError("Maximum of possible PDO copy commands reached!");
  end_if;

END_FUNCTION


FUNCTION SafetyManager::CheckCPUConfigs
	VAR_OUTPUT
		ConfigsOK 	: BOOL;
	END_VAR
  VAR
  	pHelpManaging   : ^t_ManagingComponent;
    pSourceManaging : ^t_ManagingComponent;
    pHelpConfig     : ^t_CfgListElem;
    pHelpPdo        : ^t_PdoListElem;
    pLastPdo        : ^t_PdoListElem;
    IsSource        : DINT;
    PDOCount : UDINT;
  END_VAR
  
  // before we go into the usual check routine, we have to ensure that we have enough virtual PDOs for writing interface frames (config holds a broadcast and we have to look for possible target modules)
  CreateVirtualPDOs();

  // initialize with true (normal case is that everything is ok => now we check for errors)
  ConfigsOK := TRUE;
  
  PDOCount := 0;
  
  // check if all non-optional modules are available and all corresponding domain managing module are synchron (if necessary)
  pHelpConfig := pConfigs;
  while pHelpConfig do
    pLastPdo := NIL;
    pHelpPdo := pHelpConfig^.pFirstPdoCfg;
    while pHelpPdo do
      // if it's an interface frame and no broadcast frame
      if pHelpPdo^.PdoInfo.Info.IsInterfacePDO then
        if (pHelpPdo^.PdoInfo.Info.IFBroadCast = FALSE) then

          // check if we have already added the domain interface to the IF List
          IsSource := -1; // -1 = not found, 0 = destination, 1 = source
          pSourceManaging := NIL;
          pHelpManaging := pFirstManagingInterfaceComponent;
          while pHelpManaging do
            // if source or destination of the PDO matches our managing module path => it's an interface frame to/from this domain
            if (To_StdLib.MemCmp(pHelpManaging^.pModulePath, pHelpPdo^.PdoInfo.pSourcePath, pHelpPdo^.PdoInfo.SourcePathLen) = 0) then
              pSourceManaging := pHelpManaging;
              IsSource := 1;
              exit;
            elsif (To_StdLib.MemCmp(pHelpManaging^.pModulePath, pHelpPdo^.PdoInfo.pDestPath, pHelpPdo^.PdoInfo.DestPathLen) = 0) then
              IsSource := 0;
              exit;
            end_if;
            
            pHelpManaging := pHelpManaging^.pNext;
          end_while;

          // if we got a source managing module and it isn't synchron
          if pSourceManaging then
            // if this pdo is not optional => the source module also isn't
            if pHelpPdo^.PdoInfo.Info.IsOptional = FALSE then
              pSourceManaging^.InfoBits.IsOptional := FALSE;
            end_if;
            
            if (pSourceManaging^.InfoBits.IsSynchron = FALSE) then
              if pHelpPdo^.PdoInfo.Info.IsOptional then
                // ignore it
  //              LogError("Info: Optional interface frame can't be received, because source domain is not connected or not synchron");
                
                // remove the PDO from the list (if not the receiver module would wait endless for the PDO and we can't send the set bus ready to quit errors of local PDOs)
                if pLastPdo then
                  // if we had already a PDO before in this configuration we have to skip the removed PDO with the next pointer
                  pLastPdo^.pNext := pHelpPdo^.pNext;
                  
                  To_StdLib.Free(pHelpPdo^.PdoInfo.pSourcePath);
                  To_StdLib.Free(pHelpPdo^.PdoInfo.pDestPath);
                  To_StdLib.Free(pHelpPdo);
                  
                  pHelpPdo := pLastPdo;
                else
                  // if it was the first PDO, we have to correct the first pointer
                  pHelpConfig^.pFirstPdoCfg := pHelpPdo^.pNext;

                  To_StdLib.Free(pHelpPdo^.PdoInfo.pSourcePath);
                  To_StdLib.Free(pHelpPdo^.PdoInfo.pDestPath);
                  To_StdLib.Free(pHelpPdo);

                  pHelpPdo := pHelpConfig^.pFirstPdoCfg;
                end_if;
                
                if pHelpPdo = NIL then
                  exit;
                end_if;
              else
                // non-optional interface frame domain missing => error
                LogError("ERROR! Non-Optional interface frame can't be received, because domain is not connected");
                ConfigsOK := FALSE;
                ClassState := -10;
              end_if;
            end_if;
          end_if;
        end_if;
      end_if;
    
      PDOCount += 1;
      
      pLastPdo := pHelpPdo;
      pHelpPdo := pHelpPdo^.pNext;
    end_while;
  
    pHelpConfig := pHelpConfig^.pNext;
  end_while;
  
  // if now PDOs found => reset the act ID to show that there are none
  if PDOCount = 0 then
    ActPDO_ID := 0;
  end_if;
  
END_FUNCTION


FUNCTION SafetyManager::RemoveLocalCPUCfg
	VAR_INPUT
		SafetyNumber 	: HDINT;
	END_VAR
  VAR
  	pHelpCfg    : ^t_LocalCfgListElem;
    i : UDINT;
  END_VAR

  if LocalCPUCfgNo then
    pHelpCfg := pFirstLocalCPUCfg;
    for i := 0 to (LocalCPUCfgNo-1) do
      if pHelpCfg^.SafetyNbr = SafetyNumber then
        // found it => deactivate it
        pHelpCfg^.ConfigSize := 0;
        pHelpCfg^.ConfigSent2Master := FALSE;
        exit;
      end_if;
    
      pHelpCfg := pHelpCfg^.pNext;
    end_for;
  end_if;

END_FUNCTION


FUNCTION SafetyManager::ClearRoutingInformations
  VAR
  	MyPara : CmdStruct;
    MyResult : results;
    pHelpManaging : ^t_ManagingComponent;
    i : UDINT;
    pHelpCfg      : ^t_LocalCfgListElem;
  END_VAR

  // we're flushin our stuff here

  // reset number of memorized safe cpu numbers
  SafeCPU_Nbr_No := 0;

  // set ID to zero for the next mapping assignment
  ActPDO_ID := 0;

  // reset interface frameno
  InterfaceFrameNo := 0;

  // reset local interface frameno
  LocalIFNo := 0;

  // clear configurations of safety-cpus
  FreeCfgLists();
  
  // clear number of copy DOs used
  CopyCmdsUsed := 0;

  // reset memory usage for isochronous transfer (the values are set when distributing the PDOs)
  MyPara.aPara[0] := 0;
  pHelpManaging := pFirstManagingInterfaceComponent;
  while pHelpManaging do
    pHelpManaging^.PDOReadMemUsed := 0;
    pHelpManaging^.PDOWriteMemUsed := 0;
    
    MyPara.uiCmd := CMD_SM_PDO_MEM_USAGE_WR;
    pHelpManaging^.pThis^.NewInst(#MyPara, #MyResult);
    
    MyPara.uiCmd := CMD_SM_PDO_MEM_USAGE_RD;
    pHelpManaging^.pThis^.NewInst(#MyPara, #MyResult);

    pHelpManaging^.InfoBits.HasBeenFlushed      := FALSE;
    pHelpManaging^.InfoBits.NewTimeSyncPossible := FALSE;
    pHelpManaging^.InfoBits.SubDomainsSynchron  := FALSE;
    pHelpManaging^.InfoBits.GotIFInfo           := FALSE;
    pHelpManaging^.InfoBits.LocalConfigReady    := FALSE;
    pHelpManaging^.InfoBits.IsOptional          := TRUE;  // initialize with true, later in the init process (CheckCPUConfigs) it's checked and corrected if necessary
    // synchron bit is already true at this time (or the timeout has expired)

    pHelpManaging^.DomainNr := 16#FF;

    pHelpManaging^.SubDomainsUsed := 0;
    _memset(dest:=#pHelpManaging^.SubDomainNr, usByte:=16#FF, cntr:=sizeof(pHelpManaging^.SubDomainNr));

    pHelpManaging^.ModuleNo := 0;
    _memset(dest:=#pHelpManaging^.ModuleInfo, usByte:=16#00, cntr:=sizeof(pHelpManaging^.ModuleInfo));

    pHelpManaging := pHelpManaging^.pNext;
  end_while;
  
  // all local cpu configs have to be sent again on reconnect
  if LocalCPUCfgNo then
    pHelpCfg := pFirstLocalCPUCfg;
    for i := 0 to (LocalCPUCfgNo-1) do
      pHelpCfg^.ConfigSent2Master := FALSE;
    
      pHelpCfg := pHelpCfg^.pNext;
    end_for;
  end_if;

END_FUNCTION


FUNCTION SafetyManager::CheckPDORecycle
	VAR_INPUT
		SourceDest 	: t_SourceDest;
		pNewPDO 	: ^t_PDOElement;
	END_VAR
	VAR_OUTPUT
		pRecyclePDO 	: ^t_PDOElement;
	END_VAR
  VAR
  	i : UDINT;
    pHelpInfo : ^t_PDOModuleInfo;
    pSearchInfo : ^t_PDOModuleInfo;
    ppHelpManaging : ^t_pManagingComponent;
    pSearchManaging : ^t_ManagingComponent;
  END_VAR

  // initialize with invalid
  pRecyclePDO := NIL;

  // if we have no pdoelements yet, quit
  if PDOElementNo = 0 then
    return;
  end_if;

  // we search for a PDO with the same source (then it contains the same data)
  pHelpInfo := #aPDOElements[0].SourceInfo;
  pSearchInfo := #pNewPDO^.SourceInfo;
  
  case SourceDest of
    SourceDest_IsSource:
      ppHelpManaging := #aPDOElements[0].pManagingSource;
      pSearchManaging := pNewPDO^.pManagingSource;
    SourceDest_IsDest:
      ppHelpManaging := #aPDOElements[0].pManagingDest;
      pSearchManaging := pNewPDO^.pManagingDest;
  else
    return;
  end_case;

  // check if we already have the path info of this source/destination
  for i := 0 to (PDOElementNo-1) do
    // if managing node, pathlength and path matches
    if (ppHelpManaging^ = pSearchManaging) & (pHelpInfo^.PathLen = pSearchInfo^.PathLen) & (To_StdLib.MemCmp(pHelpInfo^.pPath, pSearchInfo^.pPath, pHelpInfo^.PathLen) = 0) then
      // we found our PDO to recycle (PDO is already tranferred over this managing node
      pRecyclePDO := #aPDOElements[i];
      return;
    end_if;
    
    pHelpInfo       += sizeof(t_PDOElement);
    ppHelpManaging  += sizeof(t_PDOElement);
  end_for;

END_FUNCTION


FUNCTION SafetyManager::AddManagingInfo
	VAR_INPUT
		pPara 	: ^CmdStruct;
	END_VAR
  VAR
  	pHelpManaging : ^t_ManagingComponent;
  END_VAR

(*
  Parameter description:
  0..pointer to write PDOs in VARAN manager DPRAM
  1..pointer to read PDOs in VARAN manager DPRAM
  2..thispointer of calling class
  3..pointer to write PDOs in internal memory
  4..pointer to read PDOs in internal memory
  5..maximum available space for write PDOs in bytes
  6..maximum available space for read PDOs in bytes
*)

  pHelpManaging := pFirstManagingInterfaceComponent;
  while pHelpManaging do
    if pHelpManaging^.pThis = pPara^.aPara[2]$pVirtualBase then
      exit;
    end_if;

    pHelpManaging := pHelpManaging^.pNext;
  end_while;    
  
  if pHelpManaging then
    pHelpManaging^.pPDOWriteSpaceDPRAM  := pPara^.aPara[0]$^USINT;
    pHelpManaging^.pPDOReadSpaceDPRAM   := pPara^.aPara[1]$^USINT;
    
    pHelpManaging^.pPDOWriteSpace       := pPara^.aPara[3]$^USINT;
    pHelpManaging^.pPDOReadSpace        := pPara^.aPara[4]$^USINT;

    pHelpManaging^.PDOWriteMemAvailable := pPara^.aPara[5]$UDINT;
    pHelpManaging^.PDOReadMemAvailable  := pPara^.aPara[6]$UDINT;
    
    pHelpManaging^.ud_HandlePDOWriteSpaceDPRAM  := pPara^.aPara[7]$UDINT;
    pHelpManaging^.ud_HandlePDOReadSpaceDPRAM   := pPara^.aPara[8]$UDINT;
    
  end_if;

END_FUNCTION


FUNCTION SafetyManager::CheckModuleUsage
	VAR_INPUT
		Length 	: UINT;
		pData 	: ^void;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    pDataHelp : ^void;
    i : UDINT;
    TmpPathLen : UINT;
    TempCfgNo : USINT;
    ModuleCfgInfo : t_ModuleCfgInfo;
    PdoCfgInfo : t_PdoCfgInfo;
  END_VAR
  
(*
    Memory structure:
      4 Byte: SafetyNumber of CPU (is already there from initialisation in CSCP011_IM::InitSafeModule)
      1 Byte: Number of module configurations which are following
      for every module configuration (first is always the CPU itself)
        1 Byte: Info
        4 Byte: Interface Frame Source SafetyNumber (0 if it is no source for interface frames)
        4 Byte: Interface Frame CRC
        1 Byte: Number of destination inferface frame CRCs
        x Byte: Destination interface frame CRCs (number * sizeof(HDINT)
        2 Byte: Length of hardware path
        x Byte (depending on length in the 2 byte before): Hardwarepath
        2 Byte: Length of compressed hardware path
        x Byte (depending on length in the 2 byte before): Compressed Hardwarepath
        1 Byte: PDO out length for this module
      1 Byte: Number of pdo configurations which are following
      for every PDO configuration
        1 Byte: PDO length
        1 Byte: Interface frame info
        4 Byte: Interface CRC
        2 Byte: Length of source hardware path
        x Byte (depending on length in the 2 byte before): Hardwarepath of source
        2 Byte: Length of destination hardware path
        x Byte (depending on length in the 2 byte before): Hardwarepath of destination       
      1 Byte: Number of slave configurations which are following
      for every slave configuration
        1 Byte: Info
        4 Byte: InterfaceCRC
        2 Byte: Length of hardware path
        x Byte (depending on length in the 2 byte before): Hardwarepath
        2 Byte: Length of compressed hardware path
        x Byte (depending on length in the 2 byte before): Compressed Hardwarepath
*)

  // check if the configuration is valid (pData <> NIL) & (Length must be at least 4 byte for SafetyNbr + 1 byte module cfg number + 1 byte pdo cfg number + 1 byte slave cfc number)
  if pData & (Length >= 7)  then

    retcode := 0;
    
    pDataHelp := pData;
    
    // skip safety number of the safety cpu
    pDataHelp += sizeof(HDINT);
    
    // number of module configurations which follow now
    TempCfgNo := pDataHelp^$USINT;
    
    // skip number of module configurations
    pDataHelp += sizeof(USINT);
    
    // module configurations
    if TempCfgNo then
      for i := 0 to (TempCfgNo-1) do
        // info
        ModuleCfgInfo := pDataHelp^$t_ModuleCfgInfo;
        
        // skip info
        pDataHelp += sizeof(BSINT);
        
        // skip safety number of interface frame source
        pDataHelp += sizeof(HDINT);

        // skip interface CRC of interface frame
        pDataHelp += sizeof(HDINT);
        
        // interface frame destination CRCs
        if ModuleCfgInfo.IsInterfaceDest then
          // number of CRCs
          TmpPathLen := pDataHelp^$USINT;

          // skip number of CRCs
          pDataHelp += sizeof(USINT);
          
          // skip interface destination CRCs
          pDataHelp += TmpPathLen * sizeof(HDINT);
        end_if;
        
        // length of hardware path
        TmpPathLen := pDataHelp^$UINT;

        // skip length of hardware path
        pDataHelp += sizeof(UINT);

        SetModuleUsed(PathLen:=TmpPathLen, pPath:=pDataHelp$^USINT, IgnoreOptional:=FALSE, IsOptional:=ModuleCfgInfo.IsOptional, IsInterfaceDomain := FALSE);

        // skip hardware path
        pDataHelp += TmpPathLen;

        // length of compressed hardware path
        TmpPathLen := pDataHelp^$UINT; // save some time with this local variable

        // skip length of compressed hardware path
        pDataHelp += sizeof(UINT);

        // skip compressed hardware path
        pDataHelp += TmpPathLen;
        
        // skip pdo out length of this module
        pDataHelp += sizeof(USINT);
      end_for;
    end_if;

    // number of Pdo configurations which follow now
    TempCfgNo := pDataHelp^$USINT;
    
    // skip number of pdo configurations
    pDataHelp += sizeof(USINT);
        
    // Pdo configurations
    if TempCfgNo then
      for i := 0 to (TempCfgNo-1) do
        // skip pdo length
        pDataHelp += sizeof(USINT);
        
        // is it an interface pdo?
        PdoCfgInfo := pDataHelp^$t_PdoCfgInfo;
        
        // skip info
        pDataHelp += sizeof(BSINT);
        
        // skip interface CRC
        pDataHelp += sizeof(HDINT);
        
        // length of source hardware path
        TmpPathLen := pDataHelp^$UINT;

        // skip length of source hardware path
        pDataHelp += sizeof(UINT);
        
        SetModuleUsed(PathLen:=TmpPathLen, pPath:=pDataHelp$^USINT, IgnoreOptional:=FALSE, IsOptional:=PdoCfgInfo.IsOptional, IsInterfaceDomain := PdoCfgInfo.IsInterfacePDO);
        
        // skip source hardware path
        pDataHelp += TmpPathLen;

        // length of destination hardware path
        TmpPathLen := pDataHelp^$UINT;

        // skip length of destination hardware path
        pDataHelp += sizeof(UINT);

        // a destination module doesn't influence the optional property=> ignore the optional setting
        SetModuleUsed(PathLen:=TmpPathLen, pPath:=pDataHelp$^USINT, IgnoreOptional:=TRUE, IsOptional:=FALSE, IsInterfaceDomain := PdoCfgInfo.IsInterfacePDO);

        // skip destination hardware path
        pDataHelp += TmpPathLen;
      end_for;
    end_if;

    // number of slave configurations which follow now
    TempCfgNo := pDataHelp^$USINT;

    // skip number of slave configurations
    pDataHelp += sizeof(USINT);
   
    // slave configurations
    if TempCfgNo then
      for i := 0 to (TempCfgNo-1) do
        // skip info
        pDataHelp += sizeof(BSINT);
                   
        // skip InterfaceCRC
        pDataHelp += sizeof(HDINT);

        // length of hardwarepath
        TmpPathLen := pDataHelp^$UINT; // save some time with this local variable
        
        // skip length of hardwarepath
        pDataHelp += sizeof(UINT);
        
        // skip hardwarepath
        pDataHelp += TmpPathLen;

        // length of compressed hardwarepath
        TmpPathLen := pDataHelp^$UINT; // save some time with this local variable

        // skip length of compressed hardwarepath
        pDataHelp += sizeof(UINT);
               
        // skip compressed hardwarepath
        pDataHelp += TmpPathLen;
      end_for;
    end_if;
    
    // check if the given size matches the memory structure
    if (pDataHelp$UDINT - pData$UDINT) <> Length then
      LogError("(SafetyManager::CheckModuleUsage) Invalid configuration data given (length doesn't match memory structure)");
      retcode := -3;
      return;
    end_if;
  else   
    // invalid configuration
    LogError("(SafetyManager::CheckModuleUsage) Found invalid safety cpu configuration: Pointer or size wrong");
    retcode := -1;
  end_if;

END_FUNCTION


FUNCTION SafetyManager::SetModuleUsed
	VAR_INPUT
		PathLen 	: UINT;
		pPath 	: ^USINT;
		IgnoreOptional 	: BOOL;
		IsOptional 	: BOOL;
		IsInterfaceDomain 	: BOOL;
	END_VAR
  VAR
    pHelpManaging : ^t_ManagingComponent;
    pHelpSafety : ^t_SafetyComponent;
    TempPath : ARRAY [0..99] OF USINT;
  END_VAR

  // search for the hardware path
  
  // start with the safety components
  pHelpSafety := pFirstSafetyComponent;
  while pHelpSafety & pHelpSafety^.pPath do
    // we have 1 byte path length on the safety component but we got a 2 byte path length from the configuration
    // furthermore the pPath string could be over more domains and we have only our local path => check if length is bigger and if there is a domain escape right before the domain number
    if ((pPath^ = pHelpSafety^.pPath^) | ((pPath^ > pHelpSafety^.pPath^) & ((pPath + 1 + pPath^ - pHelpSafety^.pPath^)^ = HWT_ESCAPE_DOMAIN))) & 
       (To_StdLib.MemCmp(pHelpSafety^.pPath + 1, pPath + 2 + pPath^ - pHelpSafety^.pPath^, pHelpSafety^.pPath^) = 0) then
      // only set IsOptional to false (has been initialized with true)
      if (IsOptional = FALSE) & (IgnoreOptional = FALSE) then
        pHelpSafety^.InfoBits.IsOptional := FALSE;
      end_if;
      return;
    end_if;
   
    pHelpSafety := pHelpSafety^.pNext;
  end_while;

  // if not found, continue with the managing interface components
  pHelpManaging := pFirstManagingInterfaceComponent;
  while pHelpManaging do
    if (To_StdLib.MemCmp(pHelpManaging^.pModulePath, pPath, PathLen) = 0) then
      // only set IsOptional to false (has been initialized with true)
      if (IsOptional = FALSE) & (IgnoreOptional = FALSE) then
        pHelpManaging^.InfoBits.IsOptional := FALSE;
      end_if;
      return;
    end_if;

    pHelpManaging := pHelpManaging^.pNext;
  end_while;

  _memcpy(ptr1:=#TempPath[0], ptr2:=pPath, cntr:=PathLen$USINT);

END_FUNCTION


FUNCTION SafetyManager::CreateTimeSyncList
  VAR
  	pHelp : ^t_TimeSyncElement;
  	pHelpSafety   : ^t_SafetyComponent;
  	pHelpManaging : ^t_ManagingComponent;
  END_VAR

  // first we stop time syncing (if active) to prevent crashing due tue a running time synchronisation
  pActTimeSyncElement := NIL;

  // if there is an old list, free it first
  if pFirstTimeSyncElement then
    // open the ring (set the next pointer of the last element to NIL)
    pFirstTimeSyncElement^.pPrev^.pNext := NIL;
    
    // remove the elements
    while pFirstTimeSyncElement do
      pHelp := pFirstTimeSyncElement;
      pFirstTimeSyncElement := pFirstTimeSyncElement^.pNext;
    
      To_StdLib.Free(mptr:=pHelp);
    end_while;
  end_if;

  pHelpSafety := pFirstSafetyComponent;
  while pHelpSafety do
    // if it's a module with not only inputs (then there's nothing to synchronize with) => trigger it for time synchronisation
    if (pHelpSafety^.InfoBits.OnlyInputs = FALSE) then
      AddTimeSyncElement(pManaging:=NIL, pSafety:=pHelpSafety, IsInterfaceDomain := FALSE);
    end_if;

    pHelpSafety := pHelpSafety^.pNext;
  end_while;

  // interface domains will not get our token, they got their own
  pHelpManaging := pFirstManagingInterfaceComponent;
  while pHelpManaging do
    AddTimeSyncElement(pManaging:=pHelpManaging, pSafety:=NIL, IsInterfaceDomain := TRUE);

    pHelpManaging := pHelpManaging^.pNext;
  end_while;  

END_FUNCTION


FUNCTION SafetyManager::AddTimeSyncElement
	VAR_INPUT
		pManaging 	: ^t_ManagingComponent;
		pSafety 	: ^t_SafetyComponent;
		IsInterfaceDomain 	: BOOL;
	END_VAR
  VAR
    pLast : ^t_TimeSyncElement;
  	pHelp : ^t_TimeSyncElement;
  END_VAR

  // first we have to allocate some memory for the new element
  if pFirstTimeSyncElement = NIL then
    pFirstTimeSyncElement$pVoid := To_StdLib.Malloc(size:=sizeof(t_TimeSyncElement));
    pLast := pHelp := pFirstTimeSyncElement;
  else
    // check if we got this already
    pHelp := pFirstTimeSyncElement;
    repeat
      if pSafety & (pHelp^.pSafety = pSafety) then
        // already in list => leave
        return;
      end_if;

      if pManaging & (pHelp^.pManaging = pManaging) then
        // already in list => leave
        return;
      end_if;
      
      pHelp := pHelp^.pNext;
    until (pHelp = pFirstTimeSyncElement) end_repeat;
  
    pHelp$pVoid := To_StdLib.Malloc(size:=sizeof(t_TimeSyncElement));
    pLast := pFirstTimeSyncElement^.pPrev;
  end_if;

  if pHelp then
    // close the double linked ring with the new elements
    pFirstTimeSyncElement^.pPrev := pHelp;
    pHelp^.pNext := pFirstTimeSyncElement;
    
    pHelp^.pPrev := pLast;
    pLast^.pNext := pHelp;
  
    pHelp^.InfoBits := 0;
    pHelp^.InfoBits.IsInterfaceDomain := IsInterfaceDomain;
    
    pHelp^.pManaging := pManaging;
    pHelp^.pSafety   := pSafety;
    
    // managing modules
    if (pManaging <> NIL) then
      pHelp^.InfoBits.IsManagingModule := TRUE;
      pHelp^.pThis := pManaging^.pThis;
      
      // if it's the master connection
      if pManaging^.InfoBits.IsConnectionToMaster then
        // remember it
        pHelp^.InfoBits.IsConnectionToMaster := TRUE;
        
        // and make it the end of the list
        pFirstTimeSyncElement := pHelp^.pNext;
        
        // remember that we got a master connection
        pMasterTimeSyncElement := pHelp;
        
      elsif pMasterTimeSyncElement then
        // if we're not master and there is already a master time sync element in the list, we have to make it the last element
        pFirstTimeSyncElement := pMasterTimeSyncElement^.pNext;
      end_if;
    else
      // safety modules
      pHelp^.InfoBits.IsManagingModule := FALSE;
      pHelp^.pThis := pSafety^.pThis;
      
    // insert new safety modules at the beginning (managing modules at the end)
      pFirstTimeSyncElement := pHelp;
    end_if;
        

  else
    ClassState := -1;
    LogError("(SafetyManager::AddTimeSyncElement) Failed to allocate memory for a new Element");
  end_if;

END_FUNCTION


FUNCTION SafetyManager::CreateVirtualPDOs
  VAR
  	pHelpManaging   : ^t_ManagingComponent;
    pHelpConfig     : ^t_CfgListElem;
    pHelpPdo        : ^t_PdoListElem;
    TempPDO         : t_PdoCfg;
    pSearchConfig   : ^t_CfgListElem;
    pSearchPdo      : ^t_PdoListElem;
  END_VAR

  pHelpConfig := pConfigs;
  while pHelpConfig do
    pHelpPdo := pHelpConfig^.pFirstPdoCfg;
    while pHelpPdo do
      // check if it's a broadcast
      if (pHelpPdo^.PdoInfo.Info.IFBroadCast) & (pHelpPdo^.PdoInfo.Info.VirtualPDOsCreated = FALSE) then
        // found one => create virtual PDOs from it (add them to the same configuration)

        // prepare new virtual PDO
        TempPDO := pHelpPdo^.PdoInfo;

        TempPDO.Info.IFBroadCast := FALSE;
        TempPDO.Info.VirtualPDO := TRUE;

        // add a new PDO for every interface managing module
        pHelpManaging := pFirstManagingInterfaceComponent;
        while pHelpManaging do
          // change destination path to the actual module
          TempPDO.DestPathLen := pHelpManaging^.pModulePath^ + 2;
          TempPDO.pDestPath := pHelpManaging^.pModulePath;
          
          if AddVirtualPDOToCfg(pCfg:=pHelpConfig, pNewPDO:=#TempPDO) then
            LogError(e_msg:="(SafetyManager::CreateVirtualPDOs) Failed to allocate memory for a new virtual PDO");
          end_if;
        
          pHelpManaging := pHelpManaging^.pNext;
        end_while;

        // search in all configs (if there are other) for a pdo with this interface CRC as source
        pSearchConfig := pConfigs;
        while pSearchConfig do
          pSearchPdo := pSearchConfig^.pFirstPdoCfg;
          while pSearchPdo do
            // we must not manipulate our help pdo
            if pSearchPdo <> pHelpPdo then
              // check if the interface CRC appears in any PDO
              if pSearchPdo^.PdoInfo.InterfaceCRC = pHelpPdo^.PdoInfo.InterfaceCRC then
                // now take the source path of the broadcast PDO and use it as source path for this PDO
                To_StdLib.Free(mptr:=pSearchPdo^.PdoInfo.pSourcePath);
                
                pSearchPdo^.PdoInfo.pSourcePath$pVoid := To_StdLib.Malloc(size:=pHelpPdo^.PdoInfo.SourcePathLen);
                
                // save source hardwarepath
                if pSearchPdo^.PdoInfo.pSourcePath then
                  _memcpy(ptr1:=pSearchPdo^.PdoInfo.pSourcePath, ptr2:=pHelpPdo^.PdoInfo.pSourcePath, cntr:=pHelpPdo^.PdoInfo.SourcePathLen);
                  pSearchPdo^.PdoInfo.SourcePathLen := pHelpPdo^.PdoInfo.SourcePathLen;
                  
                  // source and destination of this PDO are both local safe cpu modules which communicate with each other via interface frames => store them in extra list for routing SDOs and TDOs
                  AddToLocalIFs(#pSearchPdo^.PdoInfo);
                else
                  LogError(e_msg:="(SafetyManager::CreateVirtualPDOs) Failed to allocate memory for a source path");
                  pSearchPdo^.PdoInfo.SourcePathLen := 0;
                  ClassState := -1;
                end_if;
              end_if;              
            end_if;
          
            pSearchPdo := pSearchPdo^.pNext;
          end_while;
        
          pSearchConfig := pSearchConfig^.pNext;
        end_while;
        pHelpPdo^.PdoInfo.Info.VirtualPDOsCreated := TRUE;
      end_if;
    
      pHelpPdo := pHelpPdo^.pNext;
    end_while;
  
    pHelpConfig := pHelpConfig^.pNext;
  end_while;
  
END_FUNCTION


FUNCTION SafetyManager::AddVirtualPDOToCfg
	VAR_INPUT
		pCfg 	: ^t_CfgListElem;
		pNewPDO 	: ^t_PdoCfg;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    pHelpPdo        : ^t_PdoListElem;
    TempLen         : UINT;
  END_VAR

  retcode := 0;

  if pCfg^.pFirstPdoCfg = NIL then
    // first PDO in this cfg (should not be possible, because the template for this PDO is also in the same config)
    pCfg^.pFirstPdoCfg$pVoid := To_StdLib.Malloc(size:=sizeof(t_PdoListElem));
    pHelpPdo := pCfg^.pFirstPdoCfg;
  else
    // search a place for the new PDO
    pHelpPdo := pCfg^.pFirstPdoCfg;
    while pHelpPdo^.pNext do
      
      pHelpPdo := pHelpPdo^.pNext;
    end_while;
    
    pHelpPdo^.pNext$pvoid := To_StdLib.Malloc(size:=sizeof(t_PdoListElem));
    pHelpPdo := pHelpPdo^.pNext;
  end_if;
  
  if pHelpPdo then
    // init the values
    pHelpPdo^.PdoInfo.PdoLen        := pNewPDO^.PdoLen;
    pHelpPdo^.PdoInfo.Info          := pNewPDO^.Info;
    pHelpPdo^.PdoInfo.InterfaceCRC  := pNewPDO^.InterfaceCRC;
    
    // length of source hardwarepath
    TempLen := pNewPDO^.SourcePathLen; // save some time with this local variable
    pHelpPdo^.PdoInfo.SourcePathLen := TempLen;
    
    // allocate memory for the source module path
    pHelpPdo^.PdoInfo.pSourcePath$pVoid := To_StdLib.Malloc(size:=TempLen);
    if pHelpPdo^.PdoInfo.pSourcePath = NIL then
      ClassState := -1;
      retcode := -2;
      return;
    end_if;
    
    // save source hardwarepath
    _memcpy(ptr1:=pHelpPdo^.PdoInfo.pSourcePath, ptr2:=pNewPDO^.pSourcePath, cntr:=TempLen);

    // length of destination hardwarepath
    TempLen := pNewPDO^.DestPathLen; // save some time with this local variable
    pHelpPdo^.PdoInfo.DestPathLen := TempLen;
    
    // allocate memory for the destination module path
    pHelpPdo^.PdoInfo.pDestPath$pVoid := To_StdLib.Malloc(size:=TempLen);
    if pHelpPdo^.PdoInfo.pDestPath = NIL then
      ClassState := -1;
      retcode := -2;
      return;
    end_if;
    
    // save destination hardwarepath
    _memcpy(ptr1:=pHelpPdo^.PdoInfo.pDestPath, ptr2:=pNewPDO^.pDestPath, cntr:=TempLen);               
    
    // now we give it an ID and increase the number for the next pdo
    pHelpPdo^.PdoInfo.PDO_ID := ActPDO_ID;
    ActPDO_ID += 1;
    
    pHelpPdo^.pNext                  := NIL;
  else
    ClassState := -1;
    retcode := -2;
    return;
  end_if;
            
END_FUNCTION


FUNCTION SafetyManager::AddToLocalIFs
	VAR_INPUT
		pHelpPDO 	: ^t_PdoCfg;
	END_VAR
  VAR
  	AddSource : BOOL;
    i : USINT;
    pHelpSafety : ^t_SafetyComponent;
  END_VAR

  // check if there is still room for new modules
  if LocalIFNo < MAX_INTERNAL_IF_MODULES then
    
    AddSource := TRUE;

    // if there is a list, check if any of our modules are already in the list
    if LocalIFNo then
      for i := 0 to (LocalIFNo-1) do
        // check if crc matches
        if (aLocalIFs[i].InterfaceCRC = pHelpPDO^.InterfaceCRC) then
          AddSource := FALSE;
          exit;
        end_if;
      end_for;
    end_if;

    // now we know how many we have to add to the list. if there are modules to add and there is enough space for all of them => do it
    if AddSource then
      // search it in the local modules
      pHelpSafety := pFirstSafetyComponent;
      while pHelpSafety do
        // if the path matches, add the module to the list

        // source module
        if (pHelpSafety^.PathLen = (pHelpPDO^.SourcePathLen - 1)) & 
        // we compare the last x byte (where x is the length of the local path including the domain) because we got different length info sizes (1 byte vs. 2 byte)
           (To_StdLib.MemCmp(pHelpSafety^.pPath + 1, pHelpPDO^.pSourcePath + 2 + pHelpPDO^.pSourcePath^ - pHelpSafety^.pPath^, pHelpSafety^.pPath^) = 0) then
          aLocalIFs[LocalIFNo].InterfaceCRC  := pHelpPDO^.InterfaceCRC;
          aLocalIFs[LocalIFNo].pSafetyModule := pHelpSafety;
          LocalIFNo += 1;
          exit;
        end_if;
      
        pHelpSafety := pHelpSafety^.pNext;
      end_while;
    end_if;
  end_if;

END_FUNCTION


FUNCTION SafetyManager::IFInfoNotArrivedYet
	VAR_INPUT
		pThis 	: pVirtualBase;
	END_VAR
	VAR_OUTPUT
		InfoNotAvailable 	: BOOL;
	END_VAR
  VAR
  	pHelpManaging : ^t_ManagingComponent;
  END_VAR

	InfoNotAvailable := FALSE;
  
  pHelpManaging := pFirstManagingInterfaceComponent;
  while pHelpManaging do
    if pHelpManaging^.pThis = pThis then
      if pHelpManaging^.InfoBits.GotIFInfo = FALSE then
        InfoNotAvailable := TRUE;
      end_if;
      return;
    end_if;
  
    pHelpManaging := pHelpManaging^.pNext;
  end_while;

END_FUNCTION

#pragma warning(disable:74)
FUNCTION SafetyManager::StartTimeMeasurement
	VAR_INPUT
		usMode (EAX) 	: DINT;
	END_VAR
#ifdef VM_CLASS_TIME_MEASUREMENT
  VAR
  	tmpTime : ^t_TimeMeasurementVaran;
  END_VAR

  case usMode of
  
    //-----------------------------------------------------------
    
    VARANTIME_RT:
      tmpTime := #s_TimeRt;
    
    //-----------------------------------------------------------
    
    VARANTIME_RTPOSTSCAN:
      tmpTime := #s_TimeRtPostScan;
    
    //-----------------------------------------------------------
    
    VARANTIME_CY:
      tmpTime := #s_TimeCy;
    
    //-----------------------------------------------------------
    
  end_case;
  
  if ( tmpTime^.us_Activate ) then
//    Save_Flg();
//    CLI();
    tmpTime^.ud_Timemark := OS_READMICROSEC();
  end_if;

#endif

END_FUNCTION


FUNCTION SafetyManager::StopTimeMeasurement
	VAR_INPUT
		usMode (EAX) 	: DINT;
	END_VAR
#ifdef VM_CLASS_TIME_MEASUREMENT
  VAR
  	tmpTime : ^t_TimeMeasurementVaran;
  END_VAR

  case usMode of
  
    //-----------------------------------------------------------
    
    VARANTIME_RT:
      tmpTime := #s_TimeRt;
    
    //-----------------------------------------------------------
    
    VARANTIME_RTPOSTSCAN:
      tmpTime := #s_TimeRtPostScan;
    
    //-----------------------------------------------------------
    
    VARANTIME_CY:
      tmpTime := #s_TimeCy;
    
    //-----------------------------------------------------------
    
  end_case;

	if ( tmpTime^.us_Activate ) then

		//get actual time
		tmpTime^.ud_ActualTime := OS_READMICROSEC();
    tmpTime^.ud_ActualTime -= tmpTime^.ud_Timemark;

		//look for maximum time
		if ( tmpTime^.ud_ActualTime > tmpTime^.ud_MaximalTime ) then
			tmpTime^.ud_MaximalTime := tmpTime^.ud_ActualTime;
		end_if;

		//look for minimum time
		if ( tmpTime^.ud_ActualTime < tmpTime^.ud_MinimalTime ) then
			tmpTime^.ud_MinimalTime := tmpTime^.ud_ActualTime;
		end_if;

		//look for average time (100000 cycles)
		if ( tmpTime^.ud_AverageCounter = 100000 ) then

			tmpTime^.ud_AverageTime 	:= tmpTime^.ud_AverageSum / tmpTime^.ud_AverageCounter;
			tmpTime^.ud_AverageSum 	:= 0;
			tmpTime^.ud_AverageCounter := 0;

		else
			tmpTime^.ud_AverageSum += ( tmpTime^.ud_ActualTime / 100 );
			tmpTime^.ud_AverageCounter += 1;
		end_if;

//		STI();
//    Restore_Flg();
	end_if;
  
#endif

END_FUNCTION // Varan_Base::StopTimeMeasurement
#pragma warning(default:74)


FUNCTION SafetyManager::AnyIFDomainSynchron
	VAR_OUTPUT
		AnythingSynchron 	: BOOL;
	END_VAR
  VAR
    pHelpManaging   : ^t_ManagingComponent;
  END_VAR

  AnythingSynchron := FALSE;
  
  pHelpManaging := pFirstManagingInterfaceComponent;
  while pHelpManaging do
    if pHelpManaging^.InfoBits.IsSynchron then
      AnythingSynchron := TRUE;
      return;
    end_if;
    
    pHelpManaging := pHelpManaging^.pNext;
  end_while;

END_FUNCTION


FUNCTION SafetyManager::LocalIFsAvailable
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    pHelpCfg : ^t_CfgListElem;
    pHelpPdo : ^t_PdoListElem;
    pHelpModule : ^t_ModuleListElem;
  END_VAR

  retcode := FALSE;
  
  // add all local configs to our structure
  SendLocalCfgsToMaster();
  
  // check the local configs for interface frames
  pHelpCfg := pConfigs;
  while pHelpCfg do
    pHelpPdo := pHelpCfg^.pFirstPdoCfg;
    while pHelpPdo do
      if pHelpPdo^.PdoInfo.Info.IsInterfacePDO | pHelpPdo^.PdoInfo.Info.IFBroadCast then
        retcode := TRUE;
        return;
      end_if;
      
      pHelpPdo := pHelpPdo^.pNext;
    end_while;

    pHelpModule := pHelpCfg^.pFirstModuleCfg;
    while pHelpModule do
      if pHelpModule^.ModuleInfo.Info.IsInterfaceSource | pHelpModule^.ModuleInfo.Info.IsInterfaceDest then
        retcode := TRUE;
        return;
      end_if;
    
      pHelpModule := pHelpModule^.pNext;
    end_while;
  
    pHelpCfg := pHelpCfg^.pNext;
  end_while;

END_FUNCTION


FUNCTION SafetyManager::IsCPUModule
  VAR_INPUT
    ModuleType : t_e_ModuleType;
  END_VAR
  VAR_OUTPUT
  	retcode : BOOL;
  END_VAR

  case ModuleType of
    _CSCP01x,
    _SCP010,
    _SCP011:
      retcode := TRUE;
  else
    retcode := FALSE;
  end_case; 

END_FUNCTION
