//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "CDias2DataMover"
	Revision           = "1.50"
	GUID               = "{E92FB3C3-AE7B-46EE-BD1A-51A759F6C469}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(592,120)">
	<Channels>
		<Server Name="Control" WriteProtected="false">
		</Server>
		<Client Name="CDIAS_BusAddress" Required="true" Internal="false" DefValue="0" Comment="Address on wishbone bus"/>
		<Client Name="MoverActive" Required="true" Internal="false" DefValue="1" Comment="set init-value to deactivate/activate mover usage&#13;&#10;&#13;&#10;0..Communication without mover (more busload but faster reaction of single modules)&#13;&#10;1..Communication with mover (less busload but values are collected by civ =&gt; slower reaction of single modules)"/>
		<Client Name="To_DataMover" Required="true" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="renste"/>
		<Dokumentation Revision="1.50" Date="12.02.2014" Author="PieSte" Company="Sigmatek" Description="Add read Client CDIAS_BusAdress and MoverActive in GetEEState to set value with connected server."/>
		<Dokumentation Revision="1.40" Date="06.12.2013" Author="LanSte" Company="Sigmatek" Description="Added payload support"/>
		<Dokumentation Revision="1.30" Date="18.07.2013" Author="ZoePat" Company="Sigmatek" Description="Added possibility to move data on CDIAS behind DataMover."/>
		<Dokumentation Revision="1.20" Date="05.11.2012" Author="RamAnd" Company="Sigmatek" Description="Corrected FlexHub Plug&apos;n&apos;Play functionality for modules with CDIAS Interface"/>
		<Dokumentation Revision="1.12" Date="27.06.2011" Author="RamAnd" Company="Sigmatek" Description="Support of sorting VARAN commands by priority added (needed for communication between safety-modules)."/>
		<Dokumentation Revision="1.11" Date="05.01.2011" Author="BleErn" Company="Sigmatek" Description="Removed #define VM_SINGLE_ID from DEFINES-section because it triggered an identical redefinition error"/>
		<Dokumentation Revision="1.10" Date="04.01.2011" Author="BleErn" Company="Sigmatek" Description="Added Client Transparent that allows to disable a VARAN-HW-Class"/>
		<Dokumentation Revision="1.9" Date="10.12.2010" Author="RamAnd" Company="Sigmatek" Description="Corrected RetryCounter handling and removed it for the internal move command."/>
		<Dokumentation Revision="1.8" Date="02.12.2010" Author="BleErn" Company="Sigmatek" Description="Created derivation of method AddDiasIRQ to prevent an exception on CPUs without DIAS"/>
		<Dokumentation Revision="1.7" Date="15.10.2010" Author="RamAnd" Company="Sigmatek" Description="Added method AddMovDO for the move command in the VM."/>
		<Dokumentation Revision="1.6" Date="22.07.2010" Author="WocPet" Company="Sigmatek" Description="Changes in base class: Functionality for required error handling added"/>
		<Dokumentation Revision="1.5" Date="23.02.2010" Author="BleErn" Company="Sigmatek" Description="New virtual method UpdateRtPostScan added to base class"/>
		<Dokumentation Revision="1.4" Date="18.12.2009" Author="RamAnd" Company="Sigmatek" Description="Added functionality to use Safety modules with activated Mover"/>
		<Dokumentation Revision="1.3" Date="18.05.2009" Author="wocpet" Company="Sigmatek" Description="New Variable was added to set CDIAS address in init phase (for CIV521 adress mapping)"/>
		<Dokumentation Revision="1.2" Date="12.02.2009" Author="RamAnd" Company="Sigmatek" Description="New Client added to disable DataMover functionality. Only available with new FPGA Version (1.7)"/>
	</RevDoku>
	<Network Name="CDias2DataMover">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{65BE266B-0E50-4ED4-938E-7252081FEC68}"
				Class      = "CIV_Base"
				Position   = "(270,150)"
				Visualized = "true">
				<Channels>
					<Server Name="Control"/>
					<Client Name="To_StdLib"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Control" Destination="_base.Control" Vertices="(742,210),(570,240),"/>
			<Connection Source="_base.VaranIn" Destination="this.VaranIn" Vertices="(270,240),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using CIV_Base

CDias2DataMover : CLASS
: CIV_Base
  //Servers:
  //Clients:
	To_DataMover 	: CltChCmd_Varan_DataMover;
	CDIAS_BusAddress 	: CltCh_HDINT;
	MoverActive 	: CltCh_DINT;
  //Variables:
		s_DummyHeader 	: LSL_VARANFRAME;
		b_First 	: BOOL;
		CDIAS_Offset 	: UDINT;
		b_CDIAS_Offset_Set 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a delay time to mover list&#13;&#10;=================================================================================================&#13;&#10;" Name="AddWait"/>
	FUNCTION VIRTUAL GLOBAL AddWait
		VAR_INPUT
			RTCY 	: DINT;
			Time_uSec 	: DINT;			//! <Variable Comment="Time in uSec (valid from 0-255)" Name="AddWait.Time_uSec"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a 8Bit write access&#13;&#10;=================================================================================================&#13;&#10;" Name="AddWr8Bit"/>
	FUNCTION VIRTUAL GLOBAL AddWr8Bit
		VAR_INPUT
			adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			data 	: USINT;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a 16Bit write access&#13;&#10;=================================================================================================&#13;&#10;" Name="AddWr16Bit"/>
	FUNCTION VIRTUAL GLOBAL AddWr16Bit
		VAR_INPUT
			Adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			data 	: UINT;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a 16Bit read access&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRd16Bit"/>
	FUNCTION VIRTUAL GLOBAL AddRd16Bit
		VAR_INPUT
			Adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to make a 16 Bit read access (direct access)&#13;&#10;=================================================================================================&#13;&#10;Data : 0-255   Bit 31 = 1 .. Error&#13;&#10;" Name="Rd16Bit"/>
	FUNCTION VIRTUAL GLOBAL Rd16Bit
		VAR_INPUT
			Adress 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Data 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to make a 8 Bit read access (direct access)&#13;&#10;=================================================================================================&#13;&#10;Data : 0-255   Bit 31 = 1 .. Error&#13;&#10;" Name="Rd8Bit"/>
	FUNCTION VIRTUAL GLOBAL Rd8Bit
		VAR_INPUT
			Adress 	: UDINT;			//! <Variable Comment="adress of access" Name="Rd8Bit.Adress"/>
		END_VAR
		VAR_OUTPUT
			Data 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to make a 8 Bit write access (direct access)&#13;&#10;=================================================================================================&#13;&#10;" Name="Wr8Bit"/>
	FUNCTION VIRTUAL GLOBAL Wr8Bit
		VAR_INPUT
			Adress 	: UDINT;
			Data 	: USINT;			//! <Variable Comment="data which should be written" Name="Wr8Bit.Data"/>
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to make a 16 Bit write access (direct access)&#13;&#10;=================================================================================================&#13;&#10;" Name="Wr16Bit"/>
	FUNCTION VIRTUAL GLOBAL Wr16Bit
		VAR_INPUT
			Adress 	: UDINT;
			Data 	: UINT;
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a 8Bit read access&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRd8Bit"/>
	FUNCTION VIRTUAL GLOBAL AddRd8Bit
		VAR_INPUT
			Adress 	: HINT;
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
		END_VAR
		VAR_OUTPUT
			Handle 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to get state&#13;&#10;=================================================================================================&#13;&#10;" Name="GetEEState"/>
	FUNCTION VIRTUAL GLOBAL GetEEState
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddDiasIRQ
		VAR_INPUT
			Place 	: USINT;
			ActionPtr 	: pVoid;
			thisptr 	: pVoid;
		END_VAR
		VAR_OUTPUT
			ok 	: USINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AddMove
		VAR_INPUT
			RTCY 	: DINT;
			thisp 	: ^void;
			callOptions 	: USINT := CALL_OPTION_RT_PRESCAN;
			SourceAddr 	: HDINT := 0;			//! <Variable Comment="only used for move with datamover" Name="AddMove.SourceAddr"/>
			DestAddr 	: HDINT := 0;			//! <Variable Comment="only used for move with datamover" Name="AddMove.DestAddr"/>
			MoveLen 	: UDINT := 0;			//! <Variable Comment="only used for move with datamover" Name="AddMove.MoveLen"/>
			pEnable 	: ^USINT := 0;			//! <Variable Comment="only used for move with datamover" Name="AddMove.pEnable"/>
			Settings 	: HDINT := 0;			//! <Variable Comment="only used for move with datamover&#13;&#10;&#13;&#10;settings:&#13;&#10; priority         -&gt; VM_PRIORITY_FILTER (VM_PRIORITY_1; VM_PRIORITY_2; VM_PRIORITY_3;)&#13;&#10; add CDIAS-addr   -&gt; 0x01: add to source; 0x02: add to dest; 0x03: add to both;" Name="AddMove.Settings"/>
		END_VAR
		VAR_OUTPUT
			HandleMove 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function call function of VaranMaster to add a read data object to varan master and install a varan task&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRdDO"/>
	FUNCTION VIRTUAL GLOBAL AddRdDO
		VAR_INPUT
			ud_dol_type 	: UDINT;			//! <Variable Comment=" type of DOL list( Realtime = 3, cyclic = 4 )" Name="AddRdDO.ud_dol_type"/>
			p_ud_handle 	: ^UDINT;			//! <Variable Comment=" pointer to variable to set right handle" Name="AddRdDO.p_ud_handle"/>
			ud_address 	: UDINT;			//! <Variable Comment="address of do" Name="AddRdDO.ud_address"/>
			ud_length 	: UDINT;			//! <Variable Comment="length of data should read" Name="AddRdDO.ud_length"/>
			p_ud_data 	: ^UDINT;			//! <Variable Comment="variable to get pointer to readed data" Name="AddRdDO.p_ud_data"/>
			ud_type 	: UDINT;			//! <Variable Comment="0=control area, 1=memory area" Name="AddRdDO.ud_type"/>
			p_ud_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddRdDO.p_ud_DataAddr"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;			//! <Variable Comment=" 0=OK, negative=error (look lsl_st_varan.h)" Name="AddRdDO.sd_retval"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function call function of VaranMaster to add a write data object to varan master and install a varan task&#13;&#10;=================================================================================================&#13;&#10;" Name="AddWrDO"/>
	FUNCTION VIRTUAL GLOBAL AddWrDO
		VAR_INPUT
			ud_dol_type 	: UDINT;
			p_ud_handle 	: ^UDINT;
			ud_address 	: UDINT;
			ud_length 	: UDINT;
			p_ud_data 	: ^UDINT;
			ud_type 	: UDINT;
			p_ud_DataAddr 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the data is given back" Name="AddWrDO.p_ud_DataAddr"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function call function of VaranMaster to add a read/write data object to varan master and install a varan task&#13;&#10;=================================================================================================&#13;&#10;" Name="AddRdWrDO"/>
	FUNCTION VIRTUAL GLOBAL AddRdWrDO
		VAR_INPUT
			ud_dol_type 	: UDINT;
			p_ud_handle 	: ^UDINT;
			ud_address_read 	: UDINT;			//! <Variable Comment="read address of do" Name="AddRdWrDO.ud_address_read"/>
			ud_length_read 	: UDINT;			//! <Variable Comment=" Length of read data object" Name="AddRdWrDO.ud_length_read"/>
			p_ud_data_read 	: ^UDINT;			//! <Variable Comment=" pointer to variable to get pointer to data" Name="AddRdWrDO.p_ud_data_read"/>
			ud_address_write 	: UDINT;			//! <Variable Comment="write address of do" Name="AddRdWrDO.ud_address_write"/>
			ud_length_write 	: UDINT;			//! <Variable Comment=" Length of write data object" Name="AddRdWrDO.ud_length_write"/>
			p_ud_data_write 	: ^UDINT;			//! <Variable Comment=" pointer to variable to get pointer to data" Name="AddRdWrDO.p_ud_data_write"/>
			ud_type 	: UDINT;
			p_ud_DataAddr_read 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the read data is given back" Name="AddRdWrDO.p_ud_DataAddr_read"/>
			p_ud_DataAddr_write 	: ^HDINT := NIL;			//! <Variable Comment="here the used DPRam address of the write data is given back" Name="AddRdWrDO.p_ud_DataAddr_write"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to read a direct access data object&#13;&#10;=================================================================================================&#13;&#10;" Name="RdDO"/>
	FUNCTION VIRTUAL GLOBAL RdDO
		VAR_INPUT
			ud_address 	: UDINT;			//! <Variable Comment=" Address of data object" Name="RdDO.ud_address"/>
			ud_length 	: UDINT;			//! <Variable Comment=" Length of data object" Name="RdDO.ud_length"/>
			p_ud_data 	: pVoid;			//! <Variable Comment=" pointer to variable to get pointer to data" Name="RdDO.p_ud_data"/>
			ud_type 	: UDINT;			//! <Variable Comment="0=control area, 1=memory area" Name="RdDO.ud_type"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;			//! <Variable Comment=" 0=OK, negative=error (look lsl_st_varan.h)" Name="RdDO.sd_retval"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to write a direct access data object&#13;&#10;=================================================================================================&#13;&#10;" Name="WrDO"/>
	FUNCTION VIRTUAL GLOBAL WrDO
		VAR_INPUT
			ud_address 	: UDINT;
			ud_length 	: UDINT;
			p_ud_data 	: pVoid;
			ud_type 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to reset a data object&#13;&#10;=================================================================================================&#13;&#10;" Name="ResetDO"/>
	FUNCTION VIRTUAL GLOBAL ResetDO
		VAR_INPUT
			p_data_object 	: ^DINT;			//! <Variable Comment="pointer to varan data object header" Name="ResetDO.p_data_object"/>
			us_state 	: USINT;			//! <Variable Comment="state of data object" Name="ResetDO.us_state"/>
			ud_bytes 	: UDINT;			//! <Variable Comment="bytes of cdias accesses" Name="ResetDO.ud_bytes"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to find out if varan is available&#13;&#10;=================================================================================================&#13;&#10;" Name="IsVaranAvailable"/>
	FUNCTION VIRTUAL GLOBAL IsVaranAvailable
		VAR_OUTPUT
			sd_varan 	: DINT;			//! <Variable Comment="0=varan not available, 1=varan available" Name="IsVaranAvailable.sd_varan"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="SetNewDOAddressRd"/>
	FUNCTION VIRTUAL GLOBAL SetNewDOAddressRd
		VAR_INPUT
			p_data 	: ^DINT;			//! <Variable Comment="pointer to varan write data" Name="SetNewDOAddressRd.p_data"/>
			ud_address 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="SetNewDOAddressWr"/>
	FUNCTION VIRTUAL GLOBAL SetNewDOAddressWr
		VAR_INPUT
			p_data 	: ^DINT;
			ud_address 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="SetNewDOAddressRdWr"/>
	FUNCTION VIRTUAL GLOBAL SetNewDOAddressRdWr
		VAR_INPUT
			p_data 	: ^DINT;
			ud_address_read 	: UDINT;			//! <Variable Comment=" Address of read data object" Name="SetNewDOAddressRdWr.ud_address_read"/>
			ud_address_write 	: UDINT;			//! <Variable Comment=" Address of write data object" Name="SetNewDOAddressRdWr.ud_address_write"/>
		END_VAR;
	
	FUNCTION VIRTUAL AddPayloadDO
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL SafetyMoverDisable;
	
	FUNCTION GLOBAL SafetyMoverEnable;
	
	FUNCTION GLOBAL SafetyMoverConfigured;
	
	FUNCTION VIRTUAL SetCDIASOffset;
	
	FUNCTION VIRTUAL GLOBAL Control::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd Varan_DataMover


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB CDias2DataMover::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_CDIAS2DATAMOVER
1$UINT, 50$UINT, (SIZEOF(::CDias2DataMover))$UINT, 
0$UINT, 3$UINT, 0$UINT, 
TO_UDINT(1046309609), "CDias2DataMover", //Class
TO_UDINT(2756859380), "CIV_Base", 2$UINT, 61$UINT, //Baseclass
//Servers:
//Clients:
(::CDias2DataMover.To_DataMover.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1067327212), "To_DataMover", TO_UDINT(3752737333), "Varan_DataMover", 1$UINT, 50$UINT, 
(::CDias2DataMover.CDIAS_BusAddress.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1385799590), "CDIAS_BusAddress", 
(::CDias2DataMover.MoverActive.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3350278117), "MoverActive", 
END_FUNCTION


#define USER_CNT_CDias2DataMover 66

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_CDias2DataMover] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION CDias2DataMover::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= CIV_Base::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= DiasMaster::Control.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, DiasMaster::Control.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_CDias2DataMover;
	vmt.CmdTable.NewInstr		:= #Control::NewInst();
	vmt.CmdTable.Write		:= #Control::M_WR_DIRECT();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #AddWait();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddWr8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #AddWr16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #AddRd16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Rd16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #Rd8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #Wr8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #Wr16Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #AddRd8Bit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #GetEEState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #AddDiasIRQ();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #AddMove();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #AddRdDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[37]		:= #AddWrDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[38]		:= #AddRdWrDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #RdDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[41]		:= #WrDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[44]		:= #ResetDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #IsVaranAvailable();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[46]		:= #SetNewDOAddressRd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[47]		:= #SetNewDOAddressWr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[48]		:= #SetNewDOAddressRdWr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[63]		:= #AddPayloadDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[65]		:= #SetCDIASOffset();

#pragma warning (default : 74)
	DiasMaster::Control.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DiasMaster::Control.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma using Varan_Base

(************************************************************************************
*
*	CDias interface class for Varan Data Mover
*	Created : Sigmatek	/	SR	/	2007
*	Changes : 
*
*
*   FOR NEWER CHANGES SEE REVISION DOCUMENTATION IN CLASS PROPERTIES
*
*
*		1.0	=> 1.1	/	08.01.2008
*			- add single calls for data mover
*
************************************************************************************)

#define VM_SINGLE_ID			16#8000_0000

//[#ENGLISH]
//=================================================================================================
//Function to get state
//=================================================================================================
FUNCTION VIRTUAL GLOBAL CDias2DataMover::GetEEState
VAR_OUTPUT
	State		: DINT;
END_VAR
  
  //get client values
  CDIAS_BusAddress := CDIAS_BusAddress.Read();
  MoverActive      := MoverActive.Read();
  if MoverActive then
    //first initialise data mover
    if ( b_First = FALSE ) then
      To_DataMover.Init();
      b_First := TRUE;
    end_if;
    State := 2;	
  else
    State := CIV_Base::GetEEState();
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::GetEEState
//[#ENGLISH]
//=================================================================================================
//Function to make a 8 Bit read access (direct access)
//=================================================================================================
//Data : 0-255   Bit 31 = 1 .. Error
FUNCTION VIRTUAL GLOBAL CDias2DataMover::Rd8Bit
VAR_INPUT
	Adress		: UDINT;
END_VAR
VAR_OUTPUT
	Data		: DINT;
END_VAR
  
  if MoverActive then
    Data := 0;
    To_DataMover.DirectAccessRead	( ud_address 	:= CDIAS_BusAddress + Adress
                    , ud_length 	:= 1
                    , p_data 		:= #Data 
                    );
  else
    Data := CIV_Base::Rd8Bit(CDIAS_Offset + Adress);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::Rd8Bit
//[#ENGLISH]
//=================================================================================================
//Function to make a 16 Bit read access (direct access)
//=================================================================================================
//Data : 0-255   Bit 31 = 1 .. Error
FUNCTION VIRTUAL GLOBAL CDias2DataMover::Rd16Bit
VAR_INPUT
	Adress		: UDINT;
END_VAR
VAR_OUTPUT
	Data		: DINT;
END_VAR

  if MoverActive then
    Data := 0;
    To_DataMover.DirectAccessRead	( ud_address 	:= CDIAS_BusAddress + Adress
                    , ud_length 	:= 2
                    , p_data 		:= #Data 
                    );
  else
    Data := CIV_Base::Rd16Bit(CDIAS_Offset + Adress);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::Rd16Bit
//[#ENGLISH]
//=================================================================================================
//Function to make a 8 Bit write access (direct access)
//=================================================================================================
//[>Adress]Address for read access
//[>Data]data which should be written
FUNCTION VIRTUAL GLOBAL CDias2DataMover::Wr8Bit
VAR_INPUT
	Adress		: UDINT;
	Data		: Usint;
END_VAR
VAR_OUTPUT
	State		: DINT;
END_VAR
  
  if MoverActive then
    State := To_DataMover.DirectAccessWrite	( ud_address 	:= CDIAS_BusAddress + Adress
                        , ud_length 	:= 1
                        , p_data 		:= #Data 
                        );
  else
    State := CIV_Base::Wr8Bit(CDIAS_Offset + Adress, Data);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::Wr8Bit
//[#ENGLISH]
//=================================================================================================
//Function to make a 16 Bit write access (direct access)
//=================================================================================================
//[>Adress]Address for read access
//[>Data]data which should be written
FUNCTION VIRTUAL GLOBAL CDias2DataMover::Wr16Bit
VAR_INPUT
	Adress		: UDINT;
	Data		: UINT;
END_VAR
VAR_OUTPUT
	State		: DINT;
END_VAR

  if MoverActive then
    State := To_DataMover.DirectAccessWrite	( ud_address 	:= CDIAS_BusAddress + Adress
                        , ud_length 	:= 2
                        , p_data 		:= #Data 
                        );
  else
    State := CIV_Base::Wr16Bit(CDIAS_Offset + Adress, Data);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::Wr16Bit
#pragma warning (disable:73)

//[#ENGLISH]
//=================================================================================================
//Function to read a direct access data object
//=================================================================================================
//[>ud_address]address to read
//[>ud_length]length of data should read
//[>p_ud_data]variable to get pointer to readed data
//[>ud_type]0=control area, 1=memory area
FUNCTION VIRTUAL GLOBAL CDias2DataMover::RdDO
VAR_INPUT
	ud_address		: UDINT;
	ud_length		: UDINT;
	p_ud_data		: pVoid;
	ud_type			: UDINT;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR

  if MoverActive then
    sd_retval := To_DataMover.DirectAccessRead	( ud_address 	:= CDIAS_BusAddress + ud_address
                          , ud_length 	:= ud_length
                          , p_data 		:= p_ud_data 
                          );
  else
    sd_retval := CIV_Base::RdDO(CDIAS_Offset + ud_address, ud_length, p_ud_data, ud_type);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::RdDO

//[#ENGLISH]
//=================================================================================================
//Function to write a direct access data object
//=================================================================================================
//[>ud_address]address to write
//[>ud_length]length of data should be written
//[>p_ud_data]pointer to data should be written
//[>ud_type]0=control area, 1=memory area
FUNCTION VIRTUAL GLOBAL CDias2DataMover::WrDO
VAR_INPUT
	ud_address		: UDINT;
	ud_length		: UDINT;
	p_ud_data		: pVoid;
	ud_type			: UDINT;
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR

  if MoverActive then
    sd_retval := To_DataMover.DirectAccessWrite	( ud_address 	:= CDIAS_BusAddress + ud_address
                          , ud_length 	:= ud_length
                          , p_data 		:= p_ud_data 
                          );
  else
    sd_retval := CIV_Base::WrDO(CDIAS_Offset + ud_address, ud_length, p_ud_data, ud_type);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::WrDO
//[#ENGLISH]
//=================================================================================================
//Function to reset a data object
//=================================================================================================
//[>p_data_object]pointer to varan data object header
//[>us_state]state of data object
//[>ud_bytes]bytes of cdias accesses
FUNCTION VIRTUAL GLOBAL CDias2DataMover::ResetDO
	VAR_INPUT
	p_data_object		: ^DINT;
	us_state		: USINT;
	ud_bytes		: UDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

  if MoverActive then
	//do nothing because cdias classes have no own DO's (to prevent Exception we must overload this methode)
    sd_retval := VARANMANAGER_OK;
  else
    sd_retval := CIV_Base::ResetDO(p_data_object, us_state, ud_bytes);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::ResetDO
//[#ENGLISH]
//[>p_data]pointer to varan write data
//[>ud_address]address of do
FUNCTION VIRTUAL GLOBAL CDias2DataMover::SetNewDOAddressWr
VAR_INPUT
	p_data			: ^DINT;
	ud_address		: UDINT;
END_VAR

  if MoverActive then
	//do nothing because cdias classes have no own DO's (do prevent Exception we must overload this methode)
  else
    CIV_Base::SetNewDOAddressWr(p_data, CDIAS_Offset + ud_address);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::SetNewDOAddressWr
//[#ENGLISH]
//[>p_data]pointer to varan write data
//[>ud_address_read]read address of do
//[>ud_address_write]write address of do
FUNCTION VIRTUAL GLOBAL CDias2DataMover::SetNewDOAddressRdWr
VAR_INPUT
	p_data				: ^DINT;
	ud_address_read		: UDINT;
	ud_address_write	: UDINt;
END_VAR

  if MoverActive then
	//do nothing because cdias classes have no own DO's (do prevent Exception we must overload this methode)
  else
    CIV_Base::SetNewDOAddressRdWr(p_data, CDIAS_Offset + ud_address_read, CDIAS_Offset + ud_address_write);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::SetNewDOAddressRdWr
//[#ENGLISH]
//[>p_data]pointer to varan write data
//[>ud_address]address of do
FUNCTION VIRTUAL GLOBAL CDias2DataMover::SetNewDOAddressRd
VAR_INPUT
	p_data			: ^DINT;
	ud_address		: UDINT;
END_VAR

  if MoverActive then
	//do nothing because cdias classes have no own DO's (do prevent Exception we must overload this methode)
  else
    CIV_Base::SetNewDOAddressRd(p_data, CDIAS_Offset + ud_address);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::SetNewDOAddressRd

#pragma warning (default:73)

//[#ENGLISH]
//=================================================================================================
//Function call function of VaranMaster to add a read data object to varan master and install a varan task
//=================================================================================================
//[>ud_dol_type] pointer to variable to set right handle
//[>p_ud_handle]pointer to variable to set right handle
//[>ud_address] Address of data object
//[>ud_length] Length of data object
//[>p_ud_data] pointer to variable to get pointer to data
//[>ud_type]0=control area, 1=memory area
//[<sd_retval] 0=OK, negative=error (look lsl_st_varan.h)
FUNCTION VIRTUAL GLOBAL CDias2DataMover::AddRdDO
	VAR_INPUT
		ud_dol_type 	: UDINT;
		p_ud_handle 	: ^UDINT;
		ud_address 	: UDINT;
		ud_length 	: UDINT;
		p_ud_data 	: ^UDINT;
		ud_type 	: UDINT;
		p_ud_DataAddr 	: ^HDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    ((0)$^USINT)^ := 0; 
  end_if;  
#endif  

  if MoverActive then
    if ( ud_dol_type = VARAN_DOL_ISO ) then

      //check if we have a single
      if ( ud_type and VM_SINGLE_ID ) then

        sd_retval := To_DataMover.AddRdISOEnable( ud_add		:= CDIAS_BusAddress + ud_address
                            , ud_length		:= ud_length
                            , p_data		:= p_ud_data
                            , p_enable		:= p_ud_handle$^USINT
                            , ud_Priority := ud_type AND VM_PRIORITY_FILTER
                            , p_DataAddr  := p_ud_DataAddr
                            );
      else

        sd_retval := To_DataMover.AddRdISO	( ud_add 	:= CDIAS_BusAddress + ud_address
                          , ud_length := ud_length
                          , p_data 	:= p_ud_data 
                          , ud_Priority := ud_type AND VM_PRIORITY_FILTER
                          , p_DataAddr  := p_ud_DataAddr
                          );

        p_ud_handle^ := ( #s_DummyHeader )$UDINT;
      end_if;

    else

      //check if we have a single
      if ( ud_type and VM_SINGLE_ID ) then

        sd_retval := To_DataMover.AddRdASYEnable( ud_add		:= CDIAS_BusAddress + ud_address
                            , ud_length		:= ud_length
                            , p_data		:= p_ud_data
                            , p_enable		:= p_ud_handle$^USINT
                            , ud_Priority := ud_type AND VM_PRIORITY_FILTER
                            , p_DataAddr  := p_ud_DataAddr
                            );
      else

        sd_retval := To_DataMover.AddRdASY	( ud_add 	:= CDIAS_BusAddress + ud_address
                          , ud_length := ud_length
                          , p_data 	:= p_ud_data 
                          , ud_Priority := ud_type AND VM_PRIORITY_FILTER
                          , p_DataAddr  := p_ud_DataAddr
                          );

        p_ud_handle^ := ( #s_DummyHeader )$UDINT;
      end_if;
    end_if;
  else
    sd_retval := CIV_Base::AddRdDO(ud_dol_type, p_ud_handle, CDIAS_Offset + ud_address, ud_length, p_ud_data, ud_type);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::AddRdDO
//[#ENGLISH]
//=================================================================================================
//Function call function of VaranMaster to add a write data object to varan master and install a varan task
//=================================================================================================
//[>ud_dol_type] pointer to variable to set right handle
//[>p_ud_handle]pointer to variable to set right handle
//[>ud_address] Address of data object
//[>ud_length] Length of data object
//[>p_ud_data] pointer to variable to get pointer to data
//[>ud_type]0=control area, 1=memory area
//[<sd_retval] 0=OK, negative=error (look lsl_st_varan.h)
FUNCTION VIRTUAL GLOBAL CDias2DataMover::AddWrDO
	VAR_INPUT
		ud_dol_type 	: UDINT;
		p_ud_handle 	: ^UDINT;
		ud_address 	: UDINT;
		ud_length 	: UDINT;
		p_ud_data 	: ^UDINT;
		ud_type 	: UDINT;
		p_ud_DataAddr 	: ^HDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    ((0)$^USINT)^ := 0; 
  end_if;  
#endif  

  if MoverActive then
    if ( ud_dol_type = VARAN_DOL_ISO ) then

      //check if we have a single
      if ( ud_type and VM_SINGLE_ID ) then

        sd_retval := To_DataMover.AddWrISOEnable( ud_add		:= CDIAS_BusAddress + ud_address
                            , ud_length		:= ud_length
                            , p_data		:= p_ud_data
                            , p_enable		:= p_ud_handle$^USINT
                            , ud_Priority := ud_type AND VM_PRIORITY_FILTER
                            , p_DataAddr  := p_ud_DataAddr
                            );
      
      else
      
        sd_retval := To_DataMover.AddWrISO	( ud_add 	:= CDIAS_BusAddress + ud_address
                          , ud_length := ud_length
                          , p_data 	:= p_ud_data 
                          , ud_Priority := ud_type AND VM_PRIORITY_FILTER
                          , p_DataAddr  := p_ud_DataAddr
                          );

        p_ud_handle^ := ( #s_DummyHeader )$UDINT;
      end_if;

    else

      //check if we have a single
      if ( ud_type and VM_SINGLE_ID ) then

        sd_retval := To_DataMover.AddWrASYEnable( ud_add		:= CDIAS_BusAddress + ud_address
                            , ud_length		:= ud_length
                            , p_data		:= p_ud_data
                            , p_enable		:= p_ud_handle$^USINT
                            , ud_Priority := ud_type AND VM_PRIORITY_FILTER
                            , p_DataAddr  := p_ud_DataAddr
                            );

      else

        sd_retval := To_DataMover.AddWrASY	( ud_add 	:= CDIAS_BusAddress + ud_address
                          , ud_length := ud_length
                          , p_data 	:= p_ud_data 
                          , ud_Priority := ud_type AND VM_PRIORITY_FILTER
                          , p_DataAddr  := p_ud_DataAddr
                          );

        p_ud_handle^ := ( #s_DummyHeader )$UDINT;
      end_if;
    end_if;
  else
    sd_retval := CIV_Base::AddWrDO(ud_dol_type, p_ud_handle, CDIAS_Offset + ud_address, ud_length, p_ud_data, ud_type);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::AddWrDO
//[#ENGLISH]
//=================================================================================================
//Function call function of VaranMaster to add a read/write data object to varan master and install a varan task
//=================================================================================================
//[>ud_dol_type] type of DOL list( 1=direct access, 2=IRQ, 3=realtime, 4=cyclic )
//[>p_ud_handle] pointer to variable to set right handle
//[>ud_address_read] Address of read data object
//[>ud_length_read] Length of read data object
//[>p_ud_data_read] pointer to variable to get pointer to data
//[>ud_address_write] Address of write data object
//[>ud_length_write] Length of write data object
//[>p_ud_data_write] pointer to variable to get pointer to data
//[>ud_type]0=control area, 1=memory area
//[<sd_retval] 0=OK, negative=error (look lsl_st_varan.h)
FUNCTION VIRTUAL GLOBAL CDias2DataMover::AddRdWrDO
	VAR_INPUT
		ud_dol_type 	: UDINT;
		p_ud_handle 	: ^UDINT;
		ud_address_read 	: UDINT;
		ud_length_read 	: UDINT;
		p_ud_data_read 	: ^UDINT;
		ud_address_write 	: UDINT;
		ud_length_write 	: UDINT;
		p_ud_data_write 	: ^UDINT;
		ud_type 	: UDINT;
		p_ud_DataAddr_read 	: ^HDINT;
		p_ud_DataAddr_write 	: ^HDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    ((0)$^USINT)^ := 0; 
  end_if;  
#endif  

  if MoverActive then
    if ( ud_dol_type = VARAN_DOL_ISO ) then

      sd_retval := To_DataMover.AddRdISO	( ud_add 	:= CDIAS_BusAddress + ud_address_read
                        , ud_length := ud_length_read
                        , p_data 	:= p_ud_data_read 
                        , ud_Priority := ud_type AND VM_PRIORITY_FILTER
                        , p_DataAddr  := p_ud_DataAddr_read
                        );

      if ( sd_retval = VARANMANAGER_OK ) then
        sd_retval := To_DataMover.AddWrISO	( ud_add 	:= CDIAS_BusAddress + ud_address_write
                          , ud_length := ud_length_write
                          , p_data 	:= p_ud_data_write 
                          , ud_Priority := ud_type AND VM_PRIORITY_FILTER
                          , p_DataAddr  := p_ud_DataAddr_write
                          );
      end_if;
      p_ud_handle^ := ( #s_DummyHeader )$UDINT;

    else
      sd_retval := To_DataMover.AddRdASY	( ud_add 	:= CDIAS_BusAddress + ud_address_read
                        , ud_length := ud_length_read
                        , p_data 	:= p_ud_data_read 
                        , ud_Priority := ud_type AND VM_PRIORITY_FILTER
                        , p_DataAddr  := p_ud_DataAddr_read
                        );

      if ( sd_retval = VARANMANAGER_OK ) then
        sd_retval := To_DataMover.AddWrASY	( ud_add 	:= CDIAS_BusAddress + ud_address_write
                          , ud_length := ud_length_write
                          , p_data 	:= p_ud_data_write 
                          , ud_Priority := ud_type AND VM_PRIORITY_FILTER
                          , p_DataAddr  := p_ud_DataAddr_write
                          );
      end_if;
      p_ud_handle^ := ( #s_DummyHeader )$UDINT;
    end_if;
  else
    sd_retval := CIV_Base::AddRdWrDO(ud_dol_type, p_ud_handle, CDIAS_Offset + ud_address_read, ud_length_read, p_ud_data_read, ud_address_write, ud_length_write, p_ud_data_write, ud_type);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::AddRdWrDO
//[#ENGLISH]
//=================================================================================================
//Function to add a delay time to mover list
//=================================================================================================
//[>Time_uSec]Time in uSec (valid from 0-255)
FUNCTION VIRTUAL GLOBAL CDias2DataMover::AddWait
VAR_INPUT
	RTCY		: DINT;
	Time_uSec	: DINT;
END_VAR

  if MoverActive then
    To_DataMover.AddDelay	( ud_task 	:= RTCY$UDINT
                , ud_time 	:= Time_uSec$UDINT 
                );
  else
    CIV_Base::AddWait(RTCY, Time_uSec);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::AddWait

//[#ENGLISH]
//=================================================================================================
//Function to find out if varan is available
//=================================================================================================
//[<sd_varan]0=varan not available, 1=varan available
FUNCTION VIRTUAL GLOBAL CDias2DataMover::IsVaranAvailable
VAR_OUTPUT
	sd_varan		: DINT;
END_VAR

  if MoverActive then
    sd_varan := 2;
  else
    sd_varan := CIV_Base::IsVaranAvailable();
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::IsVaranAvailable
#pragma warning (disable:73)
#pragma warning (disable:76)

//[#ENGLISH]
//=================================================================================================
//Function to add a 8Bit read access
//=================================================================================================
//[>Adress]adress of access
//[>RTCY]cyclic or realtime
//[>thisp]thispointer of object
//[<Handle]pointer to data
FUNCTION VIRTUAL GLOBAL CDias2DataMover::AddRd8Bit
	VAR_INPUT
		Adress 	: HINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR
  
#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    ((0)$^USINT)^ := 0; 
  end_if;  
#endif  
  
  if MoverActive = 0 then
    Handle := CIV_Base::AddRd8Bit(to_uint(CDIAS_Offset) + Adress, RTCY, thisp);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::AddRd8Bit
//[#ENGLISH]
//=================================================================================================
//Function to add a 16Bit write access
//=================================================================================================
//[>Adress]adress of access
//[>RTCY]cyclic or realtime
//[>thisp]thispointer of object
//[>data]data of first access
//[<Handle]pointer to data
FUNCTION VIRTUAL GLOBAL CDias2DataMover::AddWr16Bit
	VAR_INPUT
		Adress 	: HINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		data 	: UINT;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR
  
#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    ((0)$^USINT)^ := 0; 
  end_if;  
#endif  
  
  if MoverActive = 0 then
    Handle := CIV_Base::AddWr16Bit(to_uint(CDIAS_Offset) + Adress, RTCY, thisp, data);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::AddWr16Bit
//[#ENGLISH]
//=================================================================================================
//Function to add a 8Bit write access
//=================================================================================================
//[>Adress]adress of access
//[>RTCY]cyclic or realtime
//[>thisp]thispointer of object
//[>data]data of first access
//[<Handle]pointer to data
FUNCTION VIRTUAL GLOBAL CDias2DataMover::AddWr8Bit
	VAR_INPUT
		adress 	: HINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		data 	: USINT;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR
  
#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    ((0)$^USINT)^ := 0; 
  end_if;  
#endif  
  
  if MoverActive = 0 then
    Handle := CIV_Base::AddWr8Bit(to_uint(CDIAS_Offset) + adress, RTCY, thisp, data);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::AddWr8Bit
//[#ENGLISH]
//=================================================================================================
//Function to add a 16Bit read access
//=================================================================================================
//[>Adress]adress of access
//[>RTCY]cyclic or realtime
//[>thisp]thispointer of object
//[<Handle]pointer to data
FUNCTION VIRTUAL GLOBAL CDias2DataMover::AddRd16Bit
	VAR_INPUT
		Adress 	: HINT;
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
	END_VAR
	VAR_OUTPUT
		Handle 	: DINT;
	END_VAR

#ifdef VM_DEBUG_PAYLOAD
  // Payload not supported
  if b_PayloadSupport then
    // This method is not supporded with Payload support
    ((0)$^USINT)^ := 0; 
  end_if;  
#endif  
  
  if MoverActive = 0 then
    Handle := CIV_Base::AddRd16Bit(to_uint(CDIAS_Offset) + Adress, RTCY, thisp);
  end_if;

END_FUNCTION //VIRTUAL GLOBAL CDias2DataMover::AddRd16Bit
#pragma warning (default:73)
#pragma warning (default:76)



FUNCTION VIRTUAL GLOBAL CDias2DataMover::Init

  if b_CDIAS_Offset_Set = false then
    SetCDIASOffset();
  end_if; 
  
  //call init from base class
  CIV_Base::Init();

END_FUNCTION

FUNCTION VIRTUAL CDias2DataMover::SetCDIASOffset

  CDIAS_Offset        := 16#1000;  //for CIV521
  b_CDIAS_Offset_Set  := true;

END_FUNCTION


FUNCTION GLOBAL CDias2DataMover::SafetyMoverDisable

  To_DataMover.SafetyMoverDisable();

END_FUNCTION


FUNCTION GLOBAL CDias2DataMover::SafetyMoverEnable

  To_DataMover.SafetyMoverEnable(MoverActive);

END_FUNCTION


FUNCTION GLOBAL CDias2DataMover::SafetyMoverConfigured

  To_DataMover.SafetyMoverConfigured();

END_FUNCTION

#pragma warning(disable:73 )
FUNCTION VIRTUAL GLOBAL CDias2DataMover::AddDiasIRQ
	VAR_INPUT
		Place 	: USINT;
		ActionPtr 	: pVoid;
		thisptr 	: pVoid;
	END_VAR
	VAR_OUTPUT
		ok 	: USINT;
	END_VAR

  Trace("Interupts on DiasBus over VARAN are not supported !!! Object:");
  ok := 0;

END_FUNCTION
#pragma warning(default:73 )


FUNCTION VIRTUAL GLOBAL CDias2DataMover::Control::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
  VAR
  	p_paraAddDO           : ^t_DM_CMD_AddDO;
  END_VAR
  
  ret_code := READY;
  
  // NewInst may be called before the init of this class 
  if b_CDIAS_Offset_Set = false then
    SetCDIASOffset();
  end_if; 
  
  if MoverActive then
    
    if pPara^.uiCmd = DM_ADD_PAYLOAD_DO then    
      if ( AddPayloadDO(pPara:=pPara, pResult:=pResult) ) then
        ret_code := ERROR;
      end_if;
    else
      // Passes on the NewInst command.
      ret_code := CIV_Base::NewInst(pPara:=pPara, pResult:=pResult);
    end_if;
      
  else
    if pPara^.uiCmd = DM_ADD_PAYLOAD_DO then    
  
      p_paraAddDO := (pPara^.aPara[0])$^t_DM_CMD_AddDO;
      
      // Addjust offset depending on command 
      case p_paraAddDO^.ud_Command of
        
        VARAN_CMD_CONTROL_READ,
        VARAN_CMD_MEMORY_READ:
          p_paraAddDO^.ud_OffsetRead += CDIAS_Offset;
        
        VARAN_CMD_CONTROL_WRITE,
        VARAN_CMD_MEMORY_WRITE:
          p_paraAddDO^.ud_OffsetWrite += CDIAS_Offset;
        
        VARAN_CMD_CONTROL_READ_WRITE,
        VARAN_CMD_MEMORY_READ_WRITE:
          p_paraAddDO^.ud_OffsetRead += CDIAS_Offset;
          p_paraAddDO^.ud_OffsetWrite += CDIAS_Offset;
      
      end_case;
      
      // Pass on the command
      ret_code := CIV_Base::NewInst(pPara:=pPara, pResult:=pResult);
      
    else
    
      // Pass on the command
      ret_code := CIV_Base::NewInst(pPara:=pPara, pResult:=pResult);        
    end_if;
  end_if;	

END_FUNCTION


FUNCTION VIRTUAL CDias2DataMover::AddPayloadDO
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
  	p_paraAddDO           : ^t_DM_CMD_AddDO;
  END_VAR
  
  // Method is only used when the Mover is active
  if MoverActive = 0 then
    sd_retval := CIV_Base::AddPayloadDO(pPara, pResult);
    return;
  end_if;

  
  p_paraAddDO := (pPara^.aPara[0])$^t_DM_CMD_AddDO;
  pResult^.uiLng := sizeof(DINT);    
  
  case p_paraAddDO^.ud_Command of
  
    VARAN_CMD_CONTROL_READ,
    VARAN_CMD_MEMORY_READ:  // Read DO ********************************************************************************************        
  
        if ( p_paraAddDO^.ud_DolType = VARAN_DOL_ISO ) then // ISO Read -----------------------------------------------------------

          //check if we have a single
          if ( p_paraAddDO^.pp_Enable) then              
            pResult^.aData[0]$DINT := to_DataMover.AddRdISOEnable(ud_add        := p_paraAddDO^.ud_OffsetRead + CDIAS_BusAddress
                                                                  , ud_length	  := p_paraAddDO^.ud_LengthRead
                                                                  , p_data		  := p_paraAddDO^.p_ud_ReadData
                                                                  , p_enable		:= p_paraAddDO^.pp_Enable$^USINT
                                                                  , ud_Priority := p_paraAddDO^.ud_Priority
                                                                  , p_DataAddr  := p_paraAddDO^.p_ud_DataAddr_read
                                                                , p_UserDOHandle:= p_paraAddDO^.p_UserDOHandle
                                                                  );
          else

            pResult^.aData[0]$DINT := To_DataMover.AddRdISO(ud_add 	    := p_paraAddDO^.ud_OffsetRead + CDIAS_BusAddress
                                                            , ud_length   := p_paraAddDO^.ud_LengthRead
                                                            , p_data 	    := p_paraAddDO^.p_ud_ReadData
                                                            , ud_Priority := p_paraAddDO^.ud_Priority
                                                            , p_DataAddr  := p_paraAddDO^.p_ud_DataAddr_read
                                                            );

          end_if;
          p_paraAddDO^.p_ud_DoHandle^ := ( #s_DummyHeader )$UDINT;

        else  // ASY Read --------------------------------------------------------------------------------------------------------
        
          //check if we have a single
          if ( p_paraAddDO^.pp_Enable) then              
            pResult^.aData[0]$DINT := to_DataMover.AddRdASYEnable(ud_add        := p_paraAddDO^.ud_OffsetRead + CDIAS_BusAddress
                                                                  , ud_length	  := p_paraAddDO^.ud_LengthRead
                                                                  , p_data		  := p_paraAddDO^.p_ud_ReadData                                                                    
                                                                  , p_enable		:= p_paraAddDO^.pp_Enable$^USINT
                                                                  , ud_Priority := p_paraAddDO^.ud_Priority
                                                                  , p_DataAddr  := p_paraAddDO^.p_ud_DataAddr_read
                                                                , p_UserDOHandle:= p_paraAddDO^.p_UserDOHandle
                                                                  );
          else
            pResult^.aData[0]$DINT := To_DataMover.AddRdASY	( ud_add 	    := p_paraAddDO^.ud_OffsetRead + CDIAS_BusAddress
                                                            , ud_length   := p_paraAddDO^.ud_LengthRead
                                                            , p_data 	    := p_paraAddDO^.p_ud_ReadData
                                                            , ud_Priority := p_paraAddDO^.ud_Priority
                                                            , p_DataAddr  := p_paraAddDO^.p_ud_DataAddr_read
                                                            );
            p_paraAddDO^.p_ud_DoHandle^ := ( #s_DummyHeader )$UDINT;
          end_if;          
            
        end_if;
            
    VARAN_CMD_CONTROL_WRITE,
    VARAN_CMD_MEMORY_WRITE: // Write DO ********************************************************************************************        
    
      if ( p_paraAddDO^.ud_DolType = VARAN_DOL_ISO ) then // ISO Write -----------------------------------------------------------

          //check if we have a single
          if ( p_paraAddDO^.pp_Enable) then              
            pResult^.aData[0]$DINT := to_DataMover.AddWrISOEnable(ud_add        := p_paraAddDO^.ud_OffsetWrite + CDIAS_BusAddress
                                                                  , ud_length	  := p_paraAddDO^.ud_LengthWrite
                                                                  , p_data		  := p_paraAddDO^.p_ud_WriteData
                                                                  , p_enable		:= p_paraAddDO^.pp_Enable$^USINT
                                                                  , ud_Priority := p_paraAddDO^.ud_Priority
                                                                  , p_DataAddr  := p_paraAddDO^.p_ud_DataAddr_write
                                                                , p_UserDOHandle:= p_paraAddDO^.p_UserDOHandle
                                                                  );
          else

            pResult^.aData[0]$DINT := To_DataMover.AddWrISO(ud_add 	    := p_paraAddDO^.ud_OffsetWrite + CDIAS_BusAddress
                                                            , ud_length   := p_paraAddDO^.ud_LengthWrite
                                                            , p_data 	    := p_paraAddDO^.p_ud_WriteData
                                                            , ud_Priority := p_paraAddDO^.ud_Priority
                                                            , p_DataAddr  := p_paraAddDO^.p_ud_DataAddr_write
                                                            );

            p_paraAddDO^.p_ud_DoHandle^ := ( #s_DummyHeader )$UDINT;
          end_if;
          

        else  // ASY Write --------------------------------------------------------------------------------------------------------
        
          //check if we have a single
          if ( p_paraAddDO^.pp_Enable) then              
            pResult^.aData[0]$DINT := to_DataMover.AddWrASYEnable(ud_add        := p_paraAddDO^.ud_OffsetWrite + CDIAS_BusAddress
                                                                  , ud_length	  := p_paraAddDO^.ud_LengthWrite
                                                                  , p_data		  := p_paraAddDO^.p_ud_WriteData
                                                                  , p_enable		:= p_paraAddDO^.pp_Enable$^USINT
                                                                  , ud_Priority := p_paraAddDO^.ud_Priority
                                                                  , p_DataAddr  := p_paraAddDO^.p_ud_DataAddr_write
                                                                , p_UserDOHandle:= p_paraAddDO^.p_UserDOHandle
                                                                  );
          else
            pResult^.aData[0]$DINT := To_DataMover.AddWrASY(ud_add 	    := p_paraAddDO^.ud_OffsetWrite + CDIAS_BusAddress
                                                            , ud_length   := p_paraAddDO^.ud_LengthWrite
                                                            , p_data 	    := p_paraAddDO^.p_ud_WriteData
                                                            , ud_Priority := p_paraAddDO^.ud_Priority            
                                                            , p_DataAddr  := p_paraAddDO^.p_ud_DataAddr_write
                                                            );
                                                          
            p_paraAddDO^.p_ud_DoHandle^ := ( #s_DummyHeader )$UDINT;
          end_if;
          
            
        end_if;
    
    VARAN_CMD_CONTROL_READ_WRITE,
    VARAN_CMD_MEMORY_READ_WRITE:  // Read Write DO ********************************************************************************************    
        if ( p_paraAddDO^.ud_DolType = VARAN_DOL_ISO ) then // ISO Read Write -----------------------------------------------------------------

          pResult^.aData[0]$DINT := To_DataMover.AddRdISO(ud_add        := p_paraAddDO^.ud_OffsetRead + CDIAS_BusAddress
                                                          , ud_length   := p_paraAddDO^.ud_LengthRead
                                                          , p_data 	    := p_paraAddDO^.p_ud_ReadData
                                                          , ud_Priority := p_paraAddDO^.ud_Priority
                                                          , p_DataAddr  := p_paraAddDO^.p_ud_DataAddr_read
                                                          );

          if ( pResult^.aData[0]$DINT = VARANMANAGER_OK ) then
            pResult^.aData[0]$DINT := To_DataMover.AddWrISO(ud_add 	    := p_paraAddDO^.ud_OffsetWrite + CDIAS_BusAddress
                                                            , ud_length   := p_paraAddDO^.ud_LengthWrite
                                                            , p_data 	    := p_paraAddDO^.p_ud_WriteData
                                                            , ud_Priority := p_paraAddDO^.ud_Priority
                                                            , p_DataAddr  := p_paraAddDO^.p_ud_DataAddr_write
                                                            );
          end_if;
          p_paraAddDO^.p_ud_DoHandle^ := ( #s_DummyHeader )$UDINT;

        else  // ASY Read Write ---------------------------------------------------------------------------------------------------------------
          pResult^.aData[0]$DINT := To_DataMover.AddRdASY	( ud_add 	    := p_paraAddDO^.ud_OffsetRead + CDIAS_BusAddress
                                                          , ud_length   := p_paraAddDO^.ud_LengthRead
                                                          , p_data 	    := p_paraAddDO^.p_ud_ReadData
                                                          , ud_Priority := p_paraAddDO^.ud_Priority
                                                          , p_DataAddr  := p_paraAddDO^.p_ud_DataAddr_read
                                                          );

          if ( pResult^.aData[0]$DINT = VARANMANAGER_OK ) then
            pResult^.aData[0]$DINT := To_DataMover.AddWrASY	( ud_add 	    := p_paraAddDO^.ud_OffsetWrite + CDIAS_BusAddress
                                                            , ud_length   := p_paraAddDO^.ud_LengthWrite
                                                            , p_data 	    := p_paraAddDO^.p_ud_WriteData
                                                            , ud_Priority := p_paraAddDO^.ud_Priority
                                                            , p_DataAddr  := p_paraAddDO^.p_ud_DataAddr_write
                                                            );
          end_if;
          p_paraAddDO^.p_ud_DoHandle^ := ( #s_DummyHeader )$UDINT;
        end_if;
          
  end_case;
  
  sd_retval := pResult^.aData[0]$DINT;
  
END_FUNCTION
#pragma warning(default:73 )


FUNCTION VIRTUAL GLOBAL CDias2DataMover::AddMove
	VAR_INPUT
		RTCY 	: DINT;
		thisp 	: ^void;
		callOptions 	: USINT;
		SourceAddr 	: HDINT;
		DestAddr 	: HDINT;
		MoveLen 	: UDINT;
		pEnable 	: ^USINT;
		Settings 	: HDINT;
	END_VAR
	VAR_OUTPUT
		HandleMove 	: DINT;
	END_VAR

  if MoverActive = 1 then
    if ((SourceAddr = 0) & (DestAddr = 0)) then
      // not possible
      HandleMove := -1;
    else
      if (Settings AND 2#01) = 2#01 then
        // add CDIAS offset to source address
        SourceAddr += CDIAS_BusAddress;
      end_if;
      if (Settings AND 2#10) = 2#10 then
        // add CDIAS offset to destination address
        DestAddr += CDIAS_BusAddress;
      end_if;

      // move it
      if (RTCY AND 1) = 1 then
        HandleMove := To_DataMover.AddMoveISO( SourceAddr
                                             , DestAddr
                                             , MoveLen
                                             , pEnable
                                             , Settings AND VM_PRIORITY_FILTER
                                             );
      else
        HandleMove := To_DataMover.AddMoveASY( SourceAddr
                                             , DestAddr
                                             , MoveLen
                                             , pEnable
                                             , Settings AND VM_PRIORITY_FILTER
                                             );
      end_if;
    end_if;
  else
    // give to base
    HandleMove := CIV_Base::AddMove(RTCY, thisp, callOptions); // Addr and Enable are only for mover
  end_if;

END_FUNCTION
