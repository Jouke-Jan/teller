//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
typedef UDINT _CNC_DYN_SWLIMITS;   //! <Type Comment="Dynamic software end positions" Name="_CNC_DYN_SWLIMITS"/>
    #define _DynSWLimitMin 0
    #define _DynSWLimitMax 1

typedef struct   //! <Type Comment="Control-Bits" Name="_LMCAXIS_CONTROLBITS"/>
  {
    long SetPowerOn : 1;  //! <Type Comment="Set if the clients &quot;LMCController&quot; and &quot;ActPosition&quot; are not connected or &#13;&#10;the axis is active" Name="_LMCAXIS_CONTROLBITS.SetPowerOn"/>
    long SetFollowMode : 1;  //! <Type Comment="Set if the axis is in operationmode: &quot;FOLLOW_LMCAXIS&quot;" Name="_LMCAXIS_CONTROLBITS.SetFollowMode"/>
  }_LMCAXIS_CONTROLBITS;

typedef struct   //! <Type Comment="Error-Bits" Name="_LMCAXIS_ERROR"/>
  {
    long HwError : 1;  //! <Type Comment="Set if a general Hardware-Error occured" Name="_LMCAXIS_ERROR.HwError"/>
    long SwMinError : 1;  //! <Type Comment="Set if the Software-Endswitch Minimum is active" Name="_LMCAXIS_ERROR.SwMinError"/>
    long SwMaxError : 1;  //! <Type Comment="Set if the Software-Endswitch Maximum is active" Name="_LMCAXIS_ERROR.SwMaxError"/>
    long HwMinError : 1;  //! <Type Comment="Set if the Hardware-Endswitch Minimum is active" Name="_LMCAXIS_ERROR.HwMinError"/>
    long HwMaxError : 1;  //! <Type Comment="Set if the Hardware-Endswitch Maximum is active" Name="_LMCAXIS_ERROR.HwMaxError"/>
    long ReferenceError : 1;  //! <Type Comment="Set if an error occured during the reference-run" Name="_LMCAXIS_ERROR.ReferenceError"/>
    long ContouringError : 1;  //! <Type Comment="Set if a tracking-error occured" Name="_LMCAXIS_ERROR.ContouringError"/>
    long ActPosError : 1;  //! <Type Comment="Set if the Hardware-Position is invalid" Name="_LMCAXIS_ERROR.ActPosError"/>
    long AbsOffsetError : 1;  //! <Type Comment="Set if an Offset-Error occured" Name="_LMCAXIS_ERROR.AbsOffsetError"/>
    long OverFlowError : 1;  //! <Type Comment="Set if a Position-Overflow occured" Name="_LMCAXIS_ERROR.OverFlowError"/>
    long EmergencyError : 1;  //! <Type Comment="Set if the _LMCSafety.Emergency is active" Name="_LMCAXIS_ERROR.EmergencyError"/>
    long ResolutionError : 1;  //! <Type Comment="Set if the Resolution causes an overflow error&#13;&#10;" Name="_LMCAXIS_ERROR.ResolutionError"/>
    long dummy0 : 3;
    long GlobErr : 1;  //! <Type Comment="Set if a global error is active" Name="_LMCAXIS_ERROR.GlobErr"/>
  }_LMCAXIS_ERROR;

typedef struct   //! <Type Comment="Status-Bits of the axis" Name="_LMCAXIS_STATUS"/>
  {
    long PowerOn : 1;  //! <Type Comment="Set if axis is activated" Name="_LMCAXIS_STATUS.PowerOn"/>
    long IsReferenced : 1;  //! <Type Comment="Set if axis is referenced" Name="_LMCAXIS_STATUS.IsReferenced"/>
    long InPosition : 1;  //! <Type Comment="Set if axis is in correct position" Name="_LMCAXIS_STATUS.InPosition"/>
    long FiltRdy : 1;  //! <Type Comment="Set if axis is in correct position an the jerkfilter is ready" Name="_LMCAXIS_STATUS.FiltRdy"/>
    long Decell : 1;  //! <Type Comment="Set if axis is braking" Name="_LMCAXIS_STATUS.Decell"/>
    long PosLimActive : 1;  //! <Type Comment="Set if axis has reached one of its endpositions" Name="_LMCAXIS_STATUS.PosLimActive"/>
    long SetFlg : 1;  //! <Type Comment="Set by calling one of the functions: SetPosition or ReferenceAxis&#13;&#10;Reset if the axis is activated" Name="_LMCAXIS_STATUS.SetFlg"/>
    long EnLesFlg : 1;  //! <Type Comment="Set if the axis moves endless / infinitely" Name="_LMCAXIS_STATUS.EnLesFlg"/>
    long DirFlg : 1;  //! <Type Comment="Set if the axis moves in negative direction - speed is negative" Name="_LMCAXIS_STATUS.DirFlg"/>
    long EmergStop : 1;  //! <Type Comment="Set if the axis stops because an error occured or the axis is deactivated" Name="_LMCAXIS_STATUS.EmergStop"/>
    long Overflow : 1;  //! <Type Comment="Set if a position-overflow occured" Name="_LMCAXIS_STATUS.Overflow"/>
    long MasterLock : 1;  //! <Type Comment="Set if the slave-axis is coupled onto a master-axis" Name="_LMCAXIS_STATUS.MasterLock"/>
    long DirLock : 1;  //! <Type Comment="the direction is locked&#13;&#10;(because of HWMin, HWMax&#13;&#10; or by PowerOnMode)" Name="_LMCAXIS_STATUS.DirLock"/>
    long DynSwLimit : 1;
    long ActDirFlg : 1;  //! <Type Comment="Set if the speed of the axis is negative" Name="_LMCAXIS_STATUS.ActDirFlg"/>
    long HandFlg : 1;  //! <Type Comment="Set if one of the functions: PowerOff or MoveHand is called" Name="_LMCAXIS_STATUS.HandFlg"/>
    long ModuloFlg : 1;  //! <Type Comment="Set if the axis is defined as a modulo-axis" Name="_LMCAXIS_STATUS.ModuloFlg"/>
    long NCMotion : 1;  //! <Type Comment="Set if the axis is in NC postion mode: &quot;_NCPositioning&quot;" Name="_LMCAXIS_STATUS.NCMotion"/>
    long NoActPosMeth : 1;  //! <Type Comment="Set if axis is in &quot;SimulateMode&quot; of the client &quot;ActPosition&quot; is not connected" Name="_LMCAXIS_STATUS.NoActPosMeth"/>
    long NoControlMeth : 1;  //! <Type Comment="Set if axis is in &quot;SimulateMode&quot; of the client &quot;LMCController&quot; is not connected" Name="_LMCAXIS_STATUS.NoControlMeth"/>
    long NoRefMeth : 1;  //! <Type Comment="Set if the client &quot;LMCReference&quot; is not connected or&#13;&#10;the function &quot;CheckConnection&quot; returns &quot;FALSE&quot; or&#13;&#10;the client &quot;ActPosition&quot; is not connected" Name="_LMCAXIS_STATUS.NoRefMeth"/>
    long NoActPosChk : 1;  //! <Type Comment="Set if the client LMCSafety is connected and the function &quot;ChkHWReadyConnect&quot; returns &quot;FALSE&quot; or&#13;&#10;the client LMCSafety is not connected or&#13;&#10;the SimulateMode is active" Name="_LMCAXIS_STATUS.NoActPosChk"/>
    long NoPreRtWork : 1;  //! <Type Comment="Set if the client &quot;LMCPreRtWorkTrigger&quot; is not connected" Name="_LMCAXIS_STATUS.NoPreRtWork"/>
    long NoPostRtWork : 1;  //! <Type Comment="Set if the client &quot;LMCPostRtWorkTrigger&quot; is not connected" Name="_LMCAXIS_STATUS.NoPostRtWork"/>
  }_LMCAXIS_STATUS;

typedef UDINT _LMCCONTROLLERTYPE; 
    #define _LMCNOCONTROLLER 0
    #define _LMCUSERCONTROLLER 1
    #define _LMCDUMMYCONTROLLER 2
    #define _LMCHYDROCONTROLLER 3
    #define _LMCKV_CONTROLLER 4
    #define _LMCNCCONTROLLER 5
    #define _LMCPOSCONTROLLER 6
    #define _LMCDRIVEPOSONTROL 7

#pragma pack(push, 1)
typedef struct Aansturing 
  {
    DINT StotAan [10+1-0];
    DINT StotUit [10+1-0];
    DINT ScorAan [10+1-0];
    DINT ScorUit [10+1-0];
    DINT ScorBepaalAan [10+1-0];
    DINT ScorBepaalUit [10+1-0];
    DINT SExtraBox;
    DINT SPosbuffer [10+1-0];
    DINT Error [10+1-0];
    DINT i;
    DINT CaseAansturing [10+1-0];
    DINT CaseAansturing2 [10+1-0];
    DINT Offset [10+1-0];
    DINT CaseRing [10+1-0];
    DINT Spos [10+1-0];
    DINT wrpoint [10+1-0];
    DINT rdpoint [10+1-0];
    DINT Senpos [10+1-0];
    DINT Dooslengte [10+1-0];
    DINT Din [10+1-0];
    DINT Scoruiteerst [10+1-0];
    DINT Testaaneerst [10+1-0];
    DINT ii;
    DINT UpdateConv [10+1-0];
    DINT conveyor [10+1-0];
    DINT ConveyorLoper [10+1-0];
    DINT ConveyorCase [10+1-0];
    DINT ConveyorPosdoos [10+1-0];
    DINT ConveyorPosDoosNew [10+1-0];
    DINT iii;
    DINT iiii;
    DINT Out [10+1-0];
    DINT PakketWijzer [10+1-0];
  } Aansturing;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct AxisRef 
  {
    DINT Speed;  //! <Type Comment="Reference speed" Name="AxisRef.Speed"/>
    DINT Accel;  //! <Type Comment="Reference acceleration" Name="AxisRef.Accel"/>
    DINT Stat;  //! <Type Comment="Reference status ( error or ready )" Name="AxisRef.Stat"/>
    DINT LatchPosRef;  //! <Type Comment="External position [incr] used in mode &quot;RefLatchPos&quot;" Name="AxisRef.LatchPosRef"/>
  } AxisRef;
#pragma pack(pop)

typedef UDINT BackFolder; 
    #define Opstarten 13
    #define IdleFase 14
    #define EnableFase 15
    #define HomeFase 16
    #define LinupFase 17
    #define SyncFase 18
    #define NC_Production0 19
    #define NC_Production1 20
    #define NC_Production2 21
    #define NC_Production3 22
    #define NC_Production35 23
    #define NC_Production4 24
    #define NC_Production5 25
    #define NC_Production6 26

typedef UDINT CNCCommandStatus; 
    #define PassiveCNC 0
    #define IdleCNC 1
    #define MoveCNC 2
    #define StopedCNC 3
    #define LockedCNC 4
    #define RefGoCNC 5
    #define RefRunCNC 6
    #define RefStopCNC 7
    #define TunePosCNC 8
    #define TuneNegCNC 9
    #define ErrorCNC 10

typedef struct 
  {
    long HwError : 1;  //! <Type Comment="Hardware error Flag" Name="CncFlags.HwError"/>
    long SwMin : 1;  //! <Type Comment="Software endswitch minimum active" Name="CncFlags.SwMin"/>
    long SwMax : 1;  //! <Type Comment="Software endswitch maximum active" Name="CncFlags.SwMax"/>
    long v_error : 1;  //! <Type Comment="velocity setting error" Name="CncFlags.v_error"/>
    long a_error : 1;  //! <Type Comment="Acceleration / deceleration setting error" Name="CncFlags.a_error"/>
    long ContrOff : 1;  //! <Type Comment="position controller off" Name="CncFlags.ContrOff"/>
    long NoRef : 1;  //! <Type Comment="no position reference" Name="CncFlags.NoRef"/>
    long DragLim : 1;  //! <Type Comment="contouring error" Name="CncFlags.DragLim"/>
    long ComandErr : 1;  //! <Type Comment="Command is not exepted" Name="CncFlags.ComandErr"/>
    long ActPosError : 1;  //! <Type Comment="invalid position of the hardware" Name="CncFlags.ActPosError"/>
    long IsNotControlling : 1;  //! <Type Comment="wake and shake is active" Name="CncFlags.IsNotControlling"/>
    long Follow : 1;
    long OverFlowError : 1;
    long dummy0 : 2;
    long GlobErr : 1;  //! <Type Comment="Any other errors is active" Name="CncFlags.GlobErr"/>
  }CncFlags;

#pragma pack(push, 1)
typedef struct CNCInternalStruct 
  {
    DINT *ptrExt;
    DINT *ptrInt;
    DINT *ptrBinOffset;
    DINT NowOverflow;
    DINT OverflowDelta;
    DINT SetPos;
  } CNCInternalStruct;
#pragma pack(pop)

typedef struct 
  {
    long InPosition : 1;  //! <Type Comment="Axis is in position" Name="CntrFlgs.InPosition"/>
    long FiltRdy : 1;  //! <Type Comment="Axis is in position and jerk filter is ready" Name="CntrFlgs.FiltRdy"/>
    long PosLimActive : 1;  //! <Type Comment="Position limit is active, set position is over the SW end position" Name="CntrFlgs.PosLimActive"/>
    long Decell : 1;  //! <Type Comment="Deceleration is active" Name="CntrFlgs.Decell"/>
    long bDynSWLimit : 1;  //! <Type Comment="Set if axis has reached one of its dynamic SW endpositions" Name="CntrFlgs.bDynSWLimit"/>
    long dummy0 : 1;
    long SetFlg : 1;  //! <Type Comment="Set by calling the SetPositon, CNCRefRun and NCRefRun functions Reset after activating the controller." Name="CntrFlgs.SetFlg"/>
    long dummy1 : 2;
    long EnLesFlg : 1;  //! <Type Comment="Endless positioning is active" Name="CntrFlgs.EnLesFlg"/>
    long DirFlg : 1;  //! <Type Comment="Commanded axis direction (0 -&gt; positive, 1 -&gt; negative)" Name="CntrFlgs.DirFlg"/>
    long ActDirFlg : 1;  //! <Type Comment="Actual axis direction (0 -&gt; positive, 1 -&gt; negative)" Name="CntrFlgs.ActDirFlg"/>
    long EmergStop : 1;  //! <Type Comment="Emergency stop is active" Name="CntrFlgs.EmergStop"/>
    long AutoRun : 1;  //! <Type Comment="Controller output autotuning is running" Name="CntrFlgs.AutoRun"/>
    long AutoStop : 1;  //! <Type Comment="Controller output autotuning is ready" Name="CntrFlgs.AutoStop"/>
    long Test : 1;  //! <Type Comment="Is only queried when ControllerOn is set to 0." Name="CntrFlgs.Test"/>
    long NoActpos : 1;  //! <Type Comment="The Client &quot;iActPosition&quot; is not connected" Name="CntrFlgs.NoActpos"/>
    long Overflow : 1;  //! <Type Comment="The axis has an internal position overflow." Name="CntrFlgs.Overflow"/>
    long NoControl : 1;  //! <Type Comment="The axis is not connected to a controller and the CNC therefore operates as a profile generator only." Name="CntrFlgs.NoControl"/>
    long ModuloFlg : 1;  //! <Type Comment="The axis is defined as a modulo axis." Name="CntrFlgs.ModuloFlg"/>
    long NoActPosMeth : 1;  //! <Type Comment="The &quot;iActPosition&quot; client is not connected to a server (axis operates without posi-tion feedback)." Name="CntrFlgs.NoActPosMeth"/>
    long NoRefMeth : 1;  //! <Type Comment="The &quot;iRefChannal&quot; is not connected" Name="CntrFlgs.NoRefMeth"/>
    long NoControlMeth : 1;  //! <Type Comment="The &quot;oSignalchannal&quot; client is not connected" Name="CntrFlgs.NoControlMeth"/>
    long NoSpecial : 1;  //! <Type Comment="The &quot;oPrecyclictrigger&quot; client is not connected" Name="CntrFlgs.NoSpecial"/>
    long NCMotion : 1;  //! <Type Comment="The CNC class is operated in NC mode" Name="CntrFlgs.NCMotion"/>
    long NoActPosChk : 1;
  }CntrFlgs;

#pragma pack(push, 1)
typedef struct Counter1 
  {
    DINT i;
    DINT CounterPos;
    DINT CounterBoxlength;
    DINT EncoderOLD;
    DINT Dist2Boxen;
    DINT SpeedCalc;
    DINT TelCalc;
    UDINT Timer1;
    DINT NogTeProduceren;
    DINT NogTeProdBuffer [10+1-0];
    DINT wijzer;
    UDINT Timer;
    DINT CaseNogTeProd;
  } Counter1;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct CurveTable   //! <Type Comment="Table curve points (Masterpos, Slavepos)" Name="CurveTable"/>
  {
    DINT MasterPos;  //! <Type Comment="Master axis position [Application units]" Name="CurveTable.MasterPos"/>
    DINT SlavePos;  //! <Type Comment="Slave axis position [Application units]" Name="CurveTable.SlavePos"/>
  } CurveTable;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct Curve   //! <Type Comment="Motion type curve data" Name="Curve"/>
  {
    DINT modulo;  //! <Type Comment="Lead axis modulo value" Name="Curve.modulo"/>
    DINT tabellenth;  //! <Type Comment="number of curve points" Name="Curve.tabellenth"/>
    DINT mul;  //! <Type Comment="Part of the transmission ratio" Name="Curve.mul"/>
    DINT div;  //! <Type Comment="Part of the transmission ratio" Name="Curve.div"/>
    DINT offset;  //! <Type Comment="Position offset" Name="Curve.offset"/>
    CurveTable table [256+1-0];  //! <Type Comment="Table curve points (Masterpos, Slavepos)" Name="Curve.table"/>
  } Curve;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct EEData 
  {
    DINT dOffEE;
    DINT dMulEE;
    DINT dDivEE;
  } EEData;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct Encoder1 
  {
    DINT EncoderDelta;
    DINT EncoderOld;
    DINT SpeedDelta;
    DINT Buffer [100+1-0];
    DINT SpeedDeltaFilter;
    DINT ii;
    DINT FilterTotaal;
    DINT Filter;
    DINT Multi;
    DINT Divider;
    DINT i;
    DINT EncPerCycle;
    DINT Encx10000;
    DINT EncResolutie;
    DINT SpeedMMper50Ms;
    DINT Meting1;
    DINT Meting2;
    DINT enccalc1;
    DINT enccalc2;
    DINT enccalc3;
    DINT encdiv;
    DINT encmul;
  } Encoder1;
#pragma pack(pop)

typedef struct 
  {
    long Valid : 1;  //! <Type Comment="must be 1 to Start FileEx work" Name="FeSetup.Valid"/>
    long FileorRam : 1;  //! <Type Comment="0= work in File 1= Work File" Name="FeSetup.FileorRam"/>
    long EnableChecksum : 1;  //! <Type Comment="0=no Checksum; 1=Calculate Checksum, increased write access on the CF card" Name="FeSetup.EnableChecksum"/>
    long Encrypt : 1;  //! <Type Comment="0=no encryption; 1=encrypt file, increased write access on the CF card" Name="FeSetup.Encrypt"/>
  }FeSetup;

typedef struct   //! <Type Comment="Status Flag für IO Daten" Name="IO_FLAG"/>
  {
    short WrongHW : 1;  //! <Type Comment="Falsche Hardware verbunden" Name="IO_FLAG.WrongHW"/>
    short NoHW : 1;  //! <Type Comment="Keine Hardware verbunden" Name="IO_FLAG.NoHW"/>
    short NoCalibration : 1;  //! <Type Comment="Keine Kalibrierungsdaten im Modul-EEPROM" Name="IO_FLAG.NoCalibration"/>
    short ParaChkWrong : 1;  //! <Type Comment="Die Parameter-Checksumme ist falsch" Name="IO_FLAG.ParaChkWrong"/>
    short PhysicHiLimit : 1;  //! <Type Comment="IO ist am oberen physikalischen Limit" Name="IO_FLAG.PhysicHiLimit"/>
    short PhysicLoLimit : 1;  //! <Type Comment="IO ist am unteren physikalischen Limit" Name="IO_FLAG.PhysicLoLimit"/>
    short Invert : 1;  //! <Type Comment="Daten sind invertiert" Name="IO_FLAG.Invert"/>
    short dummy0 : 6;
    short OnDummyMode : 1;  //! <Type Comment="1 = Objekt ist im Dummymodus (nicht refreshed)" Name="IO_FLAG.OnDummyMode"/>
    short NotConnected : 1;  //! <Type Comment="1 = Objekt ist nicht verbunden" Name="IO_FLAG.NotConnected"/>
    short PhysicAccessOff : 1;  //! <Type Comment="1 = kein physikalischer Zugriff erlaubt" Name="IO_FLAG.PhysicAccessOff"/>
  }IO_FLAG;

#pragma pack(push, 1)
typedef struct IO_State 
  {
    IO_FLAG uiIO_Flags;
    UINT uiChNo;
  } IO_State;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct Jam 
  {
    DINT Jamdetect [3+1-0];
    DINT JamPos [3+1-0];
    DINT JamDetection [3+1-0];
    DINT SExtraBox;
    DINT i;
    DINT CaseJam [3+1-0];
    DINT JamBoxlength [3+1-0];
    DINT Boxlength [3+1-0];
    DINT OldBoxlength [3+1-0];
  } Jam;
#pragma pack(pop)

typedef struct MasterStruct   //! <Type Comment="Pointers to the master axis data" Name="MasterStruct"/>
  {
    DINT *pos;  //! <Type Comment="Pointer to the master axis position" Name="MasterStruct.pos"/>
    DINT *Speed;  //! <Type Comment="Pointer to the master axis speed" Name="MasterStruct.Speed"/>
    DINT *ModuloMaster;  //! <Type Comment="Pointer to ModuloInt of master axis" Name="MasterStruct.ModuloMaster"/>
  } MasterStruct;

typedef HwBase *pHwBase;

typedef HwBaseCDIAS *pHwBaseCDIAS;

typedef struct   //! <Type Comment="Motion Reference type" Name="RefMode"/>
  {
    long No_Z_Input : 1;  //! <Type Comment="0 --&gt; Referencing with referencing impuls&#13;&#10;1 --&gt; Referencing without referencing impuls&#13;&#10;" Name="RefMode.No_Z_Input"/>
    long No_ES : 1;  //! <Type Comment="0 --&gt; Referencing with endswitches&#13;&#10;1 --&gt; Referencing without endswitches" Name="RefMode.No_ES"/>
    long Ref_direction : 1;  //! <Type Comment="1 --&gt; Referencing on positive direction&#13;&#10;0 --&gt; Referencing on negative direction" Name="RefMode.Ref_direction"/>
    long No_turnOnRefSw : 1;  //! <Type Comment="0 --&gt; Reverse direction at the reference switch&#13;&#10;1 --&gt; Do not reverse direction at the reference switch" Name="RefMode.No_turnOnRefSw"/>
    long No_turnOnESSw : 1;  //! <Type Comment="0 --&gt; Reverse direction at the end switch&#13;&#10;1 --&gt; Do not reverse direction at the end switch" Name="RefMode.No_turnOnESSw"/>
    long ESequalRef : 1;  //! <Type Comment="1 --&gt; End switch as Reference switch is used&#13;&#10;" Name="RefMode.ESequalRef"/>
    long StandardRef : 1;  //! <Type Comment="0 --&gt; default reference mode&#13;&#10;1 --&gt; userdefined reference mode" Name="RefMode.StandardRef"/>
    long NoSet : 1;  //! <Type Comment="0 --&gt; The transmitted position is the reference position&#13;&#10;1 --&gt; The actual position is the reference position" Name="RefMode.NoSet"/>
    long RefLatchPos : 1;  //! <Type Comment="1 --&gt; Read reference position from client cLatchPos. If value changes, do a MoveAbsolute(cLatchPos) and set cLatchPos as current position." Name="RefMode.RefLatchPos"/>
  }RefMode;

typedef DINT ringbuffer [16+1-0];

typedef UDINT SafetyConfigStateType; 
    #define _ModuleNotFound 0
    #define _SafetyClassOK 1
    #define _ReinitConfig 2
    #define _UnsafeVarNotFound 3
    #define _ModFromCfgNotFound 4
    #define _MemAllocFailed 5
    #define _ReadFWVerFailed 6
    #define _UnknownCfgError 7
    #define _WaitForSynchronicity 8
    #define _AsyncComError 9
    #define _DOsIncreasedRestartApp 10

#pragma pack(push, 1)
typedef struct SafetyDiagInfo 
  {
    USINT uControllerID;  //! <Type Comment="ID of µController (0 = µC1, else µC2)" Name="SafetyDiagInfo.uControllerID"/>
    USINT ActErrorCode;  //! <Type Comment="actual error code" Name="SafetyDiagInfo.ActErrorCode"/>
    USINT FirstErrorCode;  //! <Type Comment="code of first error that lead to an error state" Name="SafetyDiagInfo.FirstErrorCode"/>
    UDINT ReasonCode0;  //! <Type Comment="reason for error (meaning depends on actual error code)" Name="SafetyDiagInfo.ReasonCode0"/>
    UDINT ReasonCode1;  //! <Type Comment="reason for error (meaning depends on actual error code)" Name="SafetyDiagInfo.ReasonCode1"/>
  } SafetyDiagInfo;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct SafetyDiagState 
  {
    USINT RunState;  //! <Type Comment=" 1..POST&#13;&#10; 2..SERVICE&#13;&#10; 4..ERROR&#13;&#10; 8..IDLE&#13;&#10;16..CHK_CFG&#13;&#10;32..OP_TEMP&#13;&#10;64..OP" Name="SafetyDiagState.RunState"/>
    USINT ConfigState;  //! <Type Comment=" 1..INVALID&#13;&#10; 2..NOT_CONFIGURED&#13;&#10; 4..CONFIGURED_NOT_DEPLOYED_NOT_VERIFIED&#13;&#10; 8..CONFIGURED_AND_VERIFIED&#13;&#10;16..CONFIGURED_DEPLOYED_NOT_VERIFIED&#13;&#10;36..CONFIGURED_NOT_DEPLOYED_NOT_VERIFIED_DEV&#13;&#10;48..CONFIGURED_DEPLOYED_NOT_VERIFIED_DEV" Name="SafetyDiagState.ConfigState"/>
    USINT LoginLevel;  //! <Type Comment="0..not logged in&#13;&#10;1..debug&#13;&#10;2..configuration&#13;&#10;3..general" Name="SafetyDiagState.LoginLevel"/>
    UINT ErrorCounterIOState;  //! <Type Comment="Is increased on change of the error state of any input or output" Name="SafetyDiagState.ErrorCounterIOState"/>
  } SafetyDiagState;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct SensorLR 
  {
    DINT MinimaleSpot;
    DINT MinimaleCounter [3+1-0];
    DINT MinimaalSSW [3+1-0];
    DINT DiHW [3+1-0];
    DINT Din [3+1-0];
    DINT i;
  } SensorLR;
#pragma pack(pop)

typedef UDINT t_e_VaranErrors; 
    #define _ClassOk 0
    #define _NotInitialized 1
    #define _CallBackError 2
    #define _RequiredError 3
    #define _RootError 4
    #define _NoHardware 5
    #define _WrongHardware 6
    #define _CreateDOFailed 7
    #define _DirectAccessFailed 8
    #define _PllError 9
    #define _TimeoutInInit 10
    #define _HardwareRequiredIRQ 11
    #define _HardwareNotRequiredIRQ 12
    #define _HardwareFatalErrorIRQ 13
    #define _ManagerError 14
    #define _DisableError 15
    #define _EnableError 16
    #define _MultipleError 17
    #define _SPIError 18
    #define _ErrorBootImageFPGA 19
    #define _NoCDIASInterface 20
    #define _EEPromError 21
    #define _NoVaranInterface 22
    #define _MemoryFault 23
    #define _TimesliceError 24
    #define _TimesliceErrorIRQ 25
    #define _WatchdogError 26
    #define _VaranTimeError 27
    #define _DiasTimeError 28
    #define _DORamFull 29
    #define _PortNoLink 30
    #define _VaranDriverNotExists 31
    #define _WrongDOLType 32
    #define _WrongRunStatus 33
    #define _DOHandleInvalid 34
    #define _DOCmdInvalid 35
    #define _ManagerNotExists 36
    #define _DOLAddressInvalid 37
    #define _UnknownCommand 38
    #define _ComponentNotExists 39
    #define _ClientNotExists 40
    #define _CdiasEEPromNotExists 41
    #define _CdiasEEPromNoGrant 42
    #define _CdiasEEPromNack 43
    #define _PortNotExists 44
    #define _PortIsUplink 45
    #define _NoMutex 46
    #define _NoTask 47
    #define _IDNotFound 48
    #define _IDNotInitialized 49
    #define _InvalidDeviceAddress 50
    #define _CallbackNotHandled 51
    #define _NoMem 52
    #define _NoLegacyWd 53
    #define _AdminDOLExecutionError 54
    #define _DADOLExecutionError 55
    #define _SPIFlashNoAccess 56
    #define _ClientNotready 57
    #define _TimeoutVaran 58
    #define _UnknownFault 59
    #define _DiasError 60
    #define _DeviceError 61
    #define _VaranTimeWarning 62
    #define _OnlyASYSupported 63
    #define _InvalidSerialNo 64
    #define _CDIASRequiredError 65
    #define _DIASRequiredError 66
    #define _NoCalibDataFound 67
    #define _ModuleFoundButManagerIsOff 68
    #define _InvalidConfguration 69
    #define _ClientDisabled 70
    #define _ClientCantEnable 71
    #define _CdiasAddressInvalid 72
    #define _SPIFlashInvalid 73
    #define _SPIDOLIDInvalid 74
    #define _SPIDOLInvalid 75
    #define _SPIRequiredListError 76
    #define _SPIChksumError 77
    #define _ParameterInvalid 78
    #define _DOTypeNotSupported 79
    #define _DMAError 80
    #define _PropertyIDInvalid 81
    #define _PropertyValueInvalid 82
    #define _DONumberOverflow 83
    #define _APIUsageNotAllowed 84
    #define _NodeTypeWrong 85
    #define _DataLengthInvalid 86
    #define _DOTypeInvalid 87
    #define _OperationNotAllowed 88
    #define _NodeNumberOverflow 89
    #define _NoHandleFound 90

#pragma pack(push, 1)
typedef struct t_s_ModulInfo 
  {
    HINT Kennung;
    void *p_This;
  } t_s_ModulInfo;
#pragma pack(pop)

typedef UDINT tDoosnaam; 
    #define No_box 0
    #define Langsnaad 1
    #define Driepunt 2
    #define Driepunt_Vakverdeling 3
    #define Vierpunt_Infold 4
    #define Vierpunt_Outfold 5
    #define Vierpunt_Deksel 6
    #define Vierpunt_Dubbele_Wand 7
    #define Zespunt_In_In 8
    #define Zespunt_In_Out 9
    #define Zespunt_In_In_Gespiegeld 10
    #define Driepunt_Gespiegeld 11
    #define Langsnaad2 12
    #define Driepunt2 13

#pragma pack(push, 1)
typedef struct tDoosParametersMinMax 
  {
    DINT Max_Invoer_Lengte;
    BOOL BoxMogelijk;
    DINT Max_Invoer_Breedte;
    DINT T_Max;
    DINT T_Min;
    DINT U_Max;
    DINT U_Min;
    DINT V_Max;
    DINT V_Min;
    DINT W_Max;
    DINT W_Min;
    DINT X_Max;
    DINT X_Min;
    DINT Y_Max;
    DINT Y_Min;
    DINT Z_Max;
    DINT Z_Min;
    DINT Offset_Max;
    DINT Offset_Min;
  } tDoosParametersMinMax;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct tDoosParameters 
  {
    DINT Doostype;
    DINT T;
    DINT U;
    DINT V;
    DINT W;
    DINT X;
    DINT Y;
    DINT Z;
    DINT Offset;
    tDoosParametersMinMax MinMax [14+1-1];
  } tDoosParameters;
#pragma pack(pop)

typedef CHAR TextString [50+1-0];

#pragma pack(push, 1)
typedef struct tHaak 
  {
    DINT CaseRing;
    DINT Senpos;
    DINT wrPoint;
    DINT rdPoint;
    DINT CaseAansturing;
    DINT Spos;
    DINT StartPos;
  } tHaak;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct tJam 
  {
    DINT Jamdetect;
    DINT Jampos;
    DINT Jamdetection;
    DINT SExtraBox;
    DINT CaseJam;
    DINT JamBoxlength;
    DINT Boxlength;
  } tJam;
#pragma pack(pop)

typedef UDINT tJamStatus; 
    #define Turned_Off 0
    #define Normal_Operation 1
    #define No_Box_Detected 2
    #define Holes_Detected 3
    #define TeachIn_Ok 4
    #define Jam_Detect 5
    #define Box_Oversized 6
    #define No_Sensor_Configurated 7

#pragma pack(push, 1)
typedef struct tJamDetect 
  {
    DINT NrOfJamSensors;
    DINT SectieNrInMachine;
    DINT MinSpot;
    DINT MinJamSpeed;
    DINT sExtraBox;
    DINT iEncMulti;
    DINT iEncDiv;
    DINT T_Doos;
    DINT OnOff [16+1-0];
    DINT SensorNrInMachine [16+1-0];
    DINT JamBoxlength [16+1-0];
    DINT TeachInLength [16+1-0];
    tJamStatus Status [16+1-0];
    DINT Sensor [16+1-0];
  } tJamDetect;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct tKop 
  {
    DINT Present [10+1-0];
    DINT Sensor [10+1-0];
    DINT SensorHW [10+1-0];
    DINT OffsetL [10+1-0];
    DINT OffsetR [10+1-0];
    DINT OffsetSTR [10+1-0];
    DINT TopkomInMs [10+1-0];
    DINT TafvalInMs [10+1-0];
    DINT Boxlengte [10+1-0];
    DINT Start [10+1-0];
    DINT Lengte [10+1-0];
    DINT Error [10+1-0];
    DINT MinSpeed [10+1-0];
    DINT Test [10+1-0];
    DINT Pakket1 [10+1-0];
    DINT Pakket2 [10+1-0];
    DINT Pakket1SET [10+1-0];
    DINT Pakket2SET [10+1-0];
    DINT OutputHW [10+1-0];
    DINT OnOff [10+1-0];
    DINT iType [10+1-0];
    DINT i2SensorCNT [10+1-0];
    DINT iBoxLengte_Max [10+1-0];
    DINT iBoxLengte_Min [10+1-0];
    DINT iStart_Max [10+1-0];
    DINT iStart_Min [10+1-0];
    DINT iLengte_Max [10+1-0];
    DINT iLengte_Min [10+1-0];
  } tKop;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct tLine 
  {
    DINT Master;
    DINT Slave;
  } tLine;
#pragma pack(pop)

typedef UDINT tModel; 
    #define m0000 0
    #define m1250 1
    #define m1450 2
    #define m1700 3
    #define m1900 4
    #define m2300 5
    #define m2800 6

#pragma pack(push, 1)
typedef struct tOspeed 
  {
    DINT EncIn;
    DINT EncOud;
    DINT EncDelta;
  } tOspeed;
#pragma pack(pop)

typedef UDINT TransTypes; 
    #define VOLT 0
    #define POTI 1
    #define THERMO_J 2
    #define POTI_10V_UNI 3
    #define POTI_10V_BI 4
    #define POTI_5V_UNI 5
    #define POTI_5V_BI 6

typedef UDINT tSectie; 
    #define PreFeeder 1
    #define TriFeeder 2
    #define Feeder 3
    #define MAS 4
    #define Prefold 5
    #define A_Sectie 6
    #define B_Sectie 7
    #define C_Sectie 8
    #define FinalFold 9
    #define F_Unit 10
    #define Trombone 11
    #define ConveyorBand 12

#pragma pack(push, 1)
typedef struct tSensor 
  {
    DINT MinimaleSpot;
    DINT MinimaleCounter;
    DINT MinimaalSSW;
    DINT Din;
    DINT DiHW;
    DINT i;
  } tSensor;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct tTabel 
  {
    DINT length;
  } tTabel;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct tVouwhaakDATA 
  {
    DINT Mask;
    DINT MaskIngegeven;
    DINT Lead;
    DINT Klephoogte;
    DINT Raakpunt;
    DINT Raakpunt_Corr;
    DINT Raakpunt_Corr_Max;
    DINT Raakpunt_Corr_Min;
    DINT Stoppunt;
    DINT Stoppunt_Corr;
    DINT Stoppunt_Corr_Max;
    DINT Stoppunt_Corr_Min;
    DINT Offset;
    DINT Offset_Corr;
    DINT Offset_Corr_Max;
    DINT Offset_Corr_Min;
    DINT Vrijloop;
    DINT Vrijloop_Corr;
    DINT Vrijloop_Corr_Max;
    DINT Vrijloop_Corr_Min;
    DINT Release;
    DINT Release_Corr;
    DINT Release_Corr_Max;
    DINT Release_Corr_Min;
    DINT Speedcorrectie;
    DINT Speedcorrectie_Max;
    DINT Speedcorrectie_Min;
    DINT Grote_Kleine_Haak;
    DINT iEncMul;
    DINT iEncDiv;
    DINT oSpeed;
    DINT oSensorHW;
    DINT oSensorZeroHW;
    DINT oJamdet;
    DINT iJamBoxlength;
    DINT iJamReset;
    DINT MinSpot;
    DINT SExtraBox;
    DINT OnOff;
    DINT Motor_LR;
    DINT WriteProt;
    DINT iSensorOffsetGH;
    DINT PapierlijnGH;
    DINT RusthoekGH;
    DINT DoorloopGH;
    DINT iSensorOffsetKH;
    DINT PapierlijnKH;
    DINT DoorloopKH;
    DINT RusthoekKH;
    DINT Nulhoek;
    DINT T1PD0;
    DINT T1PD1;
    DINT T1PD2;
    DINT T1PD3;
    DINT T1PD4;
    DINT T1PD5;
    DINT T2PD0;
    DINT T2PD1;
    DINT T2PD2;
    DINT T2PD3;
    DINT T2PD4;
    DINT T2PD5;
    DINT Mask_Max;
    DINT Mask_Min;
    DINT Lead_Max;
    DINT Lead_Min;
    DINT Klephoogte_Max;
    DINT Klephoogte_Min;
    DINT iJamBoxlength_Max;
    DINT iJamBoxlength_Min;
    DINT iPosZeroOffset;
    DINT FeedbackMotor;
  } tVouwhaakDATA;
#pragma pack(pop)

